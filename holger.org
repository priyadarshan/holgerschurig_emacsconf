#+TITLE: Holger's Emacs Startup File
#+SEQ_TODO: TODO DISABLED | DONE
# OPTIONS: H:2 num:nil toc:t
# STARTUP: oddeven
# STARTUP: overview

* use-package

See http://github.com/jwiegley/use-package/
 or http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html


(use-package PACKAGE
:init (...)                      run if defered, when :commands is there, or after requiring the package
:config (...)                    only run after modules has been are loaded
:idle (...)                      like :init, but run when emacs is idle
:idle-priority 3                 lower is run first, default is 5
:pre-load                        run before anything else
:bind ("C-." . testpkg))         key binding, try M-x describe-personal-keybindings
:bind (("M-o l" . highlight-lines-matching-regexp)
       ("M-o r" . highlight-regexp)
       ("M-o w" . highlight-phrase))
:commands testpkg                create autoload, not needed for things in :bind
:mode "\\.rb\\'"
:mode ("\\.py\\'" . python-mode)
:interpreter "ruby"
:interpreter ("python" . python-mode)
:ensure t                        load it from MELPA
:defer t
:demand t                        opposite of :defer
:disabled t                      stop using this
:if window-system                predicate, e.g. to emacs server only for graphical emacs
:defines empty-variable-defs     helps with byte-compilation
:load-path "site-lisp/ess/lisp/"
:diminish abbrev-mode
)

#+BEGIN_SRC emacs-lisp
;; Please don't load outdated byte code
(setq load-prefer-newer t)

;; ELPA might use Emacs-W3 to get files, and this in turn sets cookies.
;; Move the cookie file out into the =tmp/= directory.
(setq url-configuration-directory (concat dotfiles-dir "tmp/"))

(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

(package-initialize)

;; Bootstrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+END_SRC


* OS and environment

#+BEGIN_SRC emacs-lisp
(defconst ms-windows (equal window-system 'w32))
#+END_SRC

* Load private data

#+BEGIN_SRC emacs-lisp
(load (concat dotfiles-dir "private.el") 'noerror 'nomessage)
#+END_SRC

* Cursor
** Nicer scroll handling

Normally, Emacs does a "jumpy" scroll when you scroll exceeds the
currend displayed buffer. This makes scrolling smooth.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 1000000
      scroll-preserve-screen-position 1)
#+END_SRC
** multiple key binding
First we define code that allows us to bind multiple functions to
repeated commands. Taken from
[[http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding]]:

#+BEGIN_SRC emacs-lisp
(defvar seq-times 0
  "Stores number of times command was executed.  It cotnains
random data before `seq-times' macro is called.")

(defmacro seq-times (&optional name max &rest body)
  "Returns number of times command NAME was executed and updates
`seq-times' variable accordingly.  If NAME is nil `this-command'
will be used.  If MAX is specified the counter will wrap around
at the value of MAX never reaching it.  If body is given it will
be evaluated if the command is run for the first time in a
sequence."
  (declare (indent 2))

  ;; Build incrementation part
  (setq max (cond ((null max) '(setq seq-times (1+ seq-times)))
		  ((atom max) (if (and (integerp max) (> max 0))
				  `(setq seq-times (% (1+ seq-times) ,max))
				'(setq seq-times (1+ seq-times))))
		  (t          `(let ((max ,max))
				 (if (and (integerp max) (> max 0))
				     (setq seq-times (% (1+ seq-times) max))
				   (setq seq-times (1+ seq-times)))))))

  ;; Make macro
  (if (eq name 'last-command)
      max
    (cond ((null  name) (setq name 'this-command))
	  ((consp name) (setq name `(or ,name this-command))))
    `(if (eq last-command ,name)
	 ,max
       ,@body
       (setq seq-times 0))))

(defmacro seq-times-nth (name body &rest list)
  "Calls `seq-times' with arguments NAME, length and BODY
and (where length is the number of elements in LIST) then returns
`seq-times'th element of LIST."
  (declare (indent 2))
  `(nth (seq-times ,name ,(length list) ,body) ',list))

(defmacro seq-times-do (name body &rest commands)
  "Calls `seq-times' with arguments NAME, length and BODY (where
length is the number of COMMANDS) and then runs `seq-times'th
command from COMMANDS."
  (declare (indent 2))
  `(eval (nth (seq-times ,name ,(length commands) ,body) ',commands)))
#+END_SRC

** Home / End
Based on this, we define new home/end functions:

#+BEGIN_SRC emacs-list
(defvar my--previous-position 0)

(defun my-home ()
  "Depending on how many times it was called moves the point to:

- begin of indentation
- beginning of line
- begin of function
- beginning of buffer
- back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
    (back-to-indentation)
    (beginning-of-line)
    (beginning-of-defun)
    (goto-char (point-min))
    (goto-char my--previous-position)))
(bind-key "C-a" 'my-home)
(bind-key "<home>" 'my-home)
#+END_SRC

And the same for end:

#+BEGIN_SRC emacs-lisp
(defun my-end ()
  "Depending on how many times it was called moves the point to:

- end of line
- end of function
- end of buffer
- back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
    (end-of-line)
    (forward-paragraph)
    (end-of-defun)
    (goto-char (point-max))
    (goto-char my--previous-position)))
(bind-key "C-e" 'my-end)
(bind-key "<end>" 'my-end)
#+END_SRC

** Recenter
This is built-in into Emacs 23, but doesn't work as nice, e.g. the
bottom position is almost identical to the middle position.

#+BEGIN_SRC emacs-lisp
(defun my-recenter ()
  "Depending on how many times it was called moves the point to:

- center of screen
- near start of screen
- near end of center
- back to where it was"
  (interactive)
  (let ((i 0) (old (window-start)))
    (while (and (<= (setq i (1+ i)) 6) (equal (window-start) old))
      (seq-times-do nil (setq my--previous-position (window-start))
	(recenter)
	(recenter 4)
	(recenter -1)
	(set-window-start (selected-window) my--previous-position)))))
(bind-key "C-l" 'my-recenter)
#+END_SRC

** Nicer goto-line

Doesn't modify minibuffer-history, but use it's own little history
list.

#+BEGIN_SRC emacs-lisp
(setq my-goto-line-history '())

(defun my-goto-line (line &optional buffer)
  "Goto LINE, counting from line 1 at beginning of buffer.
Normally, move point in the current buffer, and leave mark at the
previous position.  With just \\[universal-argument] as argument,
move point in the most recently selected other buffer, and switch to it.

If there's a number in the buffer at point, it is the default for LINE.

This function is usually the wrong thing to use in a Lisp program.
What you probably want instead is something like:
  (goto-char (point-min)) (forward-line (1- N))
If at all possible, an even better solution is to use char counts
rather than line counts."
  (interactive
   (if (and current-prefix-arg (not (consp current-prefix-arg)))
       (list (prefix-numeric-value current-prefix-arg))
     ;; Look for a default, a number in the buffer at point.
     (let* ((default
	      (save-excursion
		(skip-chars-backward "0-9")
		(if (looking-at "[0-9]")
		    (buffer-substring-no-properties
		     (point)
		     (progn (skip-chars-forward "0-9")
			    (point))))))
	    ;; Decide if we're switching buffers.
	    (buffer
	     (if (consp current-prefix-arg)
		 (other-buffer (current-buffer) t)))
	    (buffer-prompt
	     (if buffer
		 (concat " in " (buffer-name buffer))
	       "")))
       ;; Read the argument, offering that number (if any) as default.
       (list (read-from-minibuffer (format (if default "Goto line%s (%s): "
					     "Goto line%s: ")
					   buffer-prompt
					   default)
				   nil nil t
				   'my-goto-line-history
				   default)
	     buffer))))
  ;; Switch to the desired buffer, one way or another.
  (if buffer
      (let ((window (get-buffer-window buffer)))
	(if window (select-window window)
	  (switch-to-buffer-other-window buffer))))
  ;; Leave mark at previous position
  (or (region-active-p) (push-mark))
  ;; Move to the specified line number in that buffer.
  (save-restriction
    (widen)
    (goto-char (point-min))
    (if (eq selective-display t)
	(re-search-forward "[\n\C-m]" nil 'end (1- line))
      (forward-line (1- line)))))

(bind-key "M-g g"   'my-goto-line)
(bind-key "M-g M-g" 'my-goto-line)
#+END_SRC

* Yank and Delete
** Delete word or yank
The following may be of interest to people who (a) are happy with
"C-w" and friends for killing and yanking, (b) use
"transient-mark-mode", (c) also like the traditional Unix tty
behaviour that "C-w" deletes a word backwards. It tweaks "C-w" so
that, if the mark is inactive, it deletes a word backwards instead of
killing the region. Without that tweak, the C-w would create an error
text without an active region.

http://www.emacswiki.org/emacs/DefaultKillingAndYanking#toc2

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before unix-werase activate compile)
  "When called interactively with no active region, delete a single word
    backwards instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (save-excursion (backward-word 1) (point)) (point)))))
#+END_SRC
** Selection deletion
Use delete-selection mode:

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Deletion in readonly buffer
Be silent when killing text from read only buffer:

#+BEGIN_SRC emacs-lisp
(setq kill-read-only-ok t)
#+END_SRC

** Join lines at killing
If at end of line, join with following; otherwise kill line.
Deletes whitespace at join.

#+BEGIN_SRC emacs-lisp
(defun kill-and-join-forward (&optional arg)
  "If at end of line, join with following; otherwise kill line.
Deletes whitespace at join."
  (interactive "P")
  (if (and (eolp) (not (bolp)))
      (delete-indentation t)
    (kill-line arg)))

(bind-key "C-k" 'kill-and-join-forward)
#+END_SRC

** DISABLED: Yank

# BEGIN_SRC emacs-lisp
(defun my-yank (&optional arg)
  "Reinsert (\"paste\") the last stretch of killed text.
More precisely, reinsert the stretch of killed text most recently
killed OR yanked. Put mark at end, and set point at
beginning (the opposite of `yank'). With just
\\[universal-argument] as argument, same but put mark at
beginning (and point at end). With argument N, reinsert the Nth
most recently killed stretch of killed text.

When this command inserts killed text into the buffer, it honors
`yank-excluded-properties' and `yank-handler' as described in the
doc string for `insert-for-yank-1', which see.

See also the command `yank-pop' (\\[yank-pop])."
  (interactive "*P")
  (setq yank-window-start (window-start))
  ;; If we don't get all the way thru, make last-command indicate that
  ;; for the following command.
  (setq this-command t)
  (push-mark (point))
  (insert-for-yank (current-kill (cond
				  ((listp arg) 0)
				  ((eq arg '-) -2)
				  (t (1- arg)))))
  (unless (consp arg)
      ;; This is like exchange-point-and-mark, but doesn't activate the mark.
      ;; It is cleaner to avoid activation, even though the command
      ;; loop would deactivate the mark because we inserted text.
      (goto-char (prog1 (mark t)
		   (set-marker (mark-marker) (point) (current-buffer)))))
  ;; If we do get all the way thru, make this-command indicate that.
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)

(bind-key "C-y" 'my-yank)
# END_SRC

** Dynamic char deletion

The following is from Boojum's post in
[[http://www.reddit.com/r/emacs/comments/b1r8a/remacs_tell_us_about_the_obscure_but_useful/]].

I don't want to kill the comment, just the prefix to it. So that

// The quick brown fox[]
// jumps over the lazy dog.

becomes

// The quick brown fox[] jumps over the lazy dog.

#+BEGIN_SRC emacs-lisp
(defun delete-char-dynamic (&optional arg)
  "If at end of line, intelligently join to the following;
otherwise delete."
  (interactive "p")
  (if (or (not (eolp)) (bolp))
      (delete-char arg)
    (let ((start (point))
          (in-comment (eq (get-text-property (point) 'face)
                          'font-lock-comment-face)))
      (forward-char)
      (skip-chars-forward " \  ")
      (if (and in-comment (looking-at comment-start-skip))
          (goto-char (match-end 0)))
      (delete-region start (point))
      (when (and (not (eolp))
                 (/= (char-before) ? )
                 (/= (char-before) ?\  ))
        (insert-char ?  1)
        (backward-char)))))

;; Make delete-selection-mode work with it
(put 'delete-char-dynamic 'delete-selection 'supersede)

;; Rebind DELETE and friends to our version
(bind-key "<deletechar>" 'delete-char-dynamic)
(bind-key "<delete>" 'delete-char-dynamic)
(bind-key "C-d" 'delete-char-dynamic)
#+END_SRC
* Completion

#+BEGIN_SRC emacs-lisp
(setq ;; ignore case when reading a file name completion
      read-file-name-completion-ignore-case t
      ;; do not consider case significant in completion (GNU Emacs default)
      completion-ignore-case t
      ;; lets TAB do completion as well
      tab-always-indent 'complete
      completions-format 'vertical)
#+END_SRC

* Windows handling
** delete-window
If only one window in frame, `delete-frame'.

From http://www.emacswiki.org/emacs/frame-cmds.el

#+BEGIN_SRC emacs-lisp
(defadvice delete-window (around delete-window (&optional window) activate)
  (interactive)
  (save-current-buffer
    (setq window (or window (selected-window)))
    (select-window window)
    (if (one-window-p t)
	(delete-frame)
      ad-do-it (selected-window))))
#+END_SRC
** new kill-buffer-and-window
Replacement for interactive `kill-buffer'. We cannot redefine
`kill-buffer', because other elisp code relies on it's exact
behavior.

#+BEGIN_SRC emacs-lisp
(defun my--kill-buffer-and-window (&optional buffer)
  "Kill buffer BUFFER-OR-NAME.
The argument may be a buffer or the name of an existing buffer.
Argument nil or omitted means kill the current buffer. Return t
if the buffer is actually killed, nil otherwise.

Unlike `kill-buffer', this also will delete the current window if
there are several windows open."
  (interactive)
  (setq buffer (or buffer (current-buffer)))
  (unless (one-window-p)
    (delete-window))
  (kill-buffer buffer)
  ;; TODO: only delete the frame if it isn't the first one
  ;; (when (> (length (frame-list)) 1)
  ;;   (delete-frame))
  )

(bind-key "C-x k" 'my--kill-buffer-and-window)
#+END_SRC

** Window sizing
#+BEGIN_SRC emacs-lisp
(bind-key "<M-down>" 'enlarge-window)

(bind-key "<M-up>" 'shrink-window)

#+END_SRC

** Window zooming (F5)

If there is only one window displayed, act like C-x 2. If there are
two windows displayed, act like C-x 1

#+BEGIN_SRC emacs-lisp
(defun my-zoom-next-buffer2 ()
  (let ((curbuf (current-buffer))
	(firstbuf nil))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
	;(princ (format "name %s, fn %s\n" (buffer-name) buffer-file-name))
	(unless (or
		 ;; Don't mention internal buffers.
		 (string= (substring (buffer-name) 0 1) " ")
		 ;; No buffers without files.
		 (not buffer-file-name)
		 ;; Skip the current buffer
		 (eq buffer curbuf)
		 )
	  ;(princ (format " nme %s, fn %s\n" (buffer-name) buffer-file-name))
	  (unless firstbuf
	    (setq firstbuf buffer))
	    ;;(print buffer)
	  )))
    (when firstbuf
      ;(princ (format "new buffer: %s.\n" firstbuf))
      (bury-buffer)
      (switch-to-buffer firstbuf)
      )
  )
)

(defun my-explode-window ()
  "If there is only one window displayed, act like C-x2. If there
are two windows displayed, act like C-x1:"
  (interactive)
  (if (one-window-p t)
      (progn
	(split-window-vertically)
	(other-window 1)
	(my-zoom-next-buffer2)
	(other-window -1))
    (delete-other-windows)
  ))

(bind-key "<f5>" 'my-explode-window)
#+END_SRC
* Buffers

#+BEGIN_SRC emacs-lisp

;; http://www.xsteve.at/prg/emacs/bubble-buffer.el
(defvar bubble-buffer-max-display-length (- (frame-width) 5)
  "Maximum number of characters to display in the minibuffer when bubbling.")

(defvar bubble-buffer-omit-regexp "\\*"
  "Regexp for buffer-names that should be skipped when bubbling buffers with
bubble-buffer-next and bubble-buffer-previous.
For example you could use \"\\\\*.+\\\\*\" to exclude all buffers that contain two *'s.")

(defun bubble-buffer-omit-buffer (buffer)
  "return nil if the buffer should be omitted, otherwise the buffer name"
  (let ((buf-name (buffer-name buffer)))
    (unless (and bubble-buffer-omit-regexp (string-match bubble-buffer-omit-regexp buf-name))
      buf-name)))


(defun bubble-buffer-next-2()
  (if (not (eq last-command 'bubble-buffer-next))
      (progn (setq bubble-buffer-list (copy-alist (buffer-list)))
             (delq (get-buffer " *Minibuf-0*") bubble-buffer-list)
             (delq (get-buffer " *Minibuf-1*") bubble-buffer-list)
             (setq bubble-buffer-buried-list nil)))
  (let* ((cur-buf (current-buffer))
         (b-list (delq nil (mapcar 'bubble-buffer-omit-buffer (cdr bubble-buffer-list))))
         (doit b-list)
         (rest nil)
         (s))
    (while doit
      (add-to-list 'bubble-buffer-buried-list (car bubble-buffer-list))
      (bury-buffer (car bubble-buffer-list))
      (setq bubble-buffer-list (cdr bubble-buffer-list))
      (switch-to-buffer (car bubble-buffer-list))
      (setq rest (cdr (copy-alist bubble-buffer-list)))
      (while rest
        (bury-buffer (car rest))
        (setq rest (cdr rest)))
      (setq doit (not (bubble-buffer-omit-buffer (current-buffer)))))
    ;;(message "%S" bubble-buffer-list)
    (if b-list
        (progn
          (setq b-list (cdr b-list))
          (setq s (concat
                   "Next: "
                   (if b-list (format "%S" b-list "") "")
                   "[end]"))
          (message "%s" (concat
			 (substring s 0 (min bubble-buffer-max-display-length (length s)))
			 " ...")))
      (message "Already at the end of the buffer-list"))))


(defun bubble-buffer-previous-2()
  (unless (eq last-command 'bubble-buffer-next)
    (setq bubble-buffer-buried-list nil))
  (setq this-command 'bubble-buffer-next)
  (if bubble-buffer-buried-list
      (progn
        (let ((doit t)
              (s)
              (b-list))
          (while doit
            (add-to-list 'bubble-buffer-list (car bubble-buffer-buried-list))
            (switch-to-buffer (car bubble-buffer-buried-list))
            (setq bubble-buffer-buried-list (cdr bubble-buffer-buried-list))
            (setq doit (not (bubble-buffer-omit-buffer (current-buffer))))))
        (setq b-list (delq nil (mapcar 'bubble-buffer-omit-buffer bubble-buffer-buried-list)))
        (setq s (concat
                 "Prev: "
                 (if b-list (format "%S" b-list "") "")
                 "[start]"))
        (message "%s" (concat
		       (substring s 0 (min bubble-buffer-max-display-length (length s))) " ...")))
    (message "Already at the start of the bubble-buffer-list")))


(defun bubble-buffer-next()
  "If you have only one window open, then bubble down one entry in the buffer list.
Switch to the next buffer on the list.

If more than one window is open, then just move to the next one."
  (interactive)
  (if (eq (count-windows) 1)
      (bubble-buffer-next-2)
    (other-window 1)
    ))


(defun bubble-buffer-previous()
  "If you have only one window open, then undo one bubbling step from bubble-buffer-next.
Switch to the buffer before the bubbled up buffer in the buffer list

If more than one window is open, then just move to the previous one."
  (interactive)
  (if (eq (count-windows) 1)
      (bubble-buffer-prev-2)
    (other-window -1)
    ))


(bind-key "<f6>"   'bubble-buffer-next)
(bind-key "S-<f6>" 'bubble-buffer-previous)


;; Insert buffer at current position
(bind-key "C-x I" 'insert-buffer)


;; Protect *scratch*
;; http://www.emacswiki.org/emacs/ProtBuf

(defvar protect-buffer-from-kill-mode nil
  "*If non-`nil', then prevent buffer from being accidentally killed.
This variable is local to all buffers.")
(progn
  (make-variable-buffer-local 'protect-buffer-from-kill-mode)
  (put 'protect-buffer-from-kill-mode 'permanent-local t)
  (or (assq 'protect-buffer-from-kill-mode minor-mode-alist)
      (setq minor-mode-alist (cons '(protect-buffer-from-kill-mode " prot")
                                   minor-mode-alist))))

(defun protect-buffer-from-kill-mode (&optional prefix buffer)
  "Protect buffer from being killed.
To remove this protection, call this command with a negative prefix argument."
  (interactive "P")
  (or buffer (setq buffer (current-buffer)))
  (save-excursion
    ;; Each cond does its own set-buffer *after* comparing prefix just in
    ;; case there's a buffer-local variable `prefix' to screw up the works.
    (cond
     ((null prefix)
      (set-buffer buffer)
      (setq protect-buffer-from-kill-mode
            (not protect-buffer-from-kill-mode)))
     ((>= prefix 0)
      (set-buffer buffer)
      (setq protect-buffer-from-kill-mode t))
     (t
      (set-buffer buffer)
      (setq protect-buffer-from-kill-mode nil)))
    ;; This is always done because kill-buffer-query-functions might have
    ;; been buffer-local when this package was initially loaded, leaving
    ;; the global value unchanged.
    (add-hook 'kill-buffer-query-functions 'protect-buffer-from-kill)))

;; This function is listed in kill-buffer-query-functions; it should return
;; nil if the buffer should not be killed, t otherwise.
(defun protect-buffer-from-kill ()
  (cond
   (protect-buffer-from-kill-mode
    (message "Buffer \"%s\" is protected from being killed." (buffer-name))
    nil)
   (t)))

(add-hook 'kill-buffer-query-functions 'protect-buffer-from-kill)

(protect-buffer-from-kill-mode nil (get-buffer "*scratch*"))
#+END_SRC
* Entering/exiting Emacs

#+BEGIN_SRC emacs-lisp
;; get rid of yes-or-no questions - y or n is enough
(fset 'yes-or-no-p 'y-or-n-p)

;; Delete 'process-kill-buffer-query-function from kill-buffer-query-function.
;; http://www.masteringemacs.org/articles/2010/11/14/disabling-prompts-emacs/
(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function kill-buffer-query-functions))

(setq ;; Do without annoying startup msg.
      inhibit-startup-message t

      ;; This inhibits the initial startup echo area message.
      inhibit-startup-echo-area-message "schurig"

      ;; Don't ask when running revert-buffer
      revert-without-query (quote (""))

      ;; Empty scratch message
      initial-scratch-message nil

      ;; Include current buffer name in the title bar
      frame-title-format '(buffer-file-name "%f" ("%b"))

      ;; Don't ask for killing emacs
      ;;(setq confirm-kill-emacs t)

      ;; Set up default editing mode.
      major-mode 'indented-text-mode

      ;; Custom file, part one
      custom-file (concat dotfiles-dir "custom.el")
      )

;; Custom file, part two
(if (file-exists-p custom-file) (load-file custom-file))
#+END_SRC

** Delete previous identical history entries
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t
      tabify-regexp "^\t* [ \t]+"
      )
#+END_SRC

** Don't run version control hooks

Don't run vc-git & friends, we have magit

#+BEGIN_SRC emacs-lisp
(defun vc-find-file-hook ()
  "Dummy, overriding the one in vc-hooks.el"
  (setq vc-mode nil))
(setq vc-handled-backends nil)
#+END_SRC
* File opening/saving

#+BEGIN_SRC emacs-lisp
(use-package ffap
	     :commands
	     find-file-at-point
	     :bind ("C-x C-p" . find-file-at-point)
	     )

;; rebind C-x C-f and others to the ffap bindings (see variable ffap-bindings)
;; (ffap-bindings)
;; C-u C-x C-f finds the file at point
;; (setq ffap-require-prefix t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Auto decompress compressed files.
(auto-compression-mode t)

(setq ;; Never show GTK file open dialog
      use-file-dialog nil
      ;; don't add newlines to end of buffer when scrolling, but show them
      next-line-add-newlines nil
      ;; Preserve hard links to the file youÂ´re editing (this is
      ;; especially important if you edit system files)
      backup-by-copying-when-linked t
      ;; Just never create backup files at all
      ;;make-backup-files nil
      backup-directory-alist (list (cons "." (concat dotfiles-dir "tmp/bak/")))
      ;; Make sure your text files end in a newline
      require-final-newline t
      ;; Disable auto-save (#init.el# file-names)
      auto-save-default nil)

;; Don't open Qt's *.pro files as IDLWAVE files TODO move to development
(add-to-list 'auto-mode-alist '("\\.pro$" . fundamental-mode))

;; Open *.h files normally in c++ mode
(add-to-list 'auto-mode-alist '("\\.h$" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-mode))

(setq auto-save-list-file-prefix (concat dotfiles-dir "tmp/auto-save-list/saves-"))


;; quickly safe
(bind-key "<f2>" 'save-buffer)
#+END_SRC
* Display
** Display: Frame display

#+BEGIN_SRC emacs-lisp
;; ~/.Xresources
;; Emacs.geometry: 120x55
;; Emacs.Font:	terminus 11
;; Emacs.verticalScrollBars: right
;; Emacs.toolBar: off
;; Emacs*Background: #000000
;; Emacs*Foreground: #7f7f7f

;; Automatically merge ~/.Xresources after changes
(defun merge-x-resources ()
  (let ((file (file-name-nondirectory (buffer-file-name))))
    (when (or (string= file ".Xdefaults")
	      (string= file ".Xresources"))
      (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
      (message (format "Merged %s into X resource database" file)))))
(add-hook 'after-save-hook 'merge-x-resources)

;; Where to position a new frame (C-x 5 2)
;; Also where to open a new frame from emacsclient
;; (setq default-frame-alist '((xxx . 10)
;; 			    (left-fringe . 1)
;; 			    (right-fringe . 0)
;; 			    (menu-bar-lines . 1)
;; 			    (tool-bar-lines . 1)
;; 			    (left . 0))

(if ms-windows
    (setq initial-frame-alist
	  '(
	    ;;(background-color . "black")
	    ;;(foreground-color . "LightGray")
	    (horizontal-scroll-bars . nil)
	    (vertical-scroll-bars . right)
	    (tool-bar-lines . 0)
	    (left-fringe . 1)
	    (right-fringe . 0)))
  (setq initial-frame-alist
	`(;;(background-color . "black")
	  ;;(foreground-color . "LightGray")
	  (horizontal-scroll-bars . nil)
	  (vertical-scroll-bars . right)
	  (tool-bar-lines . 0)
	  (left-fringe . 1)
	  (right-fringe . 0)
	  ;;(height . ,(if (or (not my-win32)
	  ;;		   have-win32-sixbyten-font)
	  ;;	       (my-frame-percent-to-char-height 97)
	  ;;	     70))
	  (width . 120)
	  (height . 55)
	  )))

;; default-frame-alist is defined in terms of initial-frame-alist.  Don't
;; use copy-sequence here -- it doesn't copy the list elements, just the
;; list's cons cells.  Use copy-alist instead.
(setq default-frame-alist (copy-alist initial-frame-alist))
#+END_SRC

** Display: Font lock and faces
*** Key word font-lock
#+BEGIN_SRC emacs-lisp
(defface my--todo-face
  '((t :foreground "red"
       :weight bold))
  "Font for showing TODO words."
  :group 'basic-faces)

;; Highlight each of TODO TODO: FIXME FIXME: XXX XXX: \todo
(defun my--hint-facify ()
   (unless (or (eq 'diff-mode major-mode) (eq 'script-mode major-mode))
     (font-lock-add-keywords nil '(
	 ("\\(\\<\\(\\(FIXME\\|TODO\\|XXX\\):?\\>\\)\\|\\\\todo\\)" 1 'my--todo-face t)
	 ))))

(add-hook 'font-lock-mode-hook 'my--hint-facify)
#+END_SRC

*** Font faces

Based on from
http://www.reddit.com/r/emacs/comments/9nh64/ask_emacs_which_color_theme_do_you_use/,
by Zenspider

#+BEGIN_SRC emacs-lisp
(custom-set-faces

 '(font-lock-constant-face
   ((((class color) (min-colors 88) (background light)) (:foreground "SlateBlue4"))))

 '(font-lock-string-face
   ((((class color) (min-colors 88) (background light)) (:foreground "Forest Green"))))

 '(font-lock-keyword-face ((t (:weight bold))))
 ;; Selected text
 '(region ((t (:background "gold" :foreground "gtk_selection_fg_color"))))
 )
#+END_SRC

** Display: Truncation lines

#+BEGIN_SRC emacs-lisp
(setq default-truncate-lines t)
(setq truncate-partial-width-windows nil)
(defun my-wrap-mode-on ()
  "Minor mode for making buffer not wrap long lines to next line."
  (interactive)
  (setq truncate-lines nil))

(defun my-wrap-mode-off ()
  "Minor mode for making buffer wrap long lines to next line."
  (interactive)
  (setq truncate-lines t))

(defun my-toggle-wrap-mode ()
  "Switch wrap mode from wrap to non-wrap, or vice-versa."
  (interactive)
  (if (eq truncate-lines nil)
      (my-wrap-mode-off)
    (my-wrap-mode-on)))
#+END_SRC

** Display: Whitespace

Let typing errors be obvious

#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook
	  '(lambda ()
	     ;; This hack allows the diff-mode hook to set the
	     ;; variable to -1. The find-file-hook fires after the
	     ;; diff-mode hook, so we get the -1 and are able to turn
	     ;; off the display of trailing whitespaces.
	     (if (eq show-trailing-whitespace -1)
		 (setq show-trailing-whitespace nil)
	       (setq show-trailing-whitespace t))))
#+END_SRC
** Display: General

#+BEGIN_SRC emacs-lisp
;; Avoid Emacs hanging for a while changing default font
(modify-frame-parameters nil '((wait-for-wm . nil)))

;; Display various non-editing buffers in their own frames
(add-to-list 'special-display-buffer-names "*Backtrace*")

;; Display those special buffer frames without a tool bar
;; now in .Xresources
;; (add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))

(if window-system
    ;; X11, Windows, etc
    (progn
      ;; Windowing systems are fast enought
      (column-number-mode t)
      ;; Turn off blinking
      (blink-cursor-mode -1)
      )
  ;; Text mode
  (progn
    ;; No "very" visible cursor
    (setq visible-cursor nil)
    ))

;; Visible bell, beeps are annoying
(setq visible-bell t)

;; Let parenthesis behave
(show-paren-mode 1)
(setq show-paren-delay 0
      blink-matching-parent nil)
(set-face-background 'show-paren-match-face "#d0d0d0")


;; Display page delimiter ^L as a horizontal line
(or standard-display-table (setq standard-display-table (make-display-table)))
(aset standard-display-table ?\f (vconcat (make-vector 72 ?-) "^L"))

;; Let emacs react way faster
(setq echo-keystrokes 0.1
      idle-update-delay 0.35)
#+END_SRC

** Display: Minibuffer

#+BEGIN_SRC emacs-lisp
;; C-c clears minibuffer
(define-key minibuffer-local-map "\C-c" (lambda () (interactive) (delete-minibuffer-contents)))

(setq
 ;; Don't insert current directory into minubuffer
 insert-default-directory nil
 ;; enable recursive minibuffer
 enable-recursive-minibuffers nil
 ;; minibuffer window expands vertically as necessary to hold the text that
 ;; you put in the minibuffer
 resize-mini-windows t
 )

;; dim the ignored part of the file name
(file-name-shadow-mode 1)

;; allow to type space chars in minibuffer input
;; (for `timeclock-in', for example)
(define-key minibuffer-local-completion-map " " nil)
(define-key minibuffer-local-must-match-map " " nil)
#+END_SRC


** Display: Menu

Get rid of the Games in the Tools menu.

#+BEGIN_SRC emacs-lisp
(define-key menu-bar-tools-menu [games] nil)
#+END_SRC
* Searching
** Package: isearch
#+BEGIN_SRC emacs-lisp
(setq ;; Scrolling while searching
      isearch-allow-scroll t

      ;; Save Isearch stuff
      isearch-resume-in-command-history t)

(bind-key "C-y" 'isearch-yank-kill isearch-mode-map)
#+END_SRC

** grep

Prompts you for an expression, defaulting to the symbol that your
cursor is on, and greps for that in the current directory and all
subdirectories:

#+BEGIN_SRC emacs-lisp
(defun my-grep ()
  "grep the whole directory for something defaults to term at cursor position"
  (interactive)
  (let ((default (thing-at-point 'symbol)))
    (let ((needle (or (read-string (concat "grep for '" default "': ")) default)))
      (setq needle (if (equal needle "") default needle))
      (grep (concat "egrep -s -i -n -r " needle " *")))))

(bind-key "C-x g" 'my-grep)

#+END_SRC

** Invoke isearch from Occur

#+BEGIN_SRC emacs-lisp
(defun isearch-occur ()
  "Invoke `occur' from within isearch."
  (interactive)
  (let ((case-fold-search isearch-case-fold-search))
    (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))
  (pop-to-buffer "*Occur*"))

(bind-key "C-o" 'isearch-occur isearch-mode-map)
#+END_SRC
* Help
** Go to last help buffer
Make 'l' (like last) go to the previous position in emacs help.

[[http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks]]

#+BEGIN_SRC emacs-lisp
(add-hook 'help-mode-hook
	  '(lambda ()
	     (bind-key "I" 'help-go-back help-mode-map)))
#+END_SRC

** F1 key searches in help or opens man page

#+BEGIN_SRC emacs-lisp
(defun my-help ()
  "If function given tries to `describe-function' otherwise uses
`manual-entry' to display manpage of a `current-word'."
  (interactive)
  (let ((var (variable-at-point)))
    (if (symbolp var)
	(describe-variable var)
      (let ((fn (function-called-at-point)))
	(if fn
	    (describe-function fn)
	  (man (current-word)))))))

(bind-key "<f1>" 'my-help)
#+END_SRC

** Apropos

#+BEGIN_SRC emacs-lisp
;; check all variables and non-interactive functions as well
(setq apropos-do-all t)

;; Help should search more than just commands
(bind-key "C-h a" 'apropos)
#+END_SRC
* Miscelleanous
** Mouse

Paste at text-cursor, not at mouse-cursor:

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
** Localisation

A sentence doesn't end with two spaces:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
** Decimal entry of quoted characters
Use decimal for `C-q', not octal. Hey, who's using octal nowaydays?

#+BEGIN_SRC emacs-lisp
(setq read-quoted-char-radix 10)
#+END_SRC
** Swap RET and C-j

#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)

(bind-key "C-j" 'newline)
#+END_SRC
** dos2unix
#+BEGIN_SRC emacs-lisp
(defun dos2unix()
  "convert dos (^M) end of line to unix end of line"
  (interactive)
  (goto-char(point-min))
  (while (search-forward "\r" nil t) (replace-match "")))

; Fri,  1 Dec 2006 15:41:36 +0100
(defun 822date ()
  "Insert date at point format the RFC822 way."
  (interactive)
  (insert (format-time-string "%a, %e %b %Y %H:%M:%S %z")))
#+END_SRC

** DISABLED: Indent yanked text
Let yanked text immediately be indented, based on an old version of
[[http://www.emacswiki.org/emacs/AutoIndentation]]:

# TODO: update with a newer version

# BEGIN_SRC emacs-lisp
(defadvice yank (after indent-region activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode org-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (let ((mark-even-if-inactive t))
        (indent-region (region-beginning) (region-end) nil))))

(defadvice yank-pop (after indent-region activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode org-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (let ((mark-even-if-inactive t))
	(indent-region (region-beginning) (region-end) nil))))
# END_SRC


* Programming
** Commenting
#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" 'comment-dwim)
#+END_SRC
** Don't untabify if deleting a tab
Deleting past a tab normally changes tab into spaces. Don't do that,
kill the tab instead.

#+BEGIN_SRC emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+END_SRC

** Compilation
*** Byte compilation
#+BEGIN_SRC emacs-lisp
(defun my--bcc-compile-source-file (fullname)
  "Compiles an elisp file into the byte-cache"
  (let (cachename
        hist-ent loaded-from-bcc-cache
        bcc-loaded-fake-cache-entry)

    (when (and bcc-enabled
               (not (save-match-data
                      (bcc-in-blacklist fullname bcc-blacklist))))

      (setq cachename (file-truename (bcc-cache-file-name fullname)))
      (make-directory (file-name-directory cachename) t)

      (when (and bcc-regenerate-toplevel
                 (file-newer-than-file-p fullname cachename))

        (bcc-regenerate-cache fullname cachename nil))

      (when (file-readable-p cachename)
        (unless bcc-loaded-fake-cache-entry
          (setq loaded-from-bcc-cache t))))
    ))
#+END_SRC

*** Compile or byte-compile

#+BEGIN_SRC emacs-lisp
(defun my-compile ()
  "Compile elisp or cpp"
  (interactive)
  (delete-other-windows)
  (save-buffer)
  (if (or (eq major-mode 'lisp-mode) (eq major-mode 'emacs-lisp-mode))
      (progn
	(ignore-errors (my--kill-buffer-and-window (get-buffer-create "*Compile-Log*")))
	; Now try to compile this file
	(my--bcc-compile-source-file (buffer-file-name))
	)
    (progn
      (if (fboundp 'eproject-root)
	  (let ((default-directory (eproject-root)))
		  (compile compile-command))
	(compile compile-command)))))

(bind-key "<f7>" 'my-compile)


(defun set-compile-command (&optional cmd)
  "Helper for to set compile-command"
  (interactive "scmd: ")
  (setq compile-command cmd))
#+END_SRC

*** Auto close compile log if there are no errors

[[http://www.emacswiki.org/emacs/ModeCompile]]

#+BEGIN_SRC emacs-lisp
(defun compile-autoclose (buffer string)
  (cond ((string-match "finished" string)
	 ;; (message "Build maybe successful: closing window.")
	 (run-with-timer 1 nil
			 'delete-window
			 (get-buffer-window buffer t)))
	(t
	 (message "Compilation exited abnormally: %s" string))))
(setq compilation-finish-functions 'compile-autoclose
      compilation-ask-about-save nil
      compilation-scroll-output t)
#+END_SRC

*** Error navigation

#+BEGIN_SRC emacs-lisp

(bind-key "<f8>" 'next-error)

(bind-key "S-<f8>" 'previous-error)
#+END_SRC
** Package: magit

=magit-rigid-key-bindings= must be set before magit is loaded. It will
remove the new key bindings that use pop-up buffers.

#+BEGIN_SRC emacs-lisp
(setq magit-rigid-key-bindings t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :config
  (progn
     (setq magit-save-some-buffers 'dontask
	   magit-commit-all-when-nothing-staged nil
	   magit-stage-all-confirm nil
	   magit-unstage-all-confirm nil
	   magit-status-buffer-switch-function 'switch-to-buffer
	   magit-refresh-file-buffer-hook '(revert-buffer)
	   magit-diff-use-overlays t
	   )
     ;(set-face-foreground 'magit-diff-add "green4")
     ;(set-face-foreground 'magit-diff-del "red3")
     )
  :bind ("C-c m" . magit-status)
  :commands (magit-get-top-dir)
)

;;(autoload 'magit-get-top-dir "magit" nil t)

(defun magit-refresh-status ()
  (magit-git-exit-code "update-index" "--refresh")
  (magit-create-buffer-sections
    (magit-with-section 'status nil
      (run-hooks 'magit-status-insert-sections-hook)))
  (run-hooks 'magit-refresh-status-hook))
#+END_SRC
** ffap (find-file-at-point)

#+BEGIN_SRC emacs-lisp
(use-package ffap
  :commands
  find-file-at-point
  :bind (("C-x C-p" . find-file-at-point))
  )

;; rebind C-x C-f and others to the ffap bindings (see variable ffap-bindings)
;; (ffap-bindings)
;; C-u C-x C-f finds the file at point
;; (setq ffap-require-prefix t)
#+END_SRC

** column-marker

#+BEGIN_SRC emacs-lisp
(defun my-column-marker-at-80 ()
  (interactive)
  (column-marker-1 80)
)

(use-package column-marker
  :ensure t
  :init
  (add-hook 'c-mode-hook 'my-column-marker-at-80)
  )
#+END_SRC


* Package: ibuffer

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind (("C-x C-b" . ibuffer))
)
#+END_SRC

This is old code that I still need to evaluate:

(setq ibuffer-display-summary nil
      ;;ibuffer-use-header-line t
      ;;ibuffer-default-sorting-mode 'major-mode
      ;;
      ;; Don't ask when killing a buffer
      ibuffer-expert t
      ;;
      ibuffer-show-empty-filter-groups nil
      ibuffer-old-time 4
      ;; And now my filters:
      ibuffer-saved-filter-groups
      '(("default"
	 ("dired" (mode . dired-mode))
	 ("erc" (mode . erc-mode))
	 ("Org-Mode" (or
		    (name . "^\\*Calendar\\*$")
		    (name . "^diary$")
		    (name . "^\\*Org.*")
		    (mode . muse-mode)))
	 ("Mail" (or
		  (name . "^contacts$")
		  (name . "^\\*BBDB\\*$")
		  (name . "^Folder$")
		  (name . "^Summary$")
		  (name . "^\\.draft/")))
	 ("magit" (name . "^\\*magit"))
	 ("emacs" (name . "^\\*"))
	 )))

;; reverse group order
(defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups ()
						   activate)
  (setq ad-return-value (nreverse ad-return-value)))

(add-hook 'ibuffer-mode-hook
	  (lambda ()
	    (ibuffer-auto-mode 1)
	    (ibuffer-switch-to-saved-filter-groups "default")))

(defun my-ibuffer ()
  "Open ibuffer with cursor pointed to most recent buffer name"
  (interactive)
  (let ((recent-buffer-name (buffer-name)))
    (ibuffer)
    (ibuffer-jump-to-buffer recent-buffer-name)))

;(bind-key "C-x C-b" 'my-ibuffer)

;; http://curiousprogrammer.wordpress.com/2009/04/02/ibuffer/
(defun ibuffer-ediff-marked-buffers ()
  (interactive)
  (let* ((marked-buffers (ibuffer-get-marked-buffers))
         (len (length marked-buffers)))
    (unless (= 2 len)
      (error (format "%s buffer%s been marked (needs to be 2)"
                     len (if (= len 1) " has" "s have"))))
    (ediff-buffers (car marked-buffers) (cadr marked-buffers))))
(bind-key "e" 'ibuffer-ediff-marked-buffers ibuffer-mode-map)

** Package: ido
* Package: ace-jump-buffer

#+BEGIN_SRC emacs-lisp
(use-package ace-jump-buffer
  :ensure t
  :bind ("C-c j" . ace-jump-buffer)
  )
#+END_SRC
* Package: ace-jump-mode

#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :bind ("C-." . ace-jump-mode)
)
#+END_SRC

* Package: ido

#+BEGIN_SRC emacs-lisp
(use-package ido
  :defer nul
  :init (ido-mode 'both)
  :config
  (progn
    (setq ido-save-directory-list-file (concat dotfiles-dir "tmp/ido.last")
          ;:ido-everywhere t                       ; use for many file dialogs
          ido-max-work-file-list      50         ; remember many
          ;:ido-enable-flex-matching t             ; be flexible
          ;;ido-max-prospects 4                    ; don't spam my minibuffer
          ido-confirm-unique-completion t        ; wait for RET, even with unique completio
          ;;ido-enable-dot-prefix t              ; need "." to select hidden files
          ido-enable-tramp-completion nil
          ido-ignore-buffers '("\\`"
                               "^\*Mess"
                               "^\*Help*"
                               "^\*Back"
                               ".*Completion"
                               "^\*Ido")
          ido-ignore-directories '("\\`CVS/"
                                   "\\.svn/"
                                   "\\.git/"
                                   "\\`\\.\\./"
                                   "\\`\\./")

          ido-default-buffer-method 'selected-window
          ido-default-file-method 'selected-window
          ido-enable-flex-matching t
          ido-max-directory-size 100000)
    ;; Ignore some files from latex / latexmk
    (add-to-list 'completion-ignored-extensions ".aux")
    (add-to-list 'completion-ignored-extensions ".dvi")
    (add-to-list 'completion-ignored-extensions ".fdb_latexmk")
    (add-to-list 'completion-ignored-extensions ".idx")
    (add-to-list 'completion-ignored-extensions ".ilg")
    (add-to-list 'completion-ignored-extensions ".ind")
    (add-to-list 'completion-ignored-extensions ".pdf")
    (add-to-list 'completion-ignored-extensions ".toc")

    (use-package ido-vertical-mode
      :init (ido-vertical-mode 1))

    (use-package idomenu
      :bind ("C-x C-i" . idomenu))
    )
  )

(use-package ido-ubiquitous
  :init
  (ido-ubiquitous-mode 1)
  )
#+END_SRC
* Package: org-babel

#+BEGIN_SRC emacs-lisp
(use-package org
  :diminish org-mode
  :init
  (progn
    (setq org-src-fontify-natively t  ; inside src block use the colors like the major mode of the src type
          org-src-tab-acts-natively t ; inside a src block let tab act like it was in major mode of the src type
	  org-src-preserve-indentation t ; don't add two indentation spaces into src blocks
          )
    )
  )
#+END_SRC

* Package: savehist (save mini-buffer history)
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :init
   (setq savehist-file (concat dotfiles-dir "tmp/history.el")
      history-length 1000)
  :config
  (savehist-mode 1)
)
#+END_SRC
