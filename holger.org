#+TITLE: Holger's Emacs Startup File
#+SEQ_TODO: TODO DISABLED | DONE
# OPTIONS: H:2 num:nil toc:t
# STARTUP: oddeven
# STARTUP: overview

* package and use-package

See http://github.com/jwiegley/use-package/
 or http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html

(use-package PACKAGE
:init (...)                      run if defered, when :commands is there, or after requiring the package
:config (...)                    only run after modules has been are loaded
:idle (...)                      like :init, but run when emacs is idle
:idle-priority 3                 lower is run first, default is 5
:pre-load                        run before anything else
:bind ("C-." . testpkg))         key binding, try M-x describe-personal-keybindings
:bind (("M-o l" . highlight-lines-matching-regexp)
       ("M-o r" . highlight-regexp)
       ("M-o w" . highlight-phrase))
:commands testpkg                create autoload, not needed for things in :bind
:mode "\\.rb\\'"
:mode ("\\.py\\'" . python-mode)
:interpreter "ruby"
:interpreter ("python" . python-mode)
:ensure t                        load it from MELPA
:defer t
:demand t                        opposite of :defer
:disabled t                      stop using this
:if window-system                predicate, e.g. to emacs server only for graphical emacs
:defines empty-variable-defs     helps with byte-compilation
:load-path "site-lisp/ess/lisp/"
:diminish abbrev-mode
)

#+BEGIN_SRC emacs-lisp
;; Please don't load outdated byte code
(setq load-prefer-newer t)

;; ELPA might use Emacs-W3 to get files, and this in turn sets cookies.
;; Move the cookie file out into the =tmp/= directory.
(setq url-configuration-directory (concat dotfiles-dir "tmp/"))

(require 'package)
(setq package-enable-at-startup nil)

;(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/"))

(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

; When using melpa-stable instead of melpa, magit won't run:
;(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

(package-initialize)

;; Automatically install `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+END_SRC

* Entering/exiting Emacs
#+BEGIN_SRC emacs-lisp
(setq ;; Do without annoying startup msg.
      inhibit-startup-message t

      ;; This inhibits the initial startup echo area message.
      inhibit-startup-echo-area-message "schurig"

      ;; Don't ask when running revert-buffer
      revert-without-query (quote (""))

      ;; Empty scratch message
      initial-scratch-message nil

      ;; Include current buffer name in the title bar
      frame-title-format '(buffer-file-name "%f" ("%b"))

      ;; Set up default editing mode.
      major-mode 'indented-text-mode

      ;; Custom file, part one
      custom-file (concat dotfiles-dir "custom.el")

      ;; Delete previous identical history entries
      history-delete-duplicates t
      )
#+END_SRC

** Load customization file
#+BEGIN_SRC emacs-lisp
(if (file-exists-p custom-file) (load-file custom-file))
#+END_SRC
** Simpler yes or no prompt
Get rid of yes-or-no questions - y or n is enough
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
* Load private data

#+BEGIN_SRC emacs-lisp
(load (concat dotfiles-dir "private.el") 'noerror 'nomessage)
#+END_SRC
* Cursor
** Nicer scroll handling

Normally, Emacs does a "jumpy" scroll when you scroll exceeds the
currend displayed buffer. This makes scrolling smooth.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 1000000
      scroll-preserve-screen-position 1)
#+END_SRC
** multiple key binding
First we define code that allows us to bind multiple functions to
repeated commands. Taken from
[[http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding]]:

#+BEGIN_SRC emacs-lisp
(defvar seq-times 0
  "Stores number of times command was executed.  It cotnains
random data before `seq-times' macro is called.")

(defmacro seq-times (&optional name max &rest body)
  "Returns number of times command NAME was executed and updates
`seq-times' variable accordingly.  If NAME is nil `this-command'
will be used.  If MAX is specified the counter will wrap around
at the value of MAX never reaching it.  If body is given it will
be evaluated if the command is run for the first time in a
sequence."
  (declare (indent 2))

  ;; Build incrementation part
  (setq max (cond ((null max) '(setq seq-times (1+ seq-times)))
		  ((atom max) (if (and (integerp max) (> max 0))
				  `(setq seq-times (% (1+ seq-times) ,max))
				'(setq seq-times (1+ seq-times))))
		  (t          `(let ((max ,max))
				 (if (and (integerp max) (> max 0))
				     (setq seq-times (% (1+ seq-times) max))
				   (setq seq-times (1+ seq-times)))))))

  ;; Make macro
  (if (eq name 'last-command)
      max
    (cond ((null  name) (setq name 'this-command))
	  ((consp name) (setq name `(or ,name this-command))))
    `(if (eq last-command ,name)
	 ,max
       ,@body
       (setq seq-times 0))))

(defmacro seq-times-nth (name body &rest list)
  "Calls `seq-times' with arguments NAME, length and BODY
and (where length is the number of elements in LIST) then returns
`seq-times'th element of LIST."
  (declare (indent 2))
  `(nth (seq-times ,name ,(length list) ,body) ',list))

(defmacro seq-times-do (name body &rest commands)
  "Calls `seq-times' with arguments NAME, length and BODY (where
length is the number of COMMANDS) and then runs `seq-times'th
command from COMMANDS."
  (declare (indent 2))
  `(eval (nth (seq-times ,name ,(length commands) ,body) ',commands)))
#+END_SRC

** Home / End
Based on this, we define new home/end functions:

#+BEGIN_SRC emacs-list
(defvar my--previous-position 0)

(defun my-home ()
  "Depending on how many times it was called moves the point to:

- begin of indentation
- beginning of line
- begin of function
- beginning of buffer
- back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
    (back-to-indentation)
    (beginning-of-line)
    (beginning-of-defun)
    (goto-char (point-min))
    (goto-char my--previous-position)))
(bind-key "C-a" 'my-home)
(bind-key "<home>" 'my-home)
#+END_SRC

And the same for end:

#+BEGIN_SRC emacs-lisp
(defun my-end ()
  "Depending on how many times it was called moves the point to:

- end of line
- end of function
- end of buffer
- back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
    (end-of-line)
    (forward-paragraph)
    (end-of-defun)
    (goto-char (point-max))
    (goto-char my--previous-position)))
(bind-key "C-e" 'my-end)
(bind-key "<end>" 'my-end)
#+END_SRC

** Recenter
This is built-in into Emacs 23, but doesn't work as nice, e.g. the
bottom position is almost identical to the middle position.

#+BEGIN_SRC emacs-lisp
(defun my-recenter ()
  "Depending on how many times it was called moves the point to:

- center of screen
- near start of screen
- near end of center
- back to where it was"
  (interactive)
  (let ((i 0) (old (window-start)))
    (while (and (<= (setq i (1+ i)) 6) (equal (window-start) old))
      (seq-times-do nil (setq my--previous-position (window-start))
	(recenter)
	(recenter 4)
	(recenter -1)
	(set-window-start (selected-window) my--previous-position)))))
(bind-key "C-l" 'my-recenter)
#+END_SRC

** Nicer goto-line

Doesn't modify minibuffer-history, but use it's own little history
list.

#+BEGIN_SRC emacs-lisp
(setq my-goto-line-history '())

(defun my-goto-line (line &optional buffer)
  "Goto LINE, counting from line 1 at beginning of buffer.
Normally, move point in the current buffer, and leave mark at the
previous position.  With just \\[universal-argument] as argument,
move point in the most recently selected other buffer, and switch to it.

If there's a number in the buffer at point, it is the default for LINE.

This function is usually the wrong thing to use in a Lisp program.
What you probably want instead is something like:
  (goto-char (point-min)) (forward-line (1- N))
If at all possible, an even better solution is to use char counts
rather than line counts."
  (interactive
   (if (and current-prefix-arg (not (consp current-prefix-arg)))
       (list (prefix-numeric-value current-prefix-arg))
     ;; Look for a default, a number in the buffer at point.
     (let* ((default
	      (save-excursion
		(skip-chars-backward "0-9")
		(if (looking-at "[0-9]")
		    (buffer-substring-no-properties
		     (point)
		     (progn (skip-chars-forward "0-9")
			    (point))))))
	    ;; Decide if we're switching buffers.
	    (buffer
	     (if (consp current-prefix-arg)
		 (other-buffer (current-buffer) t)))
	    (buffer-prompt
	     (if buffer
		 (concat " in " (buffer-name buffer))
	       "")))
       ;; Read the argument, offering that number (if any) as default.
       (list (read-from-minibuffer (format (if default "Goto line%s (%s): "
					     "Goto line%s: ")
					   buffer-prompt
					   default)
				   nil nil t
				   'my-goto-line-history
				   default)
	     buffer))))
  ;; Switch to the desired buffer, one way or another.
  (if buffer
      (let ((window (get-buffer-window buffer)))
	(if window (select-window window)
	  (switch-to-buffer-other-window buffer))))
  ;; Leave mark at previous position
  (or (region-active-p) (push-mark))
  ;; Move to the specified line number in that buffer.
  (save-restriction
    (widen)
    (goto-char (point-min))
    (if (eq selective-display t)
	(re-search-forward "[\n\C-m]" nil 'end (1- line))
      (forward-line (1- line)))))

(bind-key "M-g g"   'my-goto-line)
(bind-key "M-g M-g" 'my-goto-line)
#+END_SRC
* Yank and Delete
** Delete word or yank
The following may be of interest to people who (a) are happy with
"C-w" and friends for killing and yanking, (b) use
"transient-mark-mode", (c) also like the traditional Unix tty
behaviour that "C-w" deletes a word backwards. It tweaks "C-w" so
that, if the mark is inactive, it deletes a word backwards instead of
killing the region. Without that tweak, the C-w would create an error
text without an active region.

http://www.emacswiki.org/emacs/DefaultKillingAndYanking#toc2

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before unix-werase activate compile)
  "When called interactively with no active region, delete a single word
    backwards instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (save-excursion (backward-word 1) (point)) (point)))))
#+END_SRC
** Selection deletion
Use delete-selection mode:

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Deletion in readonly buffer
Be silent when killing text from read only buffer:

#+BEGIN_SRC emacs-lisp
(setq kill-read-only-ok t)
#+END_SRC

** Join lines at killing
If at end of line, join with following; otherwise kill line.
Deletes whitespace at join.

#+BEGIN_SRC emacs-lisp
(defun kill-and-join-forward (&optional arg)
  "If at end of line, join with following; otherwise kill line.
Deletes whitespace at join."
  (interactive "P")
  (if (and (eolp) (not (bolp)))
      (delete-indentation t)
    (kill-line arg)))

(bind-key "C-k" 'kill-and-join-forward)
#+END_SRC

** DISABLED Yank

# BEGIN_SRC emacs-lisp
(defun my-yank (&optional arg)
  "Reinsert (\"paste\") the last stretch of killed text.
More precisely, reinsert the stretch of killed text most recently
killed OR yanked. Put mark at end, and set point at
beginning (the opposite of `yank'). With just
\\[universal-argument] as argument, same but put mark at
beginning (and point at end). With argument N, reinsert the Nth
most recently killed stretch of killed text.

When this command inserts killed text into the buffer, it honors
`yank-excluded-properties' and `yank-handler' as described in the
doc string for `insert-for-yank-1', which see.

See also the command `yank-pop' (\\[yank-pop])."
  (interactive "*P")
  (setq yank-window-start (window-start))
  ;; If we don't get all the way thru, make last-command indicate that
  ;; for the following command.
  (setq this-command t)
  (push-mark (point))
  (insert-for-yank (current-kill (cond
				  ((listp arg) 0)
				  ((eq arg '-) -2)
				  (t (1- arg)))))
  (unless (consp arg)
      ;; This is like exchange-point-and-mark, but doesn't activate the mark.
      ;; It is cleaner to avoid activation, even though the command
      ;; loop would deactivate the mark because we inserted text.
      (goto-char (prog1 (mark t)
		   (set-marker (mark-marker) (point) (current-buffer)))))
  ;; If we do get all the way thru, make this-command indicate that.
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)

(bind-key "C-y" 'my-yank)
# END_SRC

** Dynamic char deletion

The following is from Boojum's post in
[[http://www.reddit.com/r/emacs/comments/b1r8a/remacs_tell_us_about_the_obscure_but_useful/]].

I don't want to kill the comment, just the prefix to it. So that

// The quick brown fox[]
// jumps over the lazy dog.

becomes

// The quick brown fox[] jumps over the lazy dog.

#+BEGIN_SRC emacs-lisp
(defun delete-char-dynamic (&optional arg)
  "If at end of line, intelligently join to the following;
otherwise delete."
  (interactive "p")
  (if (or (not (eolp)) (bolp))
      (delete-char arg)
    (let ((start (point))
          (in-comment (eq (get-text-property (point) 'face)
                          'font-lock-comment-face)))
      (forward-char)
      (skip-chars-forward " \  ")
      (if (and in-comment (looking-at comment-start-skip))
          (goto-char (match-end 0)))
      (delete-region start (point))
      (when (and (not (eolp))
                 (/= (char-before) ? )
                 (/= (char-before) ?\  ))
        (insert-char ?  1)
        (backward-char)))))

;; Make delete-selection-mode work with it
(put 'delete-char-dynamic 'delete-selection 'supersede)

;; Rebind DELETE and friends to our version
(bind-key "<deletechar>" 'delete-char-dynamic)
(bind-key "<delete>" 'delete-char-dynamic)
(bind-key "C-d" 'delete-char-dynamic)
#+END_SRC
* Completion

#+BEGIN_SRC emacs-lisp
(setq ;; ignore case when reading a file name completion
      read-file-name-completion-ignore-case t
      ;; do not consider case significant in completion (GNU Emacs default)
      completion-ignore-case t
      ;; lets TAB do completion as well
      tab-always-indent 'complete
      completions-format 'vertical)
#+END_SRC
* Windows handling
** delete-window
If only one window in frame, `delete-frame'.

From http://www.emacswiki.org/emacs/frame-cmds.el

#+BEGIN_SRC emacs-lisp
(defadvice delete-window (around delete-window (&optional window) activate)
  (interactive)
  (save-current-buffer
    (setq window (or window (selected-window)))
    (select-window window)
    (if (one-window-p t)
	(delete-frame)
      ad-do-it (selected-window))))
#+END_SRC
** new kill-buffer-and-window
Replacement for interactive `kill-buffer'. We cannot redefine
`kill-buffer', because other elisp code relies on it's exact
behavior.

#+BEGIN_SRC emacs-lisp
(defun my--kill-buffer-and-window (&optional buffer)
  "Kill buffer BUFFER-OR-NAME.
The argument may be a buffer or the name of an existing buffer.
Argument nil or omitted means kill the current buffer. Return t
if the buffer is actually killed, nil otherwise.

Unlike `kill-buffer', this also will delete the current window if
there are several windows open."
  (interactive)
  (setq buffer (or buffer (current-buffer)))
  (unless (one-window-p)
    (delete-window))
  (kill-buffer buffer)
  ;; TODO: only delete the frame if it isn't the first one
  ;; (when (> (length (frame-list)) 1)
  ;;   (delete-frame))
  )

(bind-key "C-x k" 'my--kill-buffer-and-window)
#+END_SRC

** Window sizing
#+BEGIN_SRC emacs-lisp
(bind-key "<M-down>" 'enlarge-window)

(bind-key "<M-up>" 'shrink-window)

#+END_SRC

** Window zooming (F5)

If there is only one window displayed, act like C-x 2. If there are
two windows displayed, act like C-x 1

#+BEGIN_SRC emacs-lisp
(defun my-zoom-next-buffer2 ()
  (let ((curbuf (current-buffer))
	(firstbuf nil))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
	;(princ (format "name %s, fn %s\n" (buffer-name) buffer-file-name))
	(unless (or
		 ;; Don't mention internal buffers.
		 (string= (substring (buffer-name) 0 1) " ")
		 ;; No buffers without files.
		 (not buffer-file-name)
		 ;; Skip the current buffer
		 (eq buffer curbuf)
		 )
	  ;(princ (format " nme %s, fn %s\n" (buffer-name) buffer-file-name))
	  (unless firstbuf
	    (setq firstbuf buffer))
	    ;;(print buffer)
	  )))
    (when firstbuf
      ;(princ (format "new buffer: %s.\n" firstbuf))
      (bury-buffer)
      (switch-to-buffer firstbuf)
      )
  )
)

(defun my-explode-window ()
  "If there is only one window displayed, act like C-x2. If there
are two windows displayed, act like C-x1:"
  (interactive)
  (if (one-window-p t)
      (progn
	(split-window-vertically)
	(other-window 1)
	(my-zoom-next-buffer2)
	(other-window -1))
    (delete-other-windows)
  ))

(bind-key "<f5>" 'my-explode-window)
#+END_SRC
* Buffers
** Insert buffer

|-------+---------------|
| C-x i | insert file   |
|-------+---------------|
| C-x I | insert buffer |
|-------+---------------|

#+BEGIN_SRC emacs-lisp
;; Insert buffer at current position
(bind-key "C-x I" 'insert-buffer)
#+END_SRC
** Bubble buffers
(Almost) verbatim copy of  http://www.xsteve.at/prg/emacs/bubble-buffer.el

#+BEGIN_SRC emacs-lisp
(defvar bubble-buffer-max-display-length (- (frame-width) 5)
  "Maximum number of characters to display in the minibuffer when bubbling.")

(defvar bubble-buffer-omit-regexp "\\(^ .+$\\|\\*Messages\\*\\)"
  "Regexp for buffer-names that should be skipped when bubbling buffers with
bubble-buffer-next and bubble-buffer-previous.
For example you could use \"\\\\*.+\\\\*\" to exclude all buffers that contain two *'s.")
;"\\*.+\\*"

(defun bubble-buffer-omit-buffer (buffer)
  "return nil if the buffer should be omitted, otherwise the buffer name"
  (let ((buf-name (buffer-name buffer)))
    (unless (and bubble-buffer-omit-regexp (string-match bubble-buffer-omit-regexp buf-name))
      buf-name)))


(defun bubble-buffer-next()
  "Bubble down one entry in the buffer list.
   Switch to the next buffer on the list"
  (interactive)
  (if (not (eq last-command 'bubble-buffer-next))
      (progn (setq bubble-buffer-list (copy-alist (buffer-list)))
             (delq (get-buffer " *Minibuf-0*") bubble-buffer-list)
             (delq (get-buffer " *Minibuf-1*") bubble-buffer-list)
             (setq bubble-buffer-buried-list nil)))
  (let* ((cur-buf (current-buffer))
         (b-list (delq nil (mapcar 'bubble-buffer-omit-buffer (cdr bubble-buffer-list))))
         (doit b-list)
         (rest nil)
         (s))
    (while doit
      (add-to-list 'bubble-buffer-buried-list (car bubble-buffer-list))
      (bury-buffer (car bubble-buffer-list))
      (setq bubble-buffer-list (cdr bubble-buffer-list))
      (switch-to-buffer (car bubble-buffer-list))
      (setq rest (cdr (copy-alist bubble-buffer-list)))
      (while rest
        (bury-buffer (car rest))
        (setq rest (cdr rest)))
      (setq doit (not (bubble-buffer-omit-buffer (current-buffer)))))
    ;;(message "%S" bubble-buffer-list)
    (if b-list
        (progn
          (setq b-list (cdr b-list))
          (setq s (concat
                   "Next: "
                   (if b-list (format "%S" b-list "") "")
                   "[end-of-bubble-list]"))
          (message "%s" (concat
			 (substring s 0 (min bubble-buffer-max-display-length (length s)))
			 " ...")))
      (message "Already at the end of the buffer-list"))))

(defun bubble-buffer-previous()
  "Undo one bubbling step from bubble-buffer-next.
   Switch to the buffer before the bubbled up buffer in the buffer list"
  (interactive)
  (unless (eq last-command 'bubble-buffer-next)
    (setq bubble-buffer-buried-list nil))
  (setq this-command 'bubble-buffer-next)
  (if bubble-buffer-buried-list
      (progn
        (let ((doit t)
              (s)
              (b-list))
          (while doit
            (add-to-list 'bubble-buffer-list (car bubble-buffer-buried-list))
            (switch-to-buffer (car bubble-buffer-buried-list))
            (setq bubble-buffer-buried-list (cdr bubble-buffer-buried-list))
            (setq doit (not (bubble-buffer-omit-buffer (current-buffer))))))
        (setq b-list (delq nil (mapcar 'bubble-buffer-omit-buffer bubble-buffer-buried-list)))
        (setq s (concat
                 "Prev: "
                 (if b-list (format "%S" b-list "") "")
                 "[beginning-of-bubble-list]"))
        (message "%s" (concat
		       (substring s 0 (min bubble-buffer-max-display-length (length s))) " ...")))
    (message "Already at the start of the bubble-buffer-list")))
#+END_SRC

And here my glue-code:

#+BEGIN_SRC emacs-lisp
(bind-key "<f6>"   'bubble-buffer-next)
(bind-key "S-<f6>" 'bubble-buffer-previous)
#+END_SRC
** Protect buffers

https://raw.githubusercontent.com/lewang/le_emacs_libs/master/keep-buffers.el

By default, "*scratch*" is protected and erased when killed, "*Messages*"
is never killed or erased.  You can customize easily using elisp:

;; protect all buffers starting with "*scratch"
(push '("\\`*scratch" . erase) keep-buffers-protected-list)

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'cl))

(define-minor-mode keep-buffers-mode
  "when active, killing protected buffers results in burying them instead.
Some may also be erased, which is undo-able."
  :init-value nil
  :global t
  :group 'keep-buffers
  :lighter ""
  :version "1.4"
  (if keep-buffers-mode
      ;; Setup the hook
      (add-hook 'kill-buffer-query-functions 'keep-buffers-query)
    (remove-hook 'kill-buffer-query-functions 'keep-buffers-query)))

(defcustom keep-buffers-protected-alist
  '(("\\`\\*scratch\\*\\'" . erase)
    ("\\`\\*Messages\\*\\'" . nil))
  "an alist '((\"regex1\" . 'erase) (\"regex2\" . nil))

CAR of each cons cell is the buffer matching regexp.  If CDR is
not nil then the matching buffer is erased then buried.

If the CDR is nil, then the buffer is only buried."
  :type '(alist)
  :group 'keep-buffers
  )

(defun keep-buffers-query ()
  "The query function that disable deletion of buffers we protect."
  (let ((crit (dolist (crit keep-buffers-protected-alist)
                (when (string-match (car crit) (buffer-name))
                  (return crit)))))
    (if crit
        (progn
          (when (cdr crit)
            (erase-buffer))
          (bury-buffer)
          nil)
      t)))

(keep-buffers-mode 1)
#+END_SRC
** Easier kill buffers with processes
Don't asks you if you want to kill a buffer with a live process
attached to it:

http://www.masteringemacs.org/articles/2010/11/14/disabling-prompts-emacs/

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
	     kill-buffer-query-functions))
#+END_SRC
* File opening/saving
** Basic settings
#+BEGIN_SRC emacs-lisp
(setq ;; Never show GTK file open dialog
      use-file-dialog nil
      ;; don't add newlines to end of buffer when scrolling, but show them
      next-line-add-newlines nil
      ;; Preserve hard links to the file you´re editing (this is
      ;; especially important if you edit system files)
      backup-by-copying-when-linked t
      ;; Just never create backup files at all
      ;;make-backup-files nil
      backup-directory-alist (list (cons "." (concat dotfiles-dir "tmp/bak/")))
      ;; Make sure your text files end in a newline
      require-final-newline t
      ;; Disable auto-save (#init.el# file-names)
      auto-save-default nil)

(setq auto-save-list-file-prefix (concat dotfiles-dir "tmp/auto-save-list/saves-"))
#+END_SRC
** Find file at point
#+BEGIN_SRC emacs-lisp
(use-package ffap
  :defer t
  :commands
  find-file-at-point
  :bind ("C-x C-p" . find-file-at-point)
  )
#+END_SRC
** Decompress compressed files
Auto decompress compressed files.

#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC
** Quickly save (F2)
#+BEGIN_SRC emacs-lisp
(bind-key "<f2>" 'save-buffer)
#+END_SRC
* Display
** Automatically load .Xresources after changes

Sample ~/.Xresources:

#+BEGIN_EXAMPLE
Emacs.geometry: 120x55
Emacs.Font:	terminus 11
Emacs.verticalScrollBars: right
Emacs.toolBar: off
Emacs*Background: #000000
Emacs*Foreground: #7f7f7f
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun merge-x-resources ()
  (let ((file (file-name-nondirectory (buffer-file-name))))
    (when (or (string= file ".Xdefaults")
	      (string= file ".Xresources"))
      (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
      (message (format "Merged %s into X resource database" file)))))
(add-hook 'after-save-hook 'merge-x-resources)
#+END_SRC
** Fixed frame display
#+BEGIN_SRC emacs-lisp
(if (equal window-system 'w32)
    ;; Windows settings
    (setq initial-frame-alist
	  '(
	    ;;(background-color . "black")
	    ;;(foreground-color . "LightGray")
	    (horizontal-scroll-bars . nil)
	    (vertical-scroll-bars . right)
	    (tool-bar-lines . 0)
	    (left-fringe . 1)
	    (right-fringe . 0)))
  ;; Linux settings
  (setq initial-frame-alist
	`(;;(background-color . "black")
	  ;;(foreground-color . "LightGray")
	  (horizontal-scroll-bars . nil)
	  (vertical-scroll-bars . right)
	  (tool-bar-lines . 0)
	  (left-fringe . 1)
	  (right-fringe . 0)
	  ;;(height . ,(if (or (not my-win32)
	  ;;		   have-win32-sixbyten-font)
	  ;;	       (my-frame-percent-to-char-height 97)
	  ;;	     70))
	  (width . 120)
	  (height . 55)
	  )))
#+END_SRC
** Set default frame attributes
default-frame-alist is defined in terms of initial-frame-alist.  Don't
use copy-sequence here -- it doesn't copy the list elements, just the
list's cons cells.  Use copy-alist instead.
#+BEGIN_SRC emacs-lisp
(setq default-frame-alist (copy-alist initial-frame-alist))
#+END_SRC
** Font-Lock some keywords
#+BEGIN_SRC emacs-lisp
(defface my--todo-face
  '((t :foreground "red"
       :weight bold))
  "Font for showing TODO words."
  :group 'basic-faces)

;; Highlight each of TODO TODO: FIXME FIXME: XXX XXX: \todo
(defun my--hint-facify ()
   (unless (or (eq 'diff-mode major-mode) (eq 'script-mode major-mode))
     (font-lock-add-keywords nil '(
	 ("\\(\\<\\(\\(FIXME\\|TODO\\|XXX\\):?\\>\\)\\|\\\\todo\\)" 1 'my--todo-face t)
	 ))))

(add-hook 'font-lock-mode-hook 'my--hint-facify)
#+END_SRC

** Line truncation
#+BEGIN_SRC emacs-lisp
(setq ;; don't display continuation lines
      truncate-lines t
      ;; respect truncate-lines:
      truncate-partial-width-windows nil)
#+END_SRC
** Show trailing whitespace
This makes typing errors more obvious.

#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook
	  '(lambda ()
	     ;; This hack allows the diff-mode hook to set the
	     ;; variable to -1. The find-file-hook fires after the
	     ;; diff-mode hook, so we get the -1 and are able to turn
	     ;; off the display of trailing whitespaces.
	     (if (eq show-trailing-whitespace -1)
		 (setq show-trailing-whitespace nil)
	       (setq show-trailing-whitespace t))))
#+END_SRC
** Don't wait for window manager when font changes
Avoid Emacs hanging for a while changing default font

#+BEGIN_SRC emacs-lisp
(modify-frame-parameters nil '((wait-for-wm . nil)))
#+END_SRC

** Handle some buffers specials (no toolbar, extra frame)
Display various non-editing buffers in their own frames and show those
special buffer frames without a tool bar

#+BEGIN_SRC emacs-lisp
(add-to-list 'special-display-buffer-names "*Backtrace*")
(add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))
#+END_SRC
** Misc settings for text vs. windowing systems
#+BEGIN_SRC emacs-lisp
(if window-system
    ;; X11, Windows, etc
    (progn
      ;; Windowing systems are fast enought
      (column-number-mode t)
      ;; Turn off blinking
      (blink-cursor-mode -1)
      )
  ;; Text mode
  (progn
    ;; No "very" visible cursor
    (setq visible-cursor nil)
    ))
#+END_SRC
** No audible bell
No audible bell, beeps are annoying
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

** Let emacs react faster to keystrokes
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1
      idle-update-delay 0.35)
#+END_SRC
** Menu

Get rid of the Games in the Tools menu.

# BEGIN_SRC emacs-lisp
(define-key menu-bar-tools-menu [games] nil)
# END_SRC
* Minibuffer
#+BEGIN_SRC emacs-lisp
(setq ;; Don't insert current directory into minubuffer
      insert-default-directory nil

      ;; enable recursive minibuffer, they're a nuisance
      enable-recursive-minibuffers nil

      ;; minibuffer window expands vertically as necessary to hold the text that
      ;; you put in the minibuffer
      resize-mini-windows t
      )
#+END_SRC

Allow to type space chars in minibuffer input (for `timeclock-in', for
example).

#+BEGIN_SRC emacs-lisp
(define-key minibuffer-local-completion-map " " nil)
(define-key minibuffer-local-must-match-map " " nil)
#+END_SRC
* Searching
** Package: isearch
#+BEGIN_SRC emacs-lisp
(setq ;; Scrolling while searching
      isearch-allow-scroll t

      ;; Save Isearch stuff
      isearch-resume-in-command-history t)

(bind-key "C-y" 'isearch-yank-kill isearch-mode-map)
#+END_SRC

** grep
Prompts you for an expression, defaulting to the symbol that your
cursor is on, and greps for that in the current directory and all
subdirectories:

#+BEGIN_SRC emacs-lisp
(defun my-grep ()
  "grep the whole directory for something defaults to term at cursor position"
  (interactive)
  (let ((default (thing-at-point 'symbol)))
    (let ((needle (or (read-string (concat "grep for '" default "': ")) default)))
      (setq needle (if (equal needle "") default needle))
      (grep (concat "egrep -s -i -n -r " needle " *")))))

(bind-key "C-x g" 'my-grep)

#+END_SRC

** Invoke isearch from occur
#+BEGIN_SRC emacs-lisp
(defun isearch-occur ()
  "Invoke `occur' from within isearch."
  (interactive)
  (let ((case-fold-search isearch-case-fold-search))
    (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))
  (pop-to-buffer "*Occur*"))

(bind-key "C-o" 'isearch-occur isearch-mode-map)
#+END_SRC
* Help
** Go to back to previous help buffer
Make 'b' (back) go to the previous position in emacs help.

[[http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks]]

#+BEGIN_SRC emacs-lisp
(add-hook 'help-mode-hook
	  '(lambda ()
	     (bind-key "b" 'help-go-back help-mode-map)))
#+END_SRC
** F1 key searches in help or opens man page
#+BEGIN_SRC emacs-lisp
(defun my-help ()
  "If function given tries to `describe-function' otherwise uses
`manual-entry' to display manpage of a `current-word'."
  (interactive)
  (let ((var (variable-at-point)))
    (if (symbolp var)
	(describe-variable var)
      (let ((fn (function-called-at-point)))
	(if fn
	    (describe-function fn)
	  (man (current-word)))))))

(bind-key "<f1>" 'my-help)
#+END_SRC

** Apropos
Check all variables and non-interactive functions as well
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)

;; Help should search more than just commands
(bind-key "C-h a" 'apropos)
#+END_SRC
* Miscelleanous
** Mouse
Paste at text-cursor, not at mouse-cursor:

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
** Localisation
A sentence doesn't end with two spaces:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
** Decimal entry of quoted characters
Use decimal for `C-q', not octal. Hey, who's using octal nowaydays?

#+BEGIN_SRC emacs-lisp
(setq read-quoted-char-radix 10)
#+END_SRC
** Swap RET and C-j
#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)

(bind-key "C-j" 'newline)
#+END_SRC
** dos2unix
#+BEGIN_SRC emacs-lisp
(defun dos2unix()
  "convert dos (^M) end of line to unix end of line"
  (interactive)
  (goto-char(point-min))
  (while (search-forward "\r" nil t) (replace-match "")))
#+END_SRC
** 822date
Inserts something like "Fri,  1 Dec 2006 15:41:36 +0100"

#+BEGIN_SRC emacs-lisp
(defun 822date ()
  "Insert date at point format the RFC822 way."
  (interactive)
  (insert (format-time-string "%a, %e %b %Y %H:%M:%S %z")))
#+END_SRC

** DISABLED Indent yanked text
Let yanked text immediately be indented, based on an old version of
[[http://www.emacswiki.org/emacs/AutoIndentation]]:

# TODO: update with a newer version

# BEGIN_SRC emacs-lisp
(defadvice yank (after indent-region activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode org-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (let ((mark-even-if-inactive t))
        (indent-region (region-beginning) (region-end) nil))))

(defadvice yank-pop (after indent-region activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode org-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (let ((mark-even-if-inactive t))
	(indent-region (region-beginning) (region-end) nil))))
# END_SRC



* Programming
** Tab handling
Tabify only initial whitespace

#+BEGIN_SRC emacs-lisp
(setq tabify-regexp "^\t* [ \t]+")
#+END_SRC

Deleting past a tab normally changes tab into spaces. Don't do that,
kill the tab instead.

#+BEGIN_SRC emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+END_SRC
** Disable vc backends
We only use git, not other version controls:

#+BEGIN_SRC emacs-lisp
(setq vc-handled-backends nil)
#+END_SRC

** Let parenthesis behave
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0
      blink-matching-parent nil)
(set-face-background 'show-paren-match-face "#d0d0d0")
#+END_SRC

** qmake project files
Don't open Qt's *.pro files as IDLWAVE files.

TODO: look for a real qmake-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.pro$" . fundamental-mode))
#+END_SRC
** C++ mode for .h and .inl
;; Open *.h files normally in c++ mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.h$" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-mode))
#+END_SRC
** Commenting
#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" 'comment-dwim)
#+END_SRC
** Compilation
#+BEGIN_SRC emacs-lisp
(defun my-compile ()
  (interactive)
  (delete-other-windows)
  (save-buffer)
  (if (fboundp 'eproject-root)
      (let ((default-directory (eproject-root)))
	(compile compile-command))
    (compile compile-command)))

(bind-key "<f7>" 'my-compile)


(defun set-compile-command (&optional cmd)
  "Helper for to set compile-command"
  (interactive "scmd: ")
  (setq compile-command cmd))
#+END_SRC

*** Auto close compile log if there are no errors

[[http://www.emacswiki.org/emacs/ModeCompile]]

#+BEGIN_SRC emacs-lisp
(defun compile-autoclose (buffer string)
  (cond ((string-match "finished" string)
	 ;; (message "Build maybe successful: closing window.")
	 (run-with-timer 1 nil
			 'delete-window
			 (get-buffer-window buffer t)))
	(t
	 (message "Compilation exited abnormally: %s" string))))
(setq compilation-finish-functions 'compile-autoclose
      compilation-ask-about-save nil
      compilation-scroll-output t)
#+END_SRC

*** Error navigation

#+BEGIN_SRC emacs-lisp

(bind-key "<f8>" 'next-error)

(bind-key "S-<f8>" 'previous-error)
#+END_SRC
** Package: column-marker

#+BEGIN_SRC emacs-lisp
(defun my-column-marker-at-80 ()
  (interactive)
  (column-marker-1 80)
)

(use-package column-marker
  :ensure t
  :init
  (add-hook 'c-mode-hook 'my-column-marker-at-80)
  )
#+END_SRC
** Package: ffap (find-file-at-point)

#+BEGIN_SRC emacs-lisp
(use-package ffap
  :commands
  find-file-at-point
  :bind (("C-x C-p" . find-file-at-point))
  )

;; rebind C-x C-f and others to the ffap bindings (see variable ffap-bindings)
;; (ffap-bindings)
;; C-u C-x C-f finds the file at point
;; (setq ffap-require-prefix t)
#+END_SRC

** Package: magit

=magit-rigid-key-bindings= must be set before magit is loaded. It will
remove the new key bindings that use pop-up buffers.

#+BEGIN_SRC emacs-lisp
(setq magit-rigid-key-bindings t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :config
  (progn
     (setq magit-save-some-buffers 'dontask
	   magit-commit-all-when-nothing-staged nil
	   magit-stage-all-confirm nil
	   magit-unstage-all-confirm nil
	   magit-status-buffer-switch-function 'switch-to-buffer
	   magit-refresh-file-buffer-hook '(revert-buffer)
	   magit-diff-use-overlays t
	   )
     ;(set-face-foreground 'magit-diff-add "green4")
     ;(set-face-foreground 'magit-diff-del "red3")
     )
  :bind ("C-c m" . magit-status)
  :commands (magit-get-top-dir)
)

;;(autoload 'magit-get-top-dir "magit" nil t)

(defun magit-refresh-status ()
  (magit-git-exit-code "update-index" "--refresh")
  (magit-create-buffer-sections
    (magit-with-section 'status nil
      (run-hooks 'magit-status-insert-sections-hook)))
  (run-hooks 'magit-refresh-status-hook))
#+END_SRC
** Package: org-babel

#+BEGIN_SRC emacs-lisp
(use-package org
  :diminish org-mode
  :init
  (progn
    (setq org-src-fontify-natively t  ; inside src block use the colors like the major mode of the src type
          org-src-tab-acts-natively t ; inside a src block let tab act like it was in major mode of the src type
	  org-src-preserve-indentation t ; don't add two indentation spaces into src blocks
          )
    )
  )
#+END_SRC



* Package: ace-jump-buffer
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-buffer
  :ensure t
  :defer t
  :bind ("C-c j" . ace-jump-buffer)
  )
#+END_SRC
* Package: ace-jump-mode
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :defer t
  :bind ("C-." . ace-jump-mode)
)
#+END_SRC
* Package: ibuffer
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :defer t
  :bind (("C-x C-b" . ibuffer))
  :config
  (setq ;; don't display size of files
        ibuffer-display-summary nil

	;; don't sort by recent files
	;;ibuffer-default-sorting-mode 'major-mode

	;; Don't ask for "dangerous" operations, e.g. killing a buffer
	ibuffer-expert t

	;; number of hours before a buffer is considered "old"
	ibuffer-old-time 4
  )
)
#+END_SRC
* Package: ido
#+BEGIN_SRC emacs-lisp
(use-package ido
  :defer nul
  :init (ido-mode 'both)
  :config
  (progn
    (setq ido-save-directory-list-file (concat dotfiles-dir "tmp/ido.last")
          ;:ido-everywhere t                       ; use for many file dialogs
          ido-max-work-file-list      50         ; remember many
          ;:ido-enable-flex-matching t             ; be flexible
          ;;ido-max-prospects 4                    ; don't spam my minibuffer
          ido-confirm-unique-completion t        ; wait for RET, even with unique completio
          ;;ido-enable-dot-prefix t              ; need "." to select hidden files
          ido-enable-tramp-completion nil
          ido-ignore-buffers '("\\`"
                               "^\*Mess"
                               "^\*Help*"
                               "^\*Back"
                               ".*Completion"
                               "^\*Ido")
          ido-ignore-directories '("\\`CVS/"
                                   "\\.svn/"
                                   "\\.git/"
                                   "\\`\\.\\./"
                                   "\\`\\./")

          ido-default-buffer-method 'selected-window
          ido-default-file-method 'selected-window
          ido-enable-flex-matching t
          ido-max-directory-size 100000)
    ;; Ignore some files from latex / latexmk
    (add-to-list 'completion-ignored-extensions ".aux")
    (add-to-list 'completion-ignored-extensions ".dvi")
    (add-to-list 'completion-ignored-extensions ".fdb_latexmk")
    (add-to-list 'completion-ignored-extensions ".idx")
    (add-to-list 'completion-ignored-extensions ".ilg")
    (add-to-list 'completion-ignored-extensions ".ind")
    (add-to-list 'completion-ignored-extensions ".pdf")
    (add-to-list 'completion-ignored-extensions ".toc")

    (use-package ido-vertical-mode
      :init (ido-vertical-mode 1))

    (use-package idomenu
      :bind ("C-x C-i" . idomenu))
    )
  )

(use-package ido-ubiquitous
  :init
  (ido-ubiquitous-mode 1)
  )
#+END_SRC
* Package: savehist (save mini-buffer history)
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :init
   (setq savehist-file (concat dotfiles-dir "tmp/history.el")
      history-length 1000)
  :config
  (savehist-mode 1)
)
#+END_SRC
