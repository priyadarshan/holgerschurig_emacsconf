#+TITLE: Holger Schurig's Emacs configuration
#+OPTIONS: toc:4 h:4

* About this file
  :PROPERTIES:
  :CUSTOM_ID: babel-init
  :END:
<<babel-init>>

Inspired by the [[http://eschulte.me/emacs24-starter-kit/#installation][Emacs Starter Kit]], I set up my configuration file
using Org-babel. You could load it with =(org-babel-load-file
"/path/to/file")=, changing the path appropriately, but you'll
probably want to tweak it extensively first.

This page: [[http://sachac.github.io/.emacs.d/Sacha.html][HTML]] - [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][Org]] - [[https://dl.dropbox.com/u/3968124/sacha-emacs.el][.el]] - [[http://github.com/sachac/.emacs.d/][Github]] - also, http://sach.ac/dotemacs

To be precise, this is what's in the first part of my =~/.emacs.d/init.el= (what used to be the =~/.emacs= file):

#+BEGIN_SRC emacs-lisp  :tangle no
;; Don't load old .elc files when the .el file is newer
(setq load-prefer-newer t)
;; This sets up the load path so that we can override it
(package-initialize nil)
;; Local packages:
(add-to-list 'load-path (concat user-emacs-directory "elisp"))
(add-to-list 'load-path (concat user-emacs-directory "elisp/org-mode/lisp"))
(add-to-list 'load-path (concat user-emacs-directory "org-mode/contrib/lisp"))
;;(add-to-list 'load-path "/usr/local/share/emacs/site-lisp")
;; Load the rest of the packages
(package-initialize nil)
(setq package-enable-at-startup nil)

(setq inhibit-startup-screen t)

(let ((el-file (concat user-emacs-directory "config.el")))
  (if (file-exists-p el-file)
      (load-file (concat user-emacs-directory "config.el"))
    (progn
      (require 'cl)
      (org-babel-load-file (concat user-emacs-directory "config.org"))
      )))

#+END_SRC

If you're new to Emacs Lisp, you probably don't want to copy and paste
large chunks of this code. Instead, copy small parts of it (always
making sure to copy a complete set of parentheses) into your
=*scratch*= buffer or some other buffer in =emacs-lisp-mode=. Use =M-x
eval-buffer= to evaluate the code and see if you like the way that
Emacs behaves. See [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in Emacs Lisp]] for more details on Emacs Lisp. You can also find the manual by using =C-h i= (=info=) and choosing "Emacs Lisp Intro".

I've installed a lot of packages. When you see =use-package= and a
package name you might like, you can use =M-x package-install= to
install the package of that name. Note that use-package is itself
provided by a package, so you'll probably want to install that and
=bind-key=.

If you're viewing the Org file, you can open source code blocks (those are the ones in begin_src) in a separate buffer by moving your point inside them and typing C-c ' (=org-edit-special=). This opens another buffer in =emacs-lisp-mode=, so you can use =M-x eval-buffer= to load the changes. If you want to explore how functions work, use =M-x edebug-defun= to set up debugging for that function, and then call it. You can learn more about edebug in the [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][Emacs Lisp]] manual.

I like using =(setq ...)= more than Customize because I can neatly organize my configuration that way.

* Optional debug
Use the following if there is some nasty bug that you cannot find with
=emacs --debug-init=:

#+BEGIN_SRC emacs-lisp :tangle no
(toggle-debug-on-error)
#+END_SRC
* Package infrastructure
** add =git/*= to =load-path=
#+BEGIN_SRC emacs-lisp
(let ((emacs-git (expand-file-name "git/" user-emacs-directory)))
  (mapc (lambda (x)
          (add-to-list 'load-path (expand-file-name x emacs-git)))
        (delete ".." (directory-files emacs-git))))
#+END_SRC
** package
Enable =packages.el= with MELPA:

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-enable-at-startup nil
      package-archives
      '(("gnu"             . "https://elpa.gnu.org/packages/")
	("melpa"           . "https://melpa.org/packages/")
        ;; ("melpa-stable" . "http://stable.melpa.org/packages/")
	;; ("elpy"         . "http://jorgenschaefer.github.io/packages/")
	;; ("org"          . "http://orgmode.org/elpa/") ;; for org-plus-contrib
	))
#+END_SRC

** use-package
See http://github.com/jwiegley/use-package/
or http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html

Basic syntax:

(use-package package-name
     [:keyword [option]]...)

:init          Code to run before PACKAGE-NAME has been loaded.
:config        Code to run after PACKAGE-NAME has been loaded.  Note that if
               loading is deferred for any reason, this code does not execute
               until the lazy load has occurred.
:preface       Code to be run before everything except `:disabled'; this can
               be used to define functions for use in `:if', or that should be
               seen by the byte-compiler.
:mode          Form to be added to `auto-mode-alist'.
:interpreter   Form to be added to `interpreter-mode-alist'.
:commands      Define autoloads for commands that will be defined by the
               package.  This is useful if the package is being lazily loaded,
               and you wish to conditionally call functions in your `:init'
               block that are defined in the package.
:bind          Bind keys, and define autoloads for the bound commands.
:bind*         Bind keys, and define autoloads for the bound commands,
               *overriding all minor mode bindings*.
:bind-keymap   Bind a key prefix to an auto-loaded keymap defined in the
               package.  This is like `:bind', but for keymaps.
:bind-keymap*  Like `:bind-keymap', but overrides all minor mode bindings
:defer         Defer loading of a package -- this is implied when using
               `:commands', `:bind', `:bind*', `:mode' or `:interpreter'.
               This can be an integer, to force loading after N seconds of
               idle time, if the package has not already been loaded.
:after         Defer loading of a package until after any of the named
               features are loaded.
:demand        Prevent deferred loading in all cases.
:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.
:disabled      The package is ignored completely if this keyword is present.
:defines       Declare certain variables to silence the byte-compiler.
:functions     Declare certain functions to silence the byte-compiler.
:load-path     Add to the `load-path' before attempting to load the package.
:diminish      Support for diminish.el (if installed).
:ensure        Loads the package using package.el if necessary.
:pin           Pin the package to an archive.


#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-verbose t)
#+END_SRC

** CANCELED Packages and url.el and cookies
ELPA might use Emacs-W3 to get files, and this in turn sets cookies.
Move the cookie file out into the =tmp/= directory. And create this
directory, if it doesn't yet exist.

#+BEGIN_SRC emacs-lisp
(use-package url
  :defer t
  :config
  (let ((dir (concat user-emacs-directory "tmp/")))
    (ignore-errors (make-directory dir))
    (setq url-configuration-directory dir))
)
#+END_SRC

** tangle on save
#+BEGIN_SRC emacs-lisp
(defun my--collect-elisp-source-bodies ()
  (when (string= "config.org" (buffer-name))
    (my-tangle-config-org)))
(add-hook 'after-save-hook #'my--collect-elisp-source-bodies)
#+END_SRC

* Personal information
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Holger Schurig")
(setq user-mail-address "holgerschurig@gmail.com")
#+END_SRC

Passwords that shouldn't end up in my public git tree. Also not that I
make =freenode-password= known via =:defines=, so that the
byte-compiler won't bark at me.

#+BEGIN_SRC emacs-lisp
(require 'private nil 'noerror)
#+END_SRC
* The views
** GUI elements

Disable toolbars and the scroll-bar

#+BEGIN_SRC emacs-lisp
(setq tool-bar-mode nil)
(setq scroll-bar-mode nil)
#+END_SRC

You may also put something like this into =~/.Xresources= to enable/disable
certain things as soon as Emacs starts, e.g. before this script executes:

#+BEGIN_EXAMPLE
Emacs.verticalScrollBars: off
Emacs.toolBar: off
#+END_EXAMPLE

Disabling greeting in the echo area is rather nasty, because a simple
setting of this variable by setq is deliberately ignored. Sigh.

#+BEGIN_SRC emacs-lisp
(eval-after-load "startup" '(fset 'display-startup-echo-area-message 'ignore))
; Empty scratch message
(setq initial-scratch-message nil)
; Include current buffer name in the title bar
(setq frame-title-format '(buffer-file-name "%f" ("%b")))
#+END_SRC

** Window manager interaction
Avoid Emacs hanging for a while after changing default font:

#+BEGIN_SRC emacs-lisp
(modify-frame-parameters nil '((wait-for-wm . nil)))
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp
(use-package kooten-theme
  :ensure t
)
#+END_SRC

You may also put something like this into =~/.Xresources= to define
the font:

#+BEGIN_EXAMPLE
Emacs.geometry: 120x55
Emacs.Font:     Terminus 11
#+END_EXAMPLE

** Blend fringe
http://emacs.stackexchange.com/a/5343/115

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'fringe nil
                      :foreground (face-foreground 'default)
                      :background (face-background 'default))
#+END_SRC

** Let parenthesis behave

#+BEGIN_SRC emacs-lisp
(use-package paren
  :config
  (show-paren-mode 1)
  (setq show-paren-delay 0)
)
#+END_SRC
** TODO Font locking
Highlight each of TODO FIXME XXX DISABLED \todo :disabled
FIXME
FIXME: 

See http://emacsredux.com/blog/2013/07/24/highlight-comment-annotations/

#+BEGIN_SRC emacs-lisp
(defface my--todo-face
  '((t :foreground "red"
       :weight bold))   
  "Font for showing TODO words."
  :group 'basic-faces)

(defun my--hint-facify ()
  (unless (or (eq 'diff-mode major-mode)
	      (eq 'org-mode major-mode))
    (font-lock-add-keywords nil 
	'(
	  ("\\<\\(FIXME:?\\)" 1 'my--todo-face)
	  ("\\<\\(XXX:?\\)" 1 'my--todo-face)
	  ("\\<\\(DISABLED:?\\)" 1 'my--todo-face)
	  ("\\<\\(TODO:?\\)" 1 'my--todo-face)
	  ;; ("\\<\\(\\\\todo\\)" 1 'my--todo-face)
	  ("\\<\\(:disabled)" 1 'my--todo-face)
	  )))
   ;; (unless (or (eq 'diff-mode major-mode))
   ;;   (font-lock-add-keywords nil '(
   ;;       ("\\(\\<\\(\\(FIXME\\|TODO\\|XXX\\|DISABLED\\):?\\>\\)\\|\\\\todo\\|:disabled:?\\)" 1 'my--todo-face t)
   ;;       )))
)
(add-hook 'find-file-hook 'my--hint-facify)
#+END_SRC

** CANCELED Highlight special comment lines
#+BEGIN_SRC emacs-lisp
(defface my--elisp-section-face
  '((t :foreground "dark blue"
       :background "dark blue"))
  "Font for showing elisp sections."
  :group 'basic-faces)

(font-lock-add-keywords 'emacs-lisp-mode '(
	 ("^\\(;;;?_\\) " 1 'my--elisp-section-face t)
	 ("^\\(;;;;;;;;+\\)" 1 'my--elisp-section-face t)
	 ))
#+END_SRC

** Line truncation
don't display continuation lines

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

Do `M-x toggle-truncate-lines` to toggle truncation mode.
`truncate-partial-width-windows' has to be nil for `toggle-truncate-lines'
to work even in split windows

#+BEGIN_SRC emacs-lisp
(setq truncate-partial-width-windows nil)
#+END_SRC

** Show trailing whitespace

#+BEGIN_SRC emacs-lisp
(defun my--show-trailing-whitespace ()
  (interactive)
  (setq show-trailing-whitespace t))
(defun my--hide-trailing-whitespace ()
  (interactive)
  (message "hide trailing whitespace")
  (setq show-trailing-whitespace nil))
(add-hook 'prog-mode-hook 'my--show-trailing-whitespace)
#+END_SRC

** Buffers without toolbar, extra frame etc

#+BEGIN_SRC emacs-lisp
(add-to-list 'special-display-buffer-names "*Backtrace*")
(add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))
#+END_SRC

** Misc settings for text vs. windowing systems

#+BEGIN_SRC emacs-lisp
(if window-system
    ;; X11, Windows, etc
    (progn
      ;; Windowing systems are fast enought
      (column-number-mode t)
      ;; Turn off blinking
      (blink-cursor-mode -1)
      )
  ;; Text mode
  (progn
    ;; No "very" visible cursor
    (setq visible-cursor nil)))
#+END_SRC

** No audible bell

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

** Let emacs react faster to keystrokes

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
(setq idle-update-delay 0.35)
#+END_SRC

** Mode line setup
Show line and column numbers in the mode-line

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

** Power mode line

This was taken (mostly) from https://ogbe.net/emacsconfig.html.

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (use-package powerline
    :ensure t
    :config
    (setq powerline-default-separator 'contour)
    (setq powerline-height 20)

    ;; first reset the faces that already exist
    (set-face-attribute 'mode-line nil
			:foreground (face-attribute 'default :foreground)
			:family "Fira Sans"
			:weight 'bold
			:background (face-attribute 'fringe :background))
    (set-face-attribute 'mode-line-inactive nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:background (face-attribute 'fringe :background)
			:family "Fira Sans"
			:weight 'bold
			:box `(:line-width -2 :color ,(face-attribute 'fringe :background)))
    (set-face-attribute 'powerline-active1 nil
			:background "gray30")
    (set-face-attribute 'powerline-inactive1 nil
			:background (face-attribute 'default :background)
			:box `(:line-width -2 :color ,(face-attribute 'fringe :background)))

    ;; these next faces are for the status indicator
    ;; read-only buffer
    (make-face 'mode-line-read-only-face)
    (make-face 'mode-line-read-only-inactive-face)
    (set-face-attribute 'mode-line-read-only-face nil
			:foreground (face-attribute 'default :foreground)
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-read-only-inactive-face nil
			:foreground (face-attribute 'default :foreground)
			:inherit 'mode-line-inactive)

    ;; modified buffer
    (make-face 'mode-line-modified-face)
    (make-face 'mode-line-modified-inactive-face)
    (set-face-attribute 'mode-line-modified-face nil
			:foreground (face-attribute 'default :background)
			:background "#e5786d"
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-modified-inactive-face nil
			:foreground (face-attribute 'default :background)
			:background "#e5786d"
			:inherit 'mode-line-inactive)

    ;; unmodified buffer
    (make-face 'mode-line-unmodified-face)
    (make-face 'mode-line-unmodified-inactive-face)
    (set-face-attribute 'mode-line-unmodified-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-unmodified-inactive-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'mode-line-inactive)

    ;; the remote indicator
    (make-face 'mode-line-remote-face)
    (make-face 'mode-line-remote-inactive-face)
    (set-face-attribute 'mode-line-remote-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:background (face-attribute 'default :background)
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-remote-inactive-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:background (face-attribute 'default :background)
			:inherit 'mode-line-inactive)

    ;; the current file name
    (make-face 'mode-line-filename-face)
    (make-face 'mode-line-filename-inactive-face)
    (set-face-attribute 'mode-line-filename-face nil
			:foreground (face-attribute 'font-lock-type-face :foreground)
			:background (face-attribute 'default :background)
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-filename-inactive-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:background (face-attribute 'default :background)
			:inherit 'mode-line-inactive)

    ;; the major mode name
    (make-face 'mode-line-major-mode-face)
    (make-face 'mode-line-major-mode-inactive-face)
    (set-face-attribute 'mode-line-major-mode-face nil
			:foreground (face-attribute 'default :foreground)
			:inherit 'powerline-active1)
    (set-face-attribute 'mode-line-major-mode-inactive-face nil
			:box `(:line-width -2 :color ,(face-attribute 'fringe :background))
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'powerline-inactive1)

    ;; the minor mode name
    (make-face 'mode-line-minor-mode-face)
    (make-face 'mode-line-minor-mode-inactive-face)
    (set-face-attribute 'mode-line-minor-mode-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'powerline-active1)
    (set-face-attribute 'mode-line-minor-mode-inactive-face nil
			:box `(:line-width -2 :color ,(face-attribute 'fringe :background))
			:foreground (face-attribute 'powerline-inactive1 :background)
			:inherit 'powerline-inactive1)

    ;; the position face
    (make-face 'mode-line-position-face)
    (make-face 'mode-line-position-inactive-face)
    (set-face-attribute 'mode-line-position-face nil
			:background (face-attribute 'default :background)
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-position-inactive-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:background (face-attribute 'default :background)
			:inherit 'mode-line-inactive)

    ;; the 80col warning face
    (make-face 'mode-line-80col-face)
    (make-face 'mode-line-80col-inactive-face)
    (set-face-attribute 'mode-line-80col-face nil
			:background "#e5786d"
			:foreground (face-attribute 'default :background)
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-80col-inactive-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:background (face-attribute 'default :background)
			:inherit 'mode-line-inactive)

    ;; the buffer percentage face
    (make-face 'mode-line-percentage-face)
    (make-face 'mode-line-percentage-inactive-face)
    (set-face-attribute 'mode-line-percentage-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'mode-line)
    (set-face-attribute 'mode-line-percentage-inactive-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'mode-line-inactive)

    ;; the directory face
    (make-face 'mode-line-shell-dir-face)
    (make-face 'mode-line-shell-dir-inactive-face)
    (set-face-attribute 'mode-line-shell-dir-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'powerline-active1)
    (set-face-attribute 'mode-line-shell-dir-inactive-face nil
			:foreground (face-attribute 'font-lock-comment-face :foreground)
			:inherit 'powerline-inactive1)

    (defun shorten-directory (dir max-length)
      "Show up to `max-length' characters of a directory name `dir'."
      (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
	    (output ""))
	(when (and path (equal "" (car path)))
	  (setq path (cdr path)))
	(while (and path (< (length output) (- max-length 4)))
	  (setq output (concat (car path) "/" output))
	  (setq path (cdr path)))
	(when path
	  (setq output (concat ".../" output)))
	output))

    (defpowerline my--powerline-narrow
      (let (real-point-min real-point-max)
	(save-excursion
	  (save-restriction
	    (widen)
	    (setq real-point-min (point-min) real-point-max (point-max))))
	(when (or (/= real-point-min (point-min))
		  (/= real-point-max (point-max)))
	  (propertize (concat (char-to-string #x2691) " Narrow")
		      'mouse-face 'mode-line-highlight
		      'help-echo "mouse-1: Remove narrowing from the current buffer"
		      'local-map (make-mode-line-mouse-map
				  'mouse-1 'mode-line-widen)))))


    (setq-default
     mode-line-format
     '("%e"
       (:eval
	(let* ((active (powerline-selected-window-active))

	       ;; toggle faces between active and inactive
	       (mode-line (if active 'mode-line 'mode-line-inactive))
	       (face1 (if active 'powerline-active1 'powerline-inactive1))
	       (face2 (if active 'powerline-active2 'powerline-inactive2))
	       (read-only-face (if active 'mode-line-read-only-face 'mode-line-read-only-inactive-face))
	       (modified-face (if active 'mode-line-modified-face 'mode-line-modified-inactive-face))
	       (unmodified-face (if active 'mode-line-unmodified-face 'mode-line-unmodified-inactive-face))
	       (position-face (if active 'mode-line-position-face 'mode-line-position-inactive-face))
	       (80col-face (if active 'mode-line-80col-face 'mode-line-80col-inactive-face))
	       (major-mode-face (if active 'mode-line-major-mode-face 'mode-line-major-mode-inactive-face))
	       (minor-mode-face (if active 'mode-line-minor-mode-face 'mode-line-minor-mode-inactive-face))
	       (filename-face (if active 'mode-line-filename-face 'mode-line-filename-inactive-face))
	       (percentage-face (if active 'mode-line-percentage-face 'mode-line-percentage-inactive-face))
	       (remote-face (if active 'mode-line-remote-face 'mode-line-remote-inactive-face))
	       (shell-dir-face (if active 'mode-line-shell-dir-face 'mode-line-shell-dir-inactive-face))

	       ;; get the separators
	       (separator-left (intern (format "powerline-%s-%s"
					       (powerline-current-separator)
					       (car powerline-default-separator-dir))))
	       (separator-right (intern (format "powerline-%s-%s"
						(powerline-current-separator)
						(cdr powerline-default-separator-dir))))

	       ;; the right side
	       (rhs (list
		     ;;(my--powerline-vc minor-mode-face 'r)
		     (funcall separator-right face1 position-face)
		     (powerline-raw " " position-face)
		     ;; Weird lowercase "L"
		     ;; (powerline-raw (char-to-string #xe0a1) position-face)
		     (powerline-raw " " position-face)
		     (powerline-raw "%4l" position-face 'r)
		     ;; display a warning if we go above 80 columns
		     (if (>= (current-column) 80)
			 (funcall separator-right position-face 80col-face)
		       (powerline-raw (char-to-string #x2502) position-face))
		     (if (>= (current-column) 80)
			 (powerline-raw "%3c" 80col-face 'l)
		       (powerline-raw "%3c" position-face 'l))
		     (if (>= (current-column) 80)
			 (powerline-raw " " 80col-face)
		       (powerline-raw " " position-face))
		     (if (>= (current-column) 80)
			 (funcall separator-left 80col-face percentage-face)
		       (funcall separator-left position-face percentage-face))
		     (powerline-raw " " percentage-face)
		     (powerline-raw "%6p" percentage-face 'r)))

	       ;; the left side
	       (lhs (list
		     ;; this is the modified status indicator
		     (cond (buffer-read-only
			    (powerline-raw "  " read-only-face))
			   ((buffer-modified-p)
			    ;; do not light up when in an interactive buffer. Set
			    ;; ML-INTERACTIVE? in hooks for interactive buffers.
			    (if (not (bound-and-true-p ml-interactive?))
				(powerline-raw "  " modified-face)
			      (powerline-raw "  " unmodified-face)))
			   ((not (buffer-modified-p))
			    (powerline-raw "  " unmodified-face)))
		     (cond (buffer-read-only
			    (powerline-raw (concat (char-to-string #xe0a2) " ") read-only-face 'l))
			   ((buffer-modified-p)
			    (if (not (bound-and-true-p ml-interactive?))
				(powerline-raw (concat (char-to-string #x2621) " ") modified-face 'l)
			      (powerline-raw (concat (char-to-string #x259e) " ") unmodified-face 'l)))
			   ((not (buffer-modified-p))
			    (powerline-raw (concat (char-to-string #x26c1) " ") unmodified-face 'l)))
		     (cond (buffer-read-only
			    (funcall separator-right read-only-face filename-face))
			   ((buffer-modified-p)
			    (if (not (bound-and-true-p ml-interactive?))
				(funcall separator-right modified-face filename-face)
			      (funcall separator-right unmodified-face filename-face)))
			   ((not (buffer-modified-p))
			    (funcall separator-right unmodified-face filename-face)))
		     ;; remote indicator
		     (when (file-remote-p default-directory)
		       (powerline-raw (concat " " (char-to-string #x211b)) remote-face))
		     ;; filename and mode info
		     (powerline-buffer-id filename-face 'l)
		     (powerline-raw " " filename-face)
		     (funcall separator-left filename-face major-mode-face)
		     ;; do not need mode info when in ansi-term
		     (unless (bound-and-true-p show-dir-in-mode-line?)
		       (powerline-major-mode major-mode-face 'l))
		     (unless (bound-and-true-p show-dir-in-mode-line?)
		       (powerline-process major-mode-face 'l))
		     ;; show a flag if in line mode in terminal
		     (when (and (bound-and-true-p show-dir-in-mode-line?) (term-in-line-mode))
		       (powerline-raw (concat (char-to-string #x2691) " Line") major-mode-face))
		     (powerline-raw " " major-mode-face)
		     ;; little trick to move the directory name to the mode line
		     ;; when inside of emacs set SHOW-DIR-IN-MODE-LINE? to enable
		     (if (bound-and-true-p show-dir-in-mode-line?)
			 (when (not (file-remote-p default-directory))
			   (powerline-raw (shorten-directory default-directory 45)
					  shell-dir-face))
		       (powerline-minor-modes minor-mode-face 'l))
		     (unless (bound-and-true-p show-dir-in-mode-line?)
		       (my--powerline-narrow major-mode-face 'l)))))

	  ;; concatenate it all together
	  (concat (powerline-render lhs)
		  (powerline-fill face1 (powerline-width rhs))
		  (powerline-render rhs))))))
))
#+END_SRC
** Whitespace
The following can visualize white space quite neatly:
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :defer t
  :bind ("\C-cw" . global-whitespace-mode)
  :config
  (setq whitespace-style
	'(face
	  trailing
	  tabs
	  spaces
	  lines
	  lines-tail
	  newline
	  ;;empty
	  space-before-tab
	  indentation
	  empty
	  space-after-tab
	  space-mark
	  tab-mark
	  ;;newline-mark
	  ))
)
#+END_SRC

** TODO Mouse avoidance
Unfortunately this doesn't work well in =customize-group=.

#+BEGIN_SRC emacs-lisp
(use-package avoid
  :config
  (mouse-avoidance-mode 'jump)
)
#+END_SRC
* Misc settings
** Emacs internals

#+BEGIN_SRC emacs-lisp
(setq message-log-max 10000)
#+END_SRC

Use new byte codes from Emacs 24.4

#+BEGIN_SRC emacs-lisp
(setq byte-compile--use-old-handlers nil)
(setq ad-redefinition-action 'accept)
#+END_SRC

** Fixup system-name
Normally, I could use the =system-name= variable to get the current
hostname, but it seems to return the value of =hostname -f=, e.g.
"holger.schurig.local". Therefore, I find the hostname manually by
calling =shell-command-to-string= and stripping some whitespace. This
will probably /not/ work on windows.

#+BEGIN_SRC emacs-lisp
(setq system-name
   (replace-regexp-in-string "\\`[ \t\n]*" ""
      (replace-regexp-in-string "[ \t\n]*\\'" ""
         (shell-command-to-string "hostname"))))
#+END_SRC
** History
Delete identical history entries
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC
** Save mini-buffer history
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :init
   (setq savehist-file (concat user-emacs-directory "tmp/history.el")
	 history-length 1000)
  :config
  (savehist-mode 1))
#+END_SRC
** Enable some disabled commands

#+BEGIN_SRC emacs-lisp
(put 'erase-buffer 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Default browser

#+BEGIN_SRC emacs-lisp
(use-package browse-url
  :defer t
  :config
  (setq browse-url-browser-function 'browse-url-generic
	browse-url-generic-program "x-www-browser"))
#+END_SRC

** Simpler yes or no prompt

#+BEGIN_SRC emacs-lisp
;  Get rid of yes-or-no questions - y or n is enough
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Customization

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(if (file-exists-p custom-file) (load-file custom-file))
#+END_SRC

Keep lisp names in the custom buffers, don't capitalize:

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :defer t
  :config
  (setq custom-unlispify-tag-names nil))
#+END_SRC

** Localisation
A sentence doesn't end with two spaces:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
** Dash
#+BEGIN_SRC emacs-lisp
(use-package dash
  :defer t
  :commands (-difference)
)
#+END_SRC
* Emacs server

- always start the emacs-server, except when run in daemon mode
- already Disable prompt asking you if you want to kill a buffer
  with a live process attached to it.
  http://stackoverflow.com/questions/268088/how-to-remove-the-prompt-for-killing-emacsclient-buffers

#+BEGIN_SRC emacs-lisp
(use-package server
  :config
  (unless (or (daemonp) (server-running-p)
      (server-mode 1)))
  (add-hook 'server-switch-hook 'raise-frame)
)
#+END_SRC

A good way to start emacsclient is with this line in =/etc/bash.bashrc=:

#+BEGIN_EXAMPLE
alias e="emacsclient --no-wait --alternate-editor=\"\" --create-frame"
#+END_EXAMPLE

May may also set the environment variables =EDITOR= and/or =VISUAL=,
but then you better omit the "=--no-wait=" option.

* Editing
** CANCELED Transpose
http://endlessparentheses.com/transposing-keybinds-in-emacs.html

#+BEGIN_SRC emacs-lisp
(bind-key "\C-t" #'transpose-lines)
(bind-key "\C-t" #'transpose-chars ctl-x-map)
#+END_SRC
** Undo-Tree
This lets you use =C-z= (undo-tree-visualize) to visually walk through
the changes you've made, undo back to a certain point (or redo), and
go down different branches.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :commands (undo-tree-visualize)
  :bind ("C-z" . undo-tree-visualize)
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC
* Cursor movement
First we define code that allows us to bind multiple functions to
repeated commands. Taken from
[[http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding]]:

#+BEGIN_SRC emacs-lisp
(defvar seq-times 0
  "Stores number of times command was executed.  It cotnains
random data before `seq-times' macro is called.")

(defmacro seq-times (&optional name max &rest body)
  "Returns number of times command NAME was executed and updates
`seq-times' variable accordingly.  If NAME is nil `this-command'
will be used.  If MAX is specified the counter will wrap around
at the value of MAX never reaching it.  If body is given it will
be evaluated if the command is run for the first time in a
sequence."
  (declare (indent 2))

  ;; Build incrementation part
  (setq max (cond ((null max) '(setq seq-times (1+ seq-times)))
		  ((atom max) (if (and (integerp max) (> max 0))
				  `(setq seq-times (% (1+ seq-times) ,max))
				'(setq seq-times (1+ seq-times))))
		  (t          `(let ((max ,max))
				 (if (and (integerp max) (> max 0))
				     (setq seq-times (% (1+ seq-times) max))
				   (setq seq-times (1+ seq-times)))))))

  ;; Make macro
  (if (eq name 'last-command)
      max
    (cond ((null  name) (setq name 'this-command))
	  ((consp name) (setq name `(or ,name this-command))))
    `(if (eq last-command ,name)
	 ,max
       ,@body
       (setq seq-times 0))))

(defmacro seq-times-nth (name body &rest list)
  "Calls `seq-times' with arguments NAME, length and BODY
and (where length is the number of elements in LIST) then returns
`seq-times'th element of LIST."
  (declare (indent 2))
  `(nth (seq-times ,name ,(length list) ,body) ',list))

(defmacro seq-times-do (name body &rest commands)
  "Calls `seq-times' with arguments NAME, length and BODY (where
length is the number of COMMANDS) and then runs `seq-times'th
command from COMMANDS."
  (declare (indent 2))
  `(eval (nth (seq-times ,name ,(length commands) ,body) ',commands)))
#+END_SRC

** Home / End

#+BEGIN_SRC emacs-lisp
(defvar my--previous-position)

(defun my-home ()
  "Depending on how many times it was called moves the point to:

   - begin of indentation
   - beginning of line
   - begin of function
   - beginning of buffer
   - back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
    (back-to-indentation)
    (beginning-of-line)
    (beginning-of-defun)
    (goto-char (point-min))
    (goto-char my--previous-position)))
#+END_SRC

(substitute-key-definition 'move-beginning-of-line 'my-home (current-global-map))

#+BEGIN_SRC emacs-lisp
(bind-key "C-a" 'my-home)
(bind-key "<home>" 'my-home)


(defun my-end ()
  "Depending on how many times it was called moves the point to:

   - end of line
   - end of function
   - end of buffer
   - back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
    (end-of-line)
    (forward-paragraph)
    (end-of-defun)
    (goto-char (point-max))
    (goto-char my--previous-position)))
(bind-key "C-e" 'my-end)
(bind-key "<end>" 'my-end)
#+END_SRC

** Recenter

#+BEGIN_SRC emacs-lisp
(setq recenter-positions '(middle 4 -4))
#+END_SRC

** Nicer goto-line
Doesn't modify minibuffer-history, but use it's own little history
list.

#+BEGIN_SRC emacs-lisp
(defvar my-goto-line-history '())
(defun my-goto-line (line &optional buffer)
  "Goto LINE, counting from line 1 at beginning of buffer.
Normally, move point in the current buffer, and leave mark at the
previous position.  With just \\[universal-argument] as argument,
move point in the most recently selected other buffer, and switch to it.

If there's a number in the buffer at point, it is the default for LINE.

This function is usually the wrong thing to use in a Lisp program.
What you probably want instead is something like:
  (goto-char (point-min)) (forward-line (1- N))
If at all possible, an even better solution is to use char counts
rather than line counts."
  (interactive
   (if (and current-prefix-arg (not (consp current-prefix-arg)))
       (list (prefix-numeric-value current-prefix-arg))
     ;; Look for a default, a number in the buffer at point.
     (let* ((default
	      (save-excursion
		(skip-chars-backward "0-9")
		(if (looking-at "[0-9]")
		    (buffer-substring-no-properties
		     (point)
		     (progn (skip-chars-forward "0-9")
			    (point))))))
	    ;; Decide if we're switching buffers.
	    (buffer
	     (if (consp current-prefix-arg)
		 (other-buffer (current-buffer) t)))
	    (buffer-prompt
	     (if buffer
		 (concat " in " (buffer-name buffer))
	       "")))
       ;; Read the argument, offering that number (if any) as default.
       (list (read-from-minibuffer (format (if default "Goto line%s (%s): "
					     "Goto line%s: ")
					   buffer-prompt
					   default)
				   nil nil t
				   'my-goto-line-history
				   default)
	     buffer))))
  ;; Switch to the desired buffer, one way or another.
  (if buffer
      (let ((window (get-buffer-window buffer)))
	(if window (select-window window)
	  (switch-to-buffer-other-window buffer))))
  ;; Leave mark at previous position
  (or (region-active-p) (push-mark))
  ;; Move to the specified line number in that buffer.
  (save-restriction
    (widen)
    (goto-char (point-min))
    (if (eq selective-display t)
	(re-search-forward "[\n\C-m]" nil 'end (1- line))
      (forward-line (1- line)))))
(bind-key "M-g g"   'my-goto-line)
(bind-key "M-g M-g" 'my-goto-line)
#+END_SRC

** expand-region
Home page: https://github.com/magnars/expand-region.el

C-+ Expand region increases the selected region by semantic units.

You can then either continue to press C-+ to expand even further, or
use + and - after the first expand to expand further / shrink again.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-+" . er/expand-region)
  :config
  (setq expand-region-reset-fast-key    "<ESC><ESC>"))
#+END_SRC

** bookmark

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :config
  (setq bookmark-default-file (concat user-emacs-directory "tmp/bookmarks.el"))
  )
#+END_SRC

** avy (alternative to ace-jump-mode)

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind ("C-#" . avy-goto-char-timer)
  :config (progn
	    (setq avy-keys (append (number-sequence ?a ?z)
				    (number-sequence ?0 ?9)))
	    (setq avy-style 'at-full)
	    (setq avy-all-windows nil)
	    (setq avy-highlight-first t)))
#+END_SRC

** smartscan
This makes =M-n= and =M-p= look for the symbol at point. This is
very un-intrusive, no pop-up, no nothing,

#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :config
  (global-smartscan-mode t)
  )
#+END_SRC

** Mouse scrolling
Smooth scrolling (default is 5).

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(2 ((shift) . 1) ((control) . nil))
      mouse-wheel-progressive-speed nil)
#+END_SRC
* Yank and Delete
** Delete word or yank
The following may be of interest to people who (a) are happy with
"C-w" and friends for killing and yanking, (b) use
"transient-mark-mode", (c) also like the traditional Unix tty
behaviour that "C-w" deletes a word backwards. It tweaks "C-w" so
that, if the mark is inactive, it deletes a word backwards instead
of killing the region. Without that tweak, the C-w would create an
error text without an active region.
http://www.emacswiki.org/emacs/DefaultKillingAndYanking#toc2

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before unix-werase activate compile)
  "When called interactively with no active region, delete a single word
    backwards instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (save-excursion (backward-word 1) (point)) (point)))))
#+END_SRC

** Selection deletion
Use delete-selection mode:

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Deletion in readonly buffer
Be silent when killing text from read only buffer:

#+BEGIN_SRC emacs-lisp
(setq kill-read-only-ok t)
#+END_SRC

** Join lines at killing
If at end of line, join with following; otherwise kill line.
Deletes whitespace at join.

#+BEGIN_SRC emacs-lisp
(defun kill-and-join-forward (&optional arg)
  "If at end of line, join with following; otherwise kill line.
Deletes whitespace at join."
  (interactive "P")
  (if (and (eolp) (not (bolp)))
      (delete-indentation t)
    (kill-line arg)))
(bind-key "C-k" 'kill-and-join-forward)
#+END_SRC

** Dynamic char deletion
The following is from Boojum's post in
[[http://www.reddit.com/r/emacs/comments/b1r8a/remacs_tell_us_about_the_obscure_but_useful/]].

I don't want to kill the comment, just the prefix to it. So that

// The quick brown fox[]
// jumps over the lazy dog.

becomes

// The quick brown fox[] jumps over the lazy dog.

#+BEGIN_SRC emacs-lisp
(defun delete-char-dynamic (&optional arg)
  "If at end of line, intelligently join to the following;
otherwise delete."
  (interactive "p")
  (if (or (not (eolp)) (bolp))
      (delete-char arg)
    (let ((start (point))
          (in-comment (eq (get-text-property (point) 'face)
                          'font-lock-comment-face)))
      (forward-char)
      (skip-chars-forward " \  ")
      (if (and in-comment (looking-at comment-start-skip))
          (goto-char (match-end 0)))
      (delete-region start (point))
      (when (and (not (eolp))
                 (/= (char-before) ? )
                 (/= (char-before) ?\  ))
        (insert-char ?  1)
        (backward-char)))))
#+END_SRC

Make delete-selection-mode work with it

#+BEGIN_SRC emacs-lisp
(put 'delete-char-dynamic 'delete-selection 'supersede)
#+END_SRC

Rebind DELETE and friends to our version

#+BEGIN_SRC emacs-lisp
(bind-key "<deletechar>" 'delete-char-dynamic)
(bind-key "<delete>" 'delete-char-dynamic)
(bind-key "C-d" 'delete-char-dynamic)
#+END_SRC

** X11 clipboard

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

** Mouse yank
Paste at text-cursor, not at mouse-cursor:

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
** Package avy-zap: delete up to a character
This makes =M-z= ask via avy to which character text should be
deleted. The character itself will stay. If you use =M-Z=, then this
character will be gone, too.

#+BEGIN_SRC emacs-lisp
(use-package avy-zap
  :ensure t
  :bind (("M-z" . avy-zap-up-to-char-dwim)
	 ("M-Z" . avy-zap-to-char-dwim))
)
#+END_SRC
* Completion
ignore case when reading a file name completion

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

do not consider case significant in completion (GNU Emacs default)

#+BEGIN_SRC emacs-lisp
(setq completion-ignore-case t)
#+END_SRC

lets TAB do completion as well

#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
(setq completions-format 'vertical)
#+END_SRC

* Windows handling
** delete-window
If only one window in frame, `delete-frame'.
From http://www.emacswiki.org/emacs/frame-cmds.el

#+BEGIN_SRC emacs-lisp
(defadvice delete-window (around delete-window (&optional window) activate)
  (interactive)
  (save-current-buffer
    (setq window (or window (selected-window)))
    (select-window window)
    (if (one-window-p t)
	(delete-frame)
      ad-do-it (selected-window))))
#+END_SRC

** new kill-buffer-and-window
Replacement for interactive `kill-buffer'. We cannot redefine
`kill-buffer', because other elisp code relies on it's exact
behavior.

#+BEGIN_SRC emacs-lisp
(defun my--kill-buffer-and-window (&optional buffer)
  "Kill buffer BUFFER-OR-NAME.
The argument may be a buffer or the name of an existing buffer.
Argument nil or omitted means kill the current buffer. Return t
if the buffer is actually killed, nil otherwise.

Unlike `kill-buffer', this also will delete the current window if
there are several windows open."
  (interactive)
  (setq buffer (or buffer (current-buffer)))
  (unless (one-window-p)
    (delete-window))
  (kill-buffer buffer))
(bind-key "C-x k" 'my--kill-buffer-and-window)
#+END_SRC

** Window sizing

#+BEGIN_SRC emacs-lisp
(bind-key "<M-down>" 'enlarge-window)
(bind-key "<M-up>" 'shrink-window)
#+END_SRC

** Window zooming (F5)
If there is only one window displayed, act like =C-x 2=. If there are
two windows displayed, act like =C-x 1=.

#+BEGIN_SRC emacs-lisp
(defun my-zoom-next-buffer2 ()
  (let ((curbuf (current-buffer))
	(firstbuf nil))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
	;(princ (format "name %s, fn %s\n" (buffer-name) buffer-file-name))
	(unless (or
		 ;; Don't mention internal buffers.
		 (string= (substring (buffer-name) 0 1) " ")
		 ;; No buffers without files.
		 (not buffer-file-name)
		 ;; Skip the current buffer
		 (eq buffer curbuf)
		 )
	  ;(princ (format " nme %s, fn %s\n" (buffer-name) buffer-file-name))
	  (unless firstbuf
	    (setq firstbuf buffer))
	    ;;(print buffer)
	  )))
    (when firstbuf
      ;(princ (format "new buffer: %s.\n" firstbuf))
      (bury-buffer)
      (switch-to-buffer firstbuf))))
(defun my-explode-window ()
  "If there is only one window displayed, act like C-x2. If there
are two windows displayed, act like C-x1:"
  (interactive)
  (if (one-window-p t)
      (progn
	(split-window-vertically)
	(other-window 1)
	(my-zoom-next-buffer2)
	(other-window -1))
    (delete-other-windows)))
(bind-key "<f5>" 'my-explode-window)
#+END_SRC
** Windows toggle / Buffer switching (F6)
If there is only one window displayed, swap it with previous buffer.
If there are two windows displayed, act like =C-x o=.

#+BEGIN_SRC emacs-lisp
(defun my-switch-to-buffer ()
  "If there is only one window displayed, swap it with previous buffer.
If there are two windows displayed, act like =C-x o=."
  (interactive)
  (if (one-window-p t)
      (switch-to-buffer (other-buffer (current-buffer) 1))
    (other-window -1)))
(bind-key "<f6>" 'my-switch-to-buffer)
#+END_SRC

** Winner mode

#+BEGIN_SRC emacs-lisp
(use-package winner
  :defer 10
  :init
  (winner-mode 1))
#+END_SRC
** Other window
#+BEGIN_SRC emacs-lisp
(bind-key "M-o" #'other-window)
#+END_SRC
* Buffers

** Insert buffer
|-------+---------------|
| C-x i | insert file   |
|-------+---------------|
| C-x I | insert buffer |
|-------+---------------|
Insert buffer at current position

#+BEGIN_SRC emacs-lisp
(bind-key "C-x I" 'insert-buffer)
#+END_SRC

** Protect buffers
https://raw.githubusercontent.com/lewang/le_emacs_libs/master/keep-buffers.el

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'cl))
(define-minor-mode keep-buffers-mode
  "when active, killing protected buffers results in burying them instead.
Some may also be erased, which is undo-able."
  :init-value nil
  :global t
  :group 'keep-buffers
  :lighter ""
  :version "1.4"
  (if keep-buffers-mode
      ;; Setup the hook
      (add-hook 'kill-buffer-query-functions 'keep-buffers-query)
    (remove-hook 'kill-buffer-query-functions 'keep-buffers-query)))
(defcustom keep-buffers-protected-alist
  '(("\\`\\*scratch\\*\\'" . erase)
    ("\\`\\*Messages\\*\\'" . nil))
  "an alist '((\"regex1\" . 'erase) (\"regex2\" . nil))

CAR of each cons cell is the buffer matching regexp.  If CDR is
not nil then the matching buffer is erased then buried.

If the CDR is nil, then the buffer is only buried."
  :type '(alist)
  :group 'keep-buffers)
(defun keep-buffers-query ()
  "The query function that disable deletion of buffers we protect."
  (let ((crit (dolist (crit keep-buffers-protected-alist)
                (when (string-match (car crit) (buffer-name))
                  (return crit)))))
    (if crit
        (progn
          (when (cdr crit)
            (erase-buffer))
          (bury-buffer)
          nil)
      t)))
(keep-buffers-mode 1)
#+END_SRC

** Easier kill buffers with processes
Don't asks you if you want to kill a buffer with a live process
attached to it:
http://www.masteringemacs.org/articles/2010/11/14/disabling-prompts-emacs/

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
	     kill-buffer-query-functions))
#+END_SRC

** Cycle buffers

** iflipb
http://www.emacswiki.org/emacs/iflipb

#+BEGIN_SRC emacs-lisp
(use-package iflipb
  :ensure t
  :commands (iflipb-next-buffer iflipb-previous-buffer)
  :bind ("S-<f6>" . my-iflipb-previous-buffer)
  :config
  (setq iflipb-wrap-around t)

  (defvar my-iflipb-auto-off-timeout-sec 4.5)
  (defvar my-iflipb-auto-off-timer-canceler-internal nil)
  (defvar my-iflipb-ing-internal nil)
  (defun my-iflipb-auto-off ()
    (message nil)
    (setq my-iflipb-auto-off-timer-canceler-internal nil
	  my-iflipb-ing-internal nil))
  (defun my-iflipb-next-buffer (arg)
    (interactive "P")
    (iflipb-next-buffer arg)
    (if my-iflipb-auto-off-timer-canceler-internal
	(cancel-timer my-iflipb-auto-off-timer-canceler-internal))
    (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
    (setq my-iflipb-ing-internal t))
  (defun my-iflipb-previous-buffer ()
    (interactive)
    (iflipb-previous-buffer)
    (if my-iflipb-auto-off-timer-canceler-internal
	(cancel-timer my-iflipb-auto-off-timer-canceler-internal))
    (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
    (setq my-iflipb-ing-internal t))
  (defun iflipb-first-iflipb-buffer-switch-command ()
    "Determines whether this is the first invocation of
  iflipb-next-buffer or iflipb-previous-buffer this round."
    (not (and (or (eq last-command 'my-iflipb-next-buffer)
		  (eq last-command 'my-iflipb-previous-buffer))
	      my-iflipb-ing-internal))))
#+END_SRC

** ace-jump-buffer DISABLED

#+BEGIN_SRC emacs-lisp
(use-package ace-jump-buffer
  :disabled t
  :bind ("C-c C-j" . ace-jump-buffer)
  )
#+END_SRC

* File opening/saving
** Basic settings
Never show GTK file open dialog

#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil)
#+END_SRC

don't add newlines to end of buffer when scrolling, but show them

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines nil)
#+END_SRC

Preserve hard links to the file youÂ´re editing (this is
especially important if you edit system files)

#+BEGIN_SRC emacs-lisp
(setq backup-by-copying-when-linked t)
#+END_SRC

Just never create backup files at all
make-backup-files nil

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist (list (cons "." (concat user-emacs-directory "tmp/bak/"))))
#+END_SRC

Make sure your text files end in a newline

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Disable auto-save (#init.el# file-names)

#+BEGIN_SRC emacs-lisp
(setq auto-save-default nil)
(setq auto-save-list-file-prefix (concat user-emacs-directory "tmp/auto-save-list/saves-"))
#+END_SRC

Kill means kill, not asking. Was:

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions nil)
#+END_SRC

** Automatically load .Xresources after changes
Sample ~/.Xresources:

Emacs.geometry: 120x55
Emacs.Font:	terminus 11

#+BEGIN_SRC emacs-lisp
(defun merge-x-resources ()
  (let ((file (file-name-nondirectory (buffer-file-name))))
    (when (or (string= file ".Xdefaults")
	      (string= file ".Xresources"))
      (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
      (message (format "Merged %s into X resource database" file)))))
(add-hook 'after-save-hook 'merge-x-resources)
#+END_SRC

** Autorevert
Revert all buffers, including dired buffers. And do it silently.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC

Don't ask when running revert-buffer when reverting files in this
list of regular expressions:

#+BEGIN_SRC emacs-lisp
(setq revert-without-query '(""))
#+END_SRC

** Decompress compressed files

#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC

** Quickly save (F2)

#+BEGIN_SRC emacs-lisp
(bind-key "<f2>" 'save-buffer)
#+END_SRC

** Unique buffer names

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

** recentf

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (setq recentf-save-file (concat user-emacs-directory "tmp/recentf.el"))
  (setq recentf-exclude '("^/tmp/"
			 "/.newsrc"
			 "bbdb$"
			 "svn-commit.tmp$"
			 ".png$"
			 "COMMIT_EDITMSG" "COMMIT_EDITMSG" "TAG_EDITMSG"))
  (setq recentf-max-saved-items 1000)
  (setq recentf-auto-cleanup 300)
  (setq recentf-max-menu-items 20))

(recentf-mode 1)
#+END_SRC
* Minibuffer
Don't insert current directory into minubuffer

#+BEGIN_SRC emacs-lisp
(setq insert-default-directory nil)
#+END_SRC

Minibuffer window expands vertically as necessary to hold the text
that you put in the minibuffer

#+BEGIN_SRC emacs-lisp
(setq resize-mini-windows t) ;; was grow-only
#+END_SRC

Read quoted chars with radix 16

#+BEGIN_SRC emacs-lisp
(setq read-quoted-char-radix 16)
#+END_SRC

Allow to type space chars in minibuffer input (for `timeclock-in',
for example).

#+BEGIN_SRC emacs-lisp
(define-key minibuffer-local-completion-map " " nil)
(define-key minibuffer-local-must-match-map " " nil)
#+END_SRC
* Searching

** isearch (incremental search)
Scrolling while searching

#+BEGIN_SRC emacs-lisp
(setq isearch-allow-scroll t)
(bind-key "C-y" 'isearch-yank-kill isearch-mode-map)
#+END_SRC

** Command; my-grep
Prompts you for an expression, defaulting to the symbol that your
cursor is on, and greps for that in the current directory and all
subdirectories:

#+BEGIN_SRC emacs-lisp
(defun my-grep ()
  "grep the whole directory for something defaults to term at cursor position"
  (interactive)
  (let ((default (thing-at-point 'symbol)))
    (let ((needle (or (read-string (concat "grep for '" default "': ")) default)))
      (setq needle (if (equal needle "") default needle))
      (grep (concat "egrep -s -i -n -r " needle " *")))))
(bind-key "M-s g" 'my-grep)
#+END_SRC
* Help

** Go to back to previous help buffer
Make 'b' (back) go to the previous position in emacs help.
[[http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks]]

#+BEGIN_SRC emacs-lisp
(add-hook 'help-mode-hook
	  '(lambda ()
	     (bind-key "b" 'help-go-back help-mode-map)))
#+END_SRC

** F1 key searches in help or opens man page

#+BEGIN_SRC emacs-lisp
(defun my-help ()
  "If function given tries to `describe-function' otherwise uses
`manual-entry' to display manpage of a `current-word'."
  (interactive)
  (let ((var (variable-at-point)))
    (if (symbolp var)
	(describe-variable var)
      (let ((fn (function-called-at-point)))
	(if fn
	    (describe-function fn)
	  (man (current-word)))))))
(bind-key "<f1>" 'my-help)
#+END_SRC

** Apropos

#+BEGIN_SRC emacs-lisp
(bind-key "C-h a" 'apropos)
#+END_SRC

** Guide key
It's hard to remember keyboard shortcuts. The guide-key package
pops up help after a short delay.

#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :ensure t
  :defer 2
  :diminish guide-key-mode
  :config
  (setq guide-key/guide-key-sequence
	'("C-c" "C-h" "C-x" "M-g" "M-s"))
  (setq guide-key/recursive-key-sequence-flag t)
  (guide-key-mode 1))
#+END_SRC
* Miscelleanous
** dos2unix

#+BEGIN_SRC emacs-lisp
(defun dos2unix()
  "convert dos (^M) end of line to unix end of line"
  (interactive)
  (goto-char(point-min))
  (while (search-forward "\r" nil t) (replace-match "")))
#+END_SRC

** 822date
Inserts something like "Fri,  1 Dec 2006 15:41:36 +0100"

#+BEGIN_SRC emacs-lisp
(defun 822date ()
  "Insert date at point format the RFC822 way."
  (interactive)
  (insert (format-time-string "%a, %e %b %Y %H:%M:%S %z")))
#+END_SRC
** Calculate region
From https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/:

Write some expression, e.g. =2+2*4= and then press C-=.

#+BEGIN_SRC emacs-lisp

(defun calc-eval-region (arg)
  "Evaluate an expression in calc and communicate the result.

If the region is active evaluate that, otherwise search backwards
to the first whitespace character to find the beginning of the
expression. By default, replace the expression with its value. If
called with the universal prefix argument, keep the expression
and insert the result into the buffer after it. If called with a
negative prefix argument, just echo the result in the
minibuffer."
  (interactive "p")
  (let (start end)
    (if (use-region-p)
	(setq start (region-beginning) end (region-end))
      (progn
	(setq end (point))
	(setq start (search-backward-regexp "\\s-\\|\n" 0 1))
	(setq start (1+ (if start start 0)))
	(goto-char end)))
    (let ((value (calc-eval (buffer-substring-no-properties start end))))
      (pcase arg
	(1 (delete-region start end))
	(4 (insert " = ")))
      (pcase arg
	((or 1 4) (insert value))
	(-1 (message value))))))
(bind-key "C-=" #'calc-eval-region)
#+END_SRC
* Other packages
** circe (IRC client)
see some configuration ideas at https://github.com/jorgenschaefer/circe/wiki/Configuration

#+BEGIN_SRC emacs-lisp
(use-package circe
  :defer t
  :ensure t
  :commands (circe)
  :config
  (setq circe-default-part-message "Fire on mainboard error")
  (setq circe-quit-part-message "Fire on mainboard error")
  (setq circe-reduce-lurker-spam t)
  ;; (circe-set-display-handler "JOIN" (lambda (&rest ignored) nil))
  ;; (circe-set-display-handler "QUIT" (lambda (&rest ignored) nil))
  ;; (setq circe-use-cycle-completion t)
  (setq circe-format-say "{nick}: {body}")
  (setq circe-server-killed-confirmation 'ask-and-kill-all)
  ;; Network settings
  (setq circe-default-ip-family 'ipv4)
  (setq circe-default-nick "schurig")
  (setq circe-default-user "schurig")
  (setq circe-server-auto-join-default-type 'after-auth) ; XXX try after-nick
  (setq circe-network-options `(("Freenode"
				  :host "kornbluth.freenode.net"
				  :port (6667 . 6697)
				  :channels ("#emacs" "#emacs-circe")
				  :nickserv-password ,freenode-password)
				 ))
  ;; Misc
  ;; (setq circe-format-server-topic "*** Topic change by {userhost}: {topic-diff}")
  (use-package lui-autopaste
    :config
    (add-hook 'circe-channel-mode-hook 'enable-lui-autopaste)
    )
)

(defun irc ()
  "Connect to IRC"
  (interactive)
  (circe "Freenode"))
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
(use-package dired
  :commands dired
  :bind ("C-x C-d" . dired) ;; used to be list-directory, quite useless
  :init
  (setq dired-listing-switches "-laGh1v --group-directories-first"))
#+END_SRC

** dired-x
#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :commands dired-jump
)
#+END_SRC

** helm
Very good intro: http://tuhdo.github.io/helm-intro.html

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure helm
  :diminish helm-mode
  :bind (
	 ("C-h a"   . helm-apropos)
	 ("C-x C-f" . helm-find-files)
	 ("M-s o"   . helm-occur)
	 ("M-x"     . helm-M-x)
	 ("M-y"     . helm-show-kill-ring)
         ("C-x C-b" . helm-mini)
	 )
  :init
  (require 'helm-config)
  (helm-mode t)
  :config
  ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
  ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
  ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
  ;; (from http://tuhdo.github.io/helm-intro.html)
  (bind-key "C-c h" 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  ;; allow "find man at point" for C-c h m (helm-man-woman)
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

  (setq helm-candidate-number-limit 100)
  (setq helm-quick-update t)

  ;; always pop at bottom
  ;; from https://github.com/hatschipuh/better-helm
  (setq helm-split-window-in-side-p t)
  (add-to-list 'display-buffer-alist
	       '("\\`\\*helm.*\\*\\'"
		 (display-buffer-in-side-window)
		 (inhibit-same-window . t)
		 (window-height . 0.4)))
  ;; move to end or beginning of source when reaching top or bottom of source.
  (setq helm-move-to-line-cycle-in-source t)
  ;; scroll 8 lines other window using M-<next>/M-<prior>
  (setq helm-scroll-amount 8)

  ;; see (customize-group "helm-files-faces")
  (set-face-attribute 'helm-ff-directory        nil :foreground "red" :background 'unspecified)
  (set-face-attribute 'helm-ff-dotted-directory nil :foreground "red" :background 'unspecified)
  (set-face-attribute 'helm-ff-executable       nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-ff-file             nil :foreground 'unspecified :background 'unspecified :inherit 'unspecified)
  (set-face-attribute 'helm-ff-invalid-symlink  nil :foreground 'unspecified :background 'unspecified)
  ;;(set-face-attribute 'helm-ff-prefix         nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-ff-symlink          nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-history-deleted     nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-history-remote      nil :foreground 'unspecified :background 'unspecified)

  ;; Hide modelines of other windows while helm is open
  ;; again from https://github.com/hatschipuh/better-helm
  (defvar my-helm-bottom-buffers nil
    "List of bottom buffers before helm session.
    Its element is a pair of `buffer-name' and `mode-line-format'.")

  (defun my-helm-bottom-buffers-init ()
    (setq-local mode-line-format (default-value 'mode-line-format))
    (setq my-helm-bottom-buffers
	  (cl-loop for w in (window-list)
		   when (window-at-side-p w 'bottom)
		   collect (with-current-buffer (window-buffer w)
			     (cons (buffer-name) mode-line-format)))))


  (defun my-helm-bottom-buffers-hide-mode-line ()
    (setq-default cursor-in-non-selected-windows nil)
    (mapc (lambda (elt)
	    (with-current-buffer (car elt)
	      (setq-local mode-line-format nil)))
	  my-helm-bottom-buffers))


  (defun my-helm-bottom-buffers-show-mode-line ()
    (setq-default cursor-in-non-selected-windows t)
    (when my-helm-bottom-buffers
      (mapc (lambda (elt)
	      (with-current-buffer (car elt)
		(setq-local mode-line-format (cdr elt))))
	    my-helm-bottom-buffers)
      (setq my-helm-bottom-buffers nil)))

  (defun my-helm-keyboard-quit-advice (orig-func &rest args)
    (my-helm-bottom-buffers-show-mode-line)
    (apply orig-func args))


  (add-hook 'helm-before-initialize-hook #'my-helm-bottom-buffers-init)
  (add-hook 'helm-after-initialize-hook #'my-helm-bottom-buffers-hide-mode-line)
  (add-hook 'helm-exit-minibuffer-hook #'my-helm-bottom-buffers-show-mode-line)
  (add-hook 'helm-cleanup-hook #'my-helm-bottom-buffers-show-mode-line)
  (advice-add 'helm-keyboard-quit :around #'my-helm-keyboard-quit-advice)

  ;; Hide source lines if there is only one source
  ;; based on https://github.com/hatschipuh/better-helm
  (setq helm-display-header-line nil)
  (defun my-helm-toggle-header-line ()
    (if (> (length helm-sources) 1)
	(set-face-attribute 'helm-source-header
			    nil
			    :foreground (face-attribute 'helm-source-header :foreground)
			    :background (face-attribute 'helm-source-header :background)
			    :box (face-attribute 'helm-source-header :box)
			    :height 1.0)
      (set-face-attribute 'helm-source-header
			  nil
			  :foreground (face-attribute 'helm-selection :background)
			  :background (face-attribute 'helm-selection :background)
			  :box nil
			  :height 0.1)))
  (add-hook 'helm-before-initialize-hook #'my-helm-toggle-header-line)

  ;; Hide minibuffer while helm is active
  (defun my-helm-hide-minibuffer-maybe ()
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
	(overlay-put ov 'window (selected-window))
	(overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
				`(:background ,bg-color :foreground ,bg-color)))
	(setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)
  )
#+END_SRC

**** autoloads

#+BEGIN_SRC emacs-lisp
(use-package helm-config
  :defer t
  :config
  (bind-key "g"   'helm-all-mark-rings helm-command-map)
)
(use-package helm-command
  :defer t
  :config
  (setq helm-M-x-requires-pattern nil)
  ;; this is kind of a goto, you can visit all marks
)
(use-package helm-files
  :defer t
  :config
  (setq helm-ff-skip-boring-files t)
  ;; search for library in `require' and `declare-function' sexp.
  (setq helm-ff-search-library-in-sexp t)
  (setq helm-ff-file-name-history-use-recentf t)
  (setq helm-ff-newfile-prompt-p nil)
  ;; ignore Emacs save files
  (add-to-list 'helm-boring-file-regexp-list "\\.#")

  ;; Make return delete one character or the last path (if before a '/')
  ;; from https://github.com/hatschipuh/better-helm
  (defun my-dwim-helm-find-files-up-one-level-maybe ()
    (interactive)
    (if (looking-back "/" 1)
	(call-interactively 'helm-find-files-up-one-level)
      (delete-backward-char 1)))
  (bind-key "<backspace>" #'my-dwim-helm-find-files-up-one-level-maybe helm-read-file-map)
  (bind-key "<backspace>" #'my-dwim-helm-find-files-up-one-level-maybe helm-find-files-map)
  (bind-key "DEL" #'my-dwim-helm-find-files-up-one-level-maybe helm-read-file-map)
  (bind-key "DEL" #'my-dwim-helm-find-files-up-one-level-maybe helm-find-files-map)

  ;; If on a directory, switch helm to this directory. Don't call it with dired.
  ;; from https://github.com/hatschipuh/better-helm
  (defun my-dwim-helm-find-files-navigate-forward (orig-fun &rest args)
  "Adjust how helm-execute-persistent actions behaves, depending on context"
  (if (file-directory-p (helm-get-selection))
      (apply orig-fun args)
    (helm-maybe-exit-minibuffer)))
  (advice-add 'helm-execute-persistent-action :around #'my-dwim-helm-find-files-navigate-forward)
  (bind-key "<return>" 'helm-maybe-exit-minibuffer helm-map)
  (bind-key "RET" 'helm-maybe-exit-minibuffer helm-map)
  (bind-key "<return>" 'helm-execute-persistent-action helm-find-files-map)
  (bind-key "<return>" 'helm-execute-persistent-action helm-read-file-map)
  (bind-key "RET" 'helm-execute-persistent-action helm-find-files-map)
  (bind-key "RET" 'helm-execute-persistent-action helm-read-file-map)
)
(use-package helm-imenu
  :defer t
  :config
  (setq helm-imenu-delimiter " ")
)
(use-package helm-semantic
  :commands (my-semantic-or-helm-imenu)
  :bind (("M-s i"   . my-helm-semantic-or-imenu)
	 ("M-s m"   . my-helm-semantic-or-imenu))
  :config
  (defun my-helm-semantic-or-imenu ()
    "This is just like helm-semantic-or-imenu, but it will
maximize the buffer"
    (interactive)
    (let ((helm-full-frame t))
      (helm-semantic-or-imenu nil)))
)
(use-package helm-source
  :defer t
  :commands (helm-make-source)
)
(use-package helm-net
  :defer t
  :config
  (when (executable-find "curl")
    (setq helm-net-prefer-curl t))
  (setq helm-browse-url-chromium-program "x-www-browser")
  (setq helm-google-suggest-default-browser-function 'helm-browse-url-chromium)
  (setq helm-home-url "http://www.google.de")
  (setq helm-autoresize-mode t)
)
#+END_SRC

*** helm-descbinds

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :commands helm-descbinds
  :bind (("C-h b" . helm-descbinds)
	 ("C-h w" . helm-descbinds)) ;; used to be where-is
  )
#+END_SRC

*** helm-swoop
https://github.com/ShingoFukuyama/helm-swoop

#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :commands (helm-swoop helm-swoop-back-to-last-point)
  :bind (("M-s s"  . helm-swoop)
	 ("M-s M-s" . helm-swoop)
	 ("M-s S"   . helm-swoop-back-to-last-point))
  :config
  (setq helm-swoop-split-direction 'split-window-sensibly)
  ;; Switch to edit mode with C-c C-e, and exit edit mode with C-c C-c
  (bind-key "C-c C-c" 'helm-swoop--edit-complete helm-swoop-edit-map)
  ;; When doing isearch, hand the word over to helm-swoop
  (bind-key "M-s s"   'helm-swoop-from-isearch isearch-mode-map)
  (bind-key "M-s M-s" 'helm-swoop-from-isearch isearch-mode-map)
  ;; Move up and down like isearch
  (bind-key "C-r" 'helm-previous-line helm-swoop-map)
  (bind-key "C-s" 'helm-next-line     helm-swoop-map)
  (bind-key "C-r" 'helm-previous-line helm-multi-swoop-map)
  (bind-key "C-s" 'helm-next-line     helm-multi-swoop-map)
  ;; always pop at bottom
  ;; from https://github.com/hatschipuh/better-helm
  (setq helm-swoop-split-with-multiple-windows nil
        helm-swoop-split-direction 'split-window-vertically
        helm-swoop-split-window-function 'helm-default-display-buffer)
)
#+END_SRC

** hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :defer t
  :ensure t
  :commands (defhydra
	      hydra-default-pre
	      hydra-keyboard-quit
	      hydra-set-transient-map)
  )
(use-package lv
  :defer t
  :commands (lv-message))
#+END_SRC
* Mail & News

** smtpmail
http://emacs.stackexchange.com/questions/6105/how-to-set-proper-smtp-gmail-settings-in-emacs-in-order-to-be-able-to-work-with
http://superuser.com/questions/476714/how-to-configure-emacs-smtp-for-using-a-secure-server-gmail

#+BEGIN_SRC emacs-lisp
(use-package smtpmail
  :defer t
  :config
  (setq smtpmail-default-smtp-server "smtp.gmail.com"
	smtpmail-smtp-server "smtp.gmail.com"
	smtpmail-stream-type 'starttls
	smtpmail-smtp-service 587
	smtpmail-debug-info t))
#+END_SRC
** sendmail
http://www.emacswiki.org/emacs/MuttInEmacs
http://dev.mutt.org/trac/wiki/MuttFaq/Editor

#+BEGIN_SRC emacs-lisp
(use-package sendmail
  :defer t
  :commands (mail-mode mail-text)
  :defines (send-mail-function)
  :mode (("/tmp/mutt-*" . mail-mode))
  :config
  (defun my-mail-quit ()
    (interactive)
    (not-modified)
    (server-edit))
  (defun my-mail-save ()
    (interactive)
    (save-buffer)
    (server-edit))
  (defun my-mail-mode-hook ()
    (flush-lines "^\\(> \n\\)*> -- \n\\(\n?> .*\\)*") ; kill quoted sigs
    ;; (visual-line-mode t)
    (auto-fill-mode)
    (delete-trailing-whitespace)
    (mail-text)
    (fill-region (point) (point-max))
    (not-modified)
    (setq make-backup-files nil))

  ;; Sending mail
  (setq send-mail-function 'smtpmail-send-it)

  (add-hook 'mail-mode-hook 'my-mail-mode-hook)
  (bind-key "C-c C-c" 'my-mail-done mail-mode-map)
  (bind-key "C-x k" 'my-mail-quit mail-mode-map)
  )
#+END_SRC

** message

#+BEGIN_SRC emacs-lisp
(use-package message
  :defer t
  :config
  ;; When composing a mail, start the auto-fill-mode.
  (add-hook 'message-mode-hook 'turn-on-auto-fill)
  ;; (add-hook 'message-setup-hook 'bbdb-define-all-aliases)

  ;; Generate the mail headers before you edit your message.
  (setq message-generate-headers-first t)

  ;; The message buffer will be killed after sending a message.
  (setq message-kill-buffer-on-exit t)

  ;;(require 'starttls)
  ;;(require 'smtpmail)
  :commands message-mode
  ;;:mode (("/mutt" . message-mode))
)
#+END_SRC

** gnus
https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org
http://www.emacswiki.org/emacs/GnusGmail
http://www.xsteve.at/prg/gnus/
https://github.com/jwiegley/dot-emacs/blob/master/dot-gnus.el

#+BEGIN_SRC emacs-lisp
(use-package gnus
  :bind ("C-c n" . gnus)
  :config
  (require 'mm-decode)
#+END_SRC

*** general setup

#+BEGIN_SRC emacs-lisp
  ;; Store gnus specific files to ~/gnus, maybe also set nnml-directory
  (setq gnus-directory (concat user-emacs-directory "News/")
  	message-directory (concat user-emacs-directory "Mail/")
  	gnus-article-save-directory (concat user-emacs-directory "News/saved/")
  	gnus-kill-files-directory (concat user-emacs-directory "News/scores/")
  	gnus-cache-directory (concat user-emacs-directory "News/cache/"))

  (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)

#+END_SRC

*** News sources

#+BEGIN_SRC emacs-lisp
  ;;http://www.xsteve.at/prg/gnus/
  (setq gnus-select-method '(nntp "news.gmane.org"))

  ;; Local offlineimap repository
  (add-to-list 'gnus-secondary-select-methods
	       '(nnmaildir "" (directory "~/Maildir/")))

#+END_SRC

*** Summary list

#+BEGIN_SRC emacs-lisp
  ;; don't refrain to show a big amount of messages
  (setq gnus-large-newsgroup 10000)
  (setq gnus-summary-line-format "%U%R %11,11&user-date; %-22,22n %B%-80,80S\n")

  ;; Added some keybindings to the gnus summary mode
  (define-key gnus-summary-mode-map [(meta up)] '(lambda() (interactive) (scroll-other-window -1)))
  (define-key gnus-summary-mode-map [(meta down)] '(lambda() (interactive) (scroll-other-window 1)))
  (define-key gnus-summary-mode-map [(control down)] 'gnus-summary-next-thread)
  (define-key gnus-summary-mode-map [(control up)] 'gnus-summary-prev-thread)

  ;; stop the annoying "move to colon" function
  (defun gnus-summary-position-point ()
    )
#+END_SRC

*** GNUS articles

#+BEGIN_SRC emacs-lisp
  ;; And this switches the cursor into this other window when we select an article
  (defun my--after-select-article (&rest args)
    (let ((window (get-buffer-window (get-buffer "*Article*"))))
      (when window
	(select-window window))))
  (advice-add 'gnus-summary-select-article :after 'my--after-select-article)

  (defun my--delete-window ()
	(interactive)
	(if (one-window-p)
		(bury-buffer)
	  (delete-window)))
  (bind-key "q"      'my--delete-window   gnus-article-mode-map)
  (bind-key "<home>" 'beginning-of-buffer gnus-article-mode-map)
  (bind-key "<end>"  'end-of-buffer       gnus-article-mode-map)
)
#+END_SRC

*** autostarts
#+BEGIN_SRC emacs-lisp
(use-package gnus-start
  :defer t
  :config
  ;; Unconditionally read the dribble file
  (setq gnus-always-read-dribble-file t)
)
(use-package gnus-sum
  :defer t
  :config
  ;; re-use one article buffer for every group
  (setq gnus-single-article-buffer t)

  ;; don't substitute my e-mail with some "-> RECEIVER" magic
  (setq gnus-ignored-from-addresses nil)

  ;; make threads full
  (setq gnus-fetch-old-headers t)

  ;; If you prefer to see only the top level message. If a message has
  ;; several replies or is part of a thread, only show the first
  ;; message. 'gnus-thread-ignore-subject' will ignore the subject and
  ;; look at 'In-Reply-To:' and 'References:' headers.
  ;; (setq gnus-thread-hide-subtree t)

  ;; Sort by date:
  (setq gnus-thread-sort-functions
  		'((not gnus-thread-sort-by-date)
  		  (not gnus-thread-sort-by-number)))


  ;;  %U  "Read" status of this article.
  ;;  %R  "A" if this article has been replied to, " "
  ;;  %d  Date of the article (string) in DD-MMM format
  ;;  %L  Number of lines in the article (integer)
  ;;  %n  Name of poster
  ;;  %B  A complex trn-style thread tree (string), see gnus-sum-thread-*
  ;;  %S  Subject (string)
  ;; Some others:
  ;;  %z  Article zcore (character), try %i
  ;;  %I  Indentation based on thread level
  ;;  %f  Contents of the From: or To: headers (string)
  ;;  %s  Subject if it is at the root of a thread, and "" otherwise
  ;;  %O  Download mark (character).
  ;; Original                    "%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n"
  (setq gnus-user-date-format-alist '(
				      ((gnus-seconds-today)           . "%H:%M")
				      ((+ 86400 (gnus-seconds-today)) . "gest %H:%M")
				      ((gnus-seconds-year)            . "%d.%m %H:%M")
				      (t                              . "%d.%m. %Y")
				      ))
)
#+END_SRC

*** gnus-art

#+BEGIN_SRC emacs-lisp
(use-package gnus-art
  :defer t
  :commands (gnus-article-reply-with-original
	     gnus-article-wide-reply-with-original
	     gnus-mime-save-part)
)
#+END_SRC

*** gnus-group

#+BEGIN_SRC emacs-lisp
(use-package gnus-group
  :defer t
  :commands (gnus-group-catchup-current
	     gnus-group-enter-server-mode
	     gnus-group-get-new-news
	     gnus-group-list-active
	     gnus-group-list-all-groups
	     gnus-group-make-nnir-group
	     gnus-group-new-mail
	     hydra-gnus-group/body
	     )
  :config
  (defhydra hydra-gnus-group (:color pink :hint nil)
    "
^Local^                        | ^Server^
-----------------------------+-------------------------------------
_l_  list all groups           | _L_  list active groups on IMAP server
_c_  catch up all (mark read)  | _s_  search on server
_g_  get new news              | _S_  enter server mode
-----------------------------+-------------------------------------
_m_  mail new post
"
       ("l" gnus-group-list-all-groups)
       ("c" gnus-group-catchup-current)
       ("g" gnus-group-get-new-news)

       ("L" gnus-group-list-active :exit t)
       ("s" gnus-group-make-nnir-group :exit t)
       ("S" gnus-group-enter-server-mode :exit t)

       ("m" gnus-group-new-mail :exit t)
       ("q" nil "quit" :color blue)
       ;; ("r" gnus-group-list-active "REMOTE groups A A")
       ;; ("l" gnus-group-list-all-groups "LOCAL groups L")
       ;; ("c" gnus-topic-catchup-articles "Read all c")
       ;; ("G" gnus-group-make-nnir-group "Search server G G")
       ;; ("g" gnus-group-get-new-news "Refresh g")
       ;; ("s" gnus-group-enter-server-mode "Servers")
       ;; ("m" gnus-group-new-mail "Compose m OR C-x m")
       ;; ("#" gnus-topic-mark-topic "mark #")
       ;; ("q" nil "cancel")
       )
     ;; y is not used by default
     (bind-key "y" #'hydra-gnus-group/body gnus-group-mode-map ))
#+END_SRC

** gnus-sum

#+BEGIN_SRC emacs-lisp
(use-package gnus-sum
  :defer t
  :commands (gnus-summary-catchup-and-exit
	     gnus-summary-clear-mark-forward
	     gnus-summary-exit
	     gnus-summary-exit-no-update
	     gnus-summary-goto-subject
	     gnus-summary-kill-thread
	     gnus-summary-last-subject
	     gnus-summary-mail-forward
	     gnus-summary-put-mark-as-read
	     gnus-summary-reply
	     gnus-summary-reply-with-original
	     gnus-summary-resend-message-edit
	     gnus-summary-save-article-body-file
	     gnus-summary-tick-article-forward
	     gnus-summary-wide-reply
	     gnus-summary-wide-reply-with-original
	     my--gnus-summary-exit-no-update
	     hydra-gnus-summary/body
	     )
  :config
  (defhydra hydra-gnus-summary (:color pink :hint nil)
    "
^Posting^                  ^Handling^
-----------------------+------------------
_f_  forward             | _!_  tick & keep
_e_  resend & edit       | _p_  untick
_R_  reply & quote       | _c_  catchup
_r_  reply personal      | _C_  catchup thread
_W_  wide reply & quote  | _u_  unmark
_w_  wide reply          |

_p_  save as patch
"
    ;; ("n" gnus-summary-insert-new-articles "Refresh / N")
    ("f" gnus-summary-mail-forward :exit t)
    ("e" gnus-summary-resend-message-edit :exit t)
    ("R" gnus-summary-reply-with-original :exit t)
    ("r" gnus-summary-reply :exit t)
    ("W" gnus-summary-wide-reply-with-original :exit t)
    ("w" gnus-summary-wide-reply :exit t)

    ("!" gnus-summary-tick-article-forward)
    ("p" gnus-summary-put-mark-as-read)
    ("c" gnus-summary-catchup-and-exit)
    ("C" gnus-summary-kill-thread)
    ("u" gnus-summary-clear-mark-forward)

    ("p" gnus-summary-save-article-body-file)

    ("q" nil "quit"))
  ;; y is not used by default
  (bind-key "y" #'hydra-gnus-summary/body gnus-summary-mode-map)

  ;; (almost) swap "q" and "Q"
  (defun my--gnus-summary-exit-no-update ()
    "This is identical to gnus-summary-exit-no-update, but it doesn't ask
for yes-or-no."
    (interactive)
    (gnus-summary-exit-no-update t))
  (bind-key "q" #'my--gnus-summary-exit-no-update gnus-summary-mode-map)
  (bind-key "Q" #'gnus-summary-exit gnus-summary-mode-map)
  )
#+END_SRC

** gnus-art

#+BEGIN_SRC emacs-lisp
(use-package gnus-art
  :defer t
  :commands (gnus-article-wide-reply
	     gnus-article-reply
	     hydra-gnus-article/body)
  :config

  ;; Test code, position cursor inside and run C-C-x to evaluate:
  ;;
  ;; (let ((filename "[PATCH 03/05] foo"))
  ;;   (when (string-match "\\[PATCH.+?0*\\([0-9]+\\)/[0-9]+\\]" filename)
  ;;     (message "%s -> %04d" filename (string-to-number (match-string 1 filename)))
  ;;     ;; (message "%s" filename)
  ;;     )
  ;;   ))

  ;; save news article body as patch, via gnus-summary-save-article-body-file "O b"
  (defun gnus-read-save-file-name (prompt &optional filename
					  function group headers variable
					  dir-var)
    (let ((patchnum))
      (setq filename (gnus-summary-article-subject))
      (when (string-match "\\[PATCH.+?0*\\([0-9]+\\)/[0-9]+\\]" filename)
    	(setq patchnum (string-to-number (match-string 1 filename)))
    	(message "%s" patchnum))
      ;; (when string-match "\\[PATCH.+?\\]" filename)
	  (message "FILENAME %s" filename)
      (setq filename (replace-regexp-in-string "\\[PATCH.*\\]" "" filename))
      (setq filename (replace-regexp-in-string "\[^a-zA-Z0-9]" "-" filename))
      (setq filename (replace-regexp-in-string "\\-+" "-" filename))
      (setq filename (replace-regexp-in-string "^-" "" filename))
      (setq filename (replace-regexp-in-string "-$" "" filename))
      (when patchnum
		(setq filename (concat (format "%04d" patchnum) "-" filename)))
      (setq filename (concat "/tmp/" filename ".patch"))
      (when (file-exists-p filename)
		(delete-file filename))
	  filename))

    (defhydra hydra-gnus-article (:color pink :hint nil)
    "
^Posting^                  ^Handling^
-----------------------+---------------------------
_f_  forward             | _!_  tick & keep
_R_  reply & quote       | _p_  untick
_r_  reply personal      | _c_  catchup
_W_  wide reply & quote  | _C_  catchup thread
_w_  wide reply          | _u_  unmark
                       | _o_  save attachment at point
_p_  save as patch
"
    ;; ("n" gnus-summary-insert-new-articles "Refresh / N")
    ("f" gnus-summary-mail-forward :exit t)
    ("R" gnus-article-reply-with-original :exit t)
    ("r" gnus-article-reply :exit t)
    ("W" gnus-article-wide-reply-with-original :exit t)
    ("w" gnus-article-wide-reply :exit t)

    ("!" gnus-summary-tick-article-forward)
    ("p" gnus-summary-put-mark-as-read)
    ("c" gnus-summary-catchup-and-exit)
    ("C" gnus-summary-kill-thread)
    ("u" gnus-summary-clear-mark-forward)
    ("o" gnus-mime-save-part)

    ("p" gnus-summary-save-article-body-file)

    ("q" nil "quit"))
  ;; y is not used by default
  (bind-key "y" #'hydra-gnus-article/body gnus-article-mode-map)
  )
#+END_SRC

** mm-decode
#+BEGIN_SRC emacs-lisp
(use-package mm-decode
  :defer t
  :config
  ;; Hide HTML mail
  (setq mm-discouraged-alternatives '("text/html" "text/richtext")
  	mm-automatic-display (-difference mm-automatic-display '("text/html" "text/enriched" "text/richtext"))
	)
  )
#+END_SRC

** CANCELED bbdb

#+BEGIN_SRC emacs-lisp
(use-package bbdb
  :ensure t
  :defer t
  :commands (bbdb bbdb-insinuate-gnus bbdb-insinuate-message)
  :bind ("C-c b" . bbdb)
  :config
  (bbdb-initialize 'gnus 'message)

  (setq bbdb-file (concat user-emacs-directory "db.bbdb"))
  (setq bbdb-update-records-p 'create)
  ;; (setq bbdb-mua-pop-up nil)
  (setq bbdb-silent t)
  (setq bbdb-user-mail-address-re "\\<holgerschurig@gmail.com\\>")
  (setq bbdb-add-name t)
  (setq bbdb-add-aka t)
  (setq bbdb-add-mails t)
  (setq bbdb-new-mails-primary t)
  (setq bbdb-complete-mail-allow-cycling t)
  (setq bbdd-phone-style nil)
  (setq bbdb-ignore-message-alist
		'(("From" . "mailer-daemon")
		  ("From" . "bugs.launchpad.net")
		  ("From" . "postmaster.twitter.com")
		  ("From" . "plus.google.com")
		  ("From" . "notify@twitter.com")
		  (("To" "From") . "review@openstack.org")))
  ;; (setq bbdb-allow-duplicates t)
)
#+END_SRC

** org

*** org itself

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (("C-c l" . org-store-link)
	 ("C-c o" . org-open-at-point-global)
	 ("C-M-x" . eval-defun))
  :commands (org-open-file orgstruct++-mode)
  :init
  ;; allow Shift-Cursor to mark stuff
  (setq org-replace-disputed-keys t)

  ;; modules to load together with org-mode
  (setq org-modules '(
                      ;; org-annotate-file
                      ;; org-bbdb
                      ;; org-bibtex
                      ;; org-collector
                      ;; org-docview
                      ;; org-drill
                      ;; org-eval
                      ;; org-expiry
                      ;; org-gnus
                      ;; org-habit
                      ;; org-info
                      ;; org-interactive-query
                      ;; org-irc
                      ;; org-jsinfo
                      ;; org-man
                      ;; org-mhe
                      ;; org-mouse
                      ;; org-panel
                      ;; org-protocol
                      ;; org-rmail
                      ;; org-screen
                      ;; org-toc
                      ;; org-w3m
                      ))

  :config
  ;; My main file
  (setq org-default-notes-file (expand-file-name "todo.org" user-emacs-directory))

  ;; Handle deletion inside elipsis
  (setq org-catch-invisible-edits 'error)

  ;; don't fold for now
  (setq org-startup-folded 'content)

  ;; Time stamp format
  (setq org-display-custom-times t)
  (setq org-time-stamp-formats '("<%Y-%m-%d>" . "<%Y-%m-%d %H:%M>"))
  (setq org-time-stamp-custom-formats '("<%Y-%m-%d>"))

  ;; :bind cannot bind into a different map
  (bind-key "C-TAB"   'org-cycle org-mode-map)
  (bind-key "C-c C-j" 'helm-org-in-buffer-headings org-mode-map) ;; was org-goto
  (bind-key "C-c k"   'org-cut-subtree org-mode-map)
  (bind-key "C-c R"   'org-reveal org-mode-map)
  ;; (bind-key "C-c t"   'org-show-todo-tree org-mode-map)

  ;; adjust level
  (setq org-yank-adjusted-subtrees t)

  (add-hook 'org-mode-hook #'visual-line-mode)
  (add-hook 'org-mode-hook #'toggle-word-wrap)

  ;; make enter open the link
  (setq org-return-follows-link t)

  ;; some speed commands, use ? at the start of an org-header to see which one we have
  (add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
  (add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
  (add-to-list 'org-speed-commands-user '("!" my/org-clock-in-and-track))
  (add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
  (add-to-list 'org-speed-commands-user '("i" call-interactively 'org-clock-in))
  (add-to-list 'org-speed-commands-user '("o" call-interactively 'org-clock-out))
  (add-to-list 'org-speed-commands-user '("$" call-interactively 'org-archive-subtree))
  (add-to-list 'org-speed-commands-user '("N" org-narrow-to-subtree))
  (add-to-list 'org-speed-commands-user '("W" widen))
  (add-to-list 'org-speed-commands-user '("k" org-cut-subtree))
  ;; (add-to-list 'org-speed-commands-user '("P" call-interactively 'org2blog/wp-post-subtree))

  ;; "!"    record time stamp
  ;; "@"    add note with time
  ;; "x/y"  use x when entering state, y when leaving state
  ;; the first letter can be used with C-c C-t
  (setq org-todo-keywords
	;; '((sequence "TODO(t)" "STARTED(s!)" "|" "DONE(x!)")
	;;   (sequence "WAIT(w@/!)" "DELEGATED(d@/!)" "|" "CANCELED(c@)")
	'((sequence "TODO(t)" "STARTED(s)" "|" "DONE(x)")
	  (sequence "WAIT(w)" "DELEGATED(d)" "|" "CANCELED(c)")
	  ))

  (setq org-todo-keyword-faces
      '(("TODO"      . (:foreground "red" :weight bold))
        ("STARTED"   . (:foreground "#b70101" :weight bold))
        ("DONE"      . (:foreground "forestgreen" :weight bold))
        ("WAIT"      . (:foreground "orange" :weight bold))
        ("DELEGATED" . (:foreground "forestgreen" :weight bold))
        ("CANCELED"  . shadow)))

  ;; use extra drawer
  (setq org-log-into-drawer t)

  ;; when my day ends
  (setq org-use-effective-time t
	org-extend-today-until 17)

  ;; Resume clocking tasks when emacs is restarted
  ;; (org-clock-persistence-insinuate)

  ;; TODO creates error
  ;; (setq org-global-properties
  ;; 	'("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 8:00"))

  ;; Try column with this:
  ;; (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")

  ;; misc refile settings
  (setq org-reverse-note-order t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))

  ;; (setq org-blank-before-new-entry nil)

  ;; export and open
  (defun my-org-export-to-html-and-open ()
    (interactive)
    (org-open-file (org-html-export-to-html)))
  (bind-key "<M-f7>" 'my-org-export-to-html-and-open org-mode-map)

  ;; make "<l" to insert an emacs-lisp source block
  ;; and use "<x" for the old latex export
  (setq org-structure-template-alist
	'(("s" "#+BEGIN_SRC ?\n\n#+END_SRC")
	  ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE")
	  ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE")
	  ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE")
	  ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM")
	  ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER")
	  ("l" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
	  ;; ("l" "#+BEGIN_EXPORT latex\n?\n#+END_EXPORT")
	  ("x" "#+BEGIN_EXPORT latex\n?\n#+END_EXPORT")
	  ("L" "#+LaTeX: ")
	  ("h" "#+BEGIN_EXPORT html\n?\n#+END_EXPORT")
	  ("H" "#+HTML: ")
	  ("a" "#+BEGIN_EXPORT ascii\n?\n#+END_EXPORT")
	  ("A" "#+ASCII: ")
	  ("i" "#+INDEX: ?")
	  ("I" "#+INCLUDE: %file ?")
	  ))
)
#+END_SRC

*** org-agenda
http://www.suenkler.info/docs/emacs-orgmode/

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :bind (("C-c a" . org-agenda)
	 ("C-c w" . org-agenda-list)  ;; w like week
	 )
  :config
  (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map)
  ;; (bind-key "!" 'my/org-clock-in-and-track org-agenda-mode-map)

  ;; Highlight current line
  (add-hook 'org-agenda-mode-hook (defun my-org-agenda-hookfunc () (hl-line-mode 1 )))

  ;; which files the agenda should consider
  (setq org-agenda-files (list org-default-notes-file))

  ;; Let date stand out
  (setq org-agenda-format-date
	"%Y-%m-%d ---------------------------------------------------------------------")

  (setq org-agenda-show-outline-path t)

  ;; colorize priorities
  (setq org-agenda-fontify-priorities
	'((65 (:foreground "Red"))
	  (66 (:foreground "Blue"))
	  (67 (:foreground "Darkgreen"))))

  ;; hide done tasks
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)

  ;; normally hide the "someday" (nice-to-have) things
  (setq org-agenda-filter-preset '("-someday"))

  ;; show day schedule, not week schedule
  (setq org-agenda-span 'day)

  ;; own views
  (setq org-agenda-custom-commands
	'(("n" "Agenda and all TODO's"
	   ((agenda "")
	    (alltodo "")))
  	  ;; ("f" "Agenda and flagged tasks"
  	  ;;  ((tags "flagged")
  	  ;;   (agenda "")))
	  ("s" "Tagged 'someday'" tags "someday" ((org-agenda-filter-preset '("+someday"))
						  (org-agenda-todo-ignore-with-date nil)))
	  ))

  ;; show clock report
  ;; (setq org-agenda-start-with-clockreport-mode nil)

  ;; Keine Links, maximal bis Level 4 herunter:
  ;; (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 4))
  )
#+END_SRC

*** org-capture

#+BEGIN_SRC emacs-lisp
(use-package org-capture
  :bind ("C-c r" . my-org-capture-todo)
  ;; ("<f9> <f8>" . (lambda () (interactive) (org-capture nil "r")))
  :config
  (defun my-org-capture-todo ()
    (interactive)
    (org-capture nil "o"))
  (setq org-capture-templates
	`(("o" "Open task" entry
	   (file+headline org-default-notes-file "Unsortiert")
	   "* TODO %?\n\n")
	  ("n" "Note" item
	   (file+headline org-default-notes-file "Infos"))
	   ))
  )
#+END_SRC

*** org-clock

#+BEGIN_SRC emacs-lisp
(use-package org-clock
  :bind ("C-c j" . org-clock-goto) ;; jump to current task from anywhere
  :config
  (setq org-clock-into-drawer "CLOCK")

  ;; Yes it's long... but more is better ;)
  (setq org-clock-history-length 35)

  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)

  ;; Change task state to STARTED when clocking in
  (setq org-clock-in-switch-to-state "STARTED")

  ;; this removes clocked tasks with 0:00 duration
  ;; (setq org-clock-out-remove-zero-time-clocks t)

  ;; Don't clock out when moving task to a done state
  ;; (setq org-clock-out-when-done nil)

  ;; Save the running clock and all clock history when exiting Emacs,
  ;; load it on startup
  ;; (setq org-clock-persist t)

  ;; Disable auto clock resolution
  (setq org-clock-auto-clock-resolution nil)
  )
#+END_SRC

*** org-list

#+BEGIN_SRC emacs-lisp
(use-package org-list
  :defer t
  :functions (org-item-re)
  :config
  ;; tab changes visibility of lists like headers
  (setq org-cycle-include-plain-lists 'integrate)

  ;; speed commands are fun, not only on the headers, but also on lists
  (defun my/org-use-speed-commands-for-headings-and-lists ()
    "Activate speed commands on list items too."
    (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
	(save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))
  (setq org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)
)
#+END_SRC

*** org-src

#+BEGIN_SRC emacs-lisp
(use-package org-src
  :defer t
  :config
  ;; Open source editor in current window
  (setq org-src-window-setup 'current-window)
  ;; inside src block use the colors like the major mode of the src type
  (setq org-src-fontify-natively t)
  ;; inside a src block let tab act like it was in major mode of the src type
  (setq org-src-tab-acts-natively t)
  ;; don't add two indentation spaces into src blocks
  (setq org-src-preserve-indentation t)

  ;; normally I'd need C-c ' to exit, but this enables the same exit
  ;; method I have in when doing a commit in magit.
  (bind-key "C-c C-c" 'org-edit-src-exit org-src-mode-map)
)
#+END_SRC

*** ox

#+BEGIN_SRC emacs-lisp
(use-package ox
  :defer t
  :config
  ;; The following make some +OPTIONS permanent:
  ;; #+OPTIONS ':t
  (setq org-export-with-smart-quotes t)
  ;; #+OPTIONS num:nil
  (setq org-export-with-section-numbers nil)
  ;; #+OPTIONS stat:t
  ;; (setq org-export-with-statistics-cookies nil)
  ;; #+OPTIONS toc:nil, use "#+TOC: headlines 2" or similar if you need a headline
  (setq org-export-with-toc nil)
  ;; #+OPTIONS ^:{}
  (setq org-export-with-sub-superscripts nil))
#+END_SRC

*** ox-html
#+BEGIN_SRC emacs-lisp
(use-package ox-html
  :defer t
  :commands org-html-export-to-html
  :config
  (setq org-html-postamble-format '(("en" "<p class=\"author\">Author: %a</p><p class=\"creator\">Created with %c</p>")))
  (setq org-html-validation-link nil)
  (setq org-html-postamble nil)
  (setq org-html-style-default "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/\n  body { text-align: center; font-family: \"Aria\", sans-serif; }\n  #content { margin: 0 auto; width: 860px; text-align: left; }\n  #text-table-of-contents > ul > li { margin-top: 1em; }\n  .title  { text-align: center; }\n  .todo   { font-family: monospace; color: red; }\n  .done   { color: green; }\n  .tag    { background-color: #eee; font-family: monospace;\n            padding: 2px; font-size: 80%; font-weight: normal; }\n  .timestamp { color: #bebebe; }\n  .timestamp-kwd { color: #5f9ea0; }\n  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }\n  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }\n  .center { margin-left: auto; margin-right: auto; text-align: center; }\n  .underline { text-decoration: underline; }\n  #postamble p, #preamble p { font-size: 90%; margin: .2em; }\n  p.verse { margin-left: 3%; }\n  pre {\n    border: 1px solid #ccc;\n    box-shadow: 3px 3px 3px #eee;\n    padding: 8pt;\n    font-family: monospace;\n    overflow: auto;\n    margin: 1em 0;\n  }\n  pre.src {\n    position: relative;\n    overflow: visible;\n    padding-top: 8pt;\n  }\n  pre.src:before {\n    display: none;\n    position: absolute;\n    background-color: white;\n    top: -10px;\n    right: 10px;\n    padding: 3px;\n    border: 1px solid black;\n  }\n  pre.src:hover:before { display: inline;}\n  pre.src-sh:before    { content: 'sh'; }\n  pre.src-bash:before  { content: 'sh'; }\n  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }\n  pre.src-R:before     { content: 'R'; }\n  pre.src-perl:before  { content: 'Perl'; }\n  pre.src-java:before  { content: 'Java'; }\n  pre.src-sql:before   { content: 'SQL'; }\n\n  table { border-collapse:collapse; }\n  caption.t-above { caption-side: top; }\n  caption.t-bottom { caption-side: bottom; }\n  td, th { vertical-align:top;  }\n  th.right  { text-align: center;  }\n  th.left   { text-align: center;   }\n  th.center { text-align: center; }\n  td.right  { text-align: right;  }\n  td.left   { text-align: left;   }\n  td.center { text-align: center; }\n  dt { font-weight: bold; }\n  .footpara:nth-child(2) { display: inline; }\n  .footpara { display: block; }\n  .footdef  { margin-bottom: 1em; }\n  .figure { padding: 1em; }\n  .figure p { text-align: center; }\n  .inlinetask {\n    padding: 10px;\n    border: 2px solid gray;\n    margin: 10px;\n    background: #ffffcc;\n  }\n  #org-div-home-and-up\n   { text-align: right; font-size: 70%; white-space: nowrap; }\n  textarea { overflow-x: auto; }\n  .linenr { font-size: smaller }\n  .code-highlighted { background-color: #ffff00; }\n  .org-info-js_info-navigation { border-style: none; }\n  #org-info-js_console-label\n    { font-size: 10px; font-weight: bold; white-space: nowrap; }\n  .org-info-js_search-highlight\n    { background-color: #ffff00; color: #000000; font-weight: bold; }\n  .ulClassNameOrID > li {}\n  /*]]>*/-->\n</style>")
  (setq org-html-table-default-attributes '(:border "2" :cellspacing "0" :cellpadding "6"))
  (setq org-html-postamble t))
#+END_SRC

*** ox-publish
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
  :defer t
  :commands (org-twbs-publish-to-html)
)
(use-package ox-publish
  :defer t
  :if (string= "holger" system-name)
  :bind (("C-c p" . my-publish))
  :config
  (setq org-publish-project-alist
	'(("twbs"
	   :base-directory "~/org/"
	   :publishing-directory "~/org/twbs/"
	   :base-extension "org"
	   :recursive t
	   :publishing-function org-twbs-publish-to-html

	   ;; See http://orgmode.org/manual/Publishing-options.html#Publishing-options

	   ;; Don't emit  "Created: 2016-02-12 Fri 09:28 Emacs 24.5.1 (Org mode 8.3.3)"
	   :html-postamble nil

	   ;; This is the Table of Contents on the right side, you can turn it off
	   ;; per page with "#+OPTIONS: toc:nil"
	   :with-toc t

	   :html-use-infojs nil
	   :html-validation-link ""
	   :html-home/up-format ""
	   :html-link-up ""
	   :html-link-home ""
	   ;; :html-checkbox-type 'html   ;; use CSS to format them
	   :html-metadata-timestamp-format "%Y-%m-%d %H:%M"

	   ;; General export settings
	   :archived-trees nil
	   :headline-levels 3
	   :section-numbers nil
	   :with-author nil ;; Only one author ever
	   :with-date nil
	   :with-latex nil
	   :with-sub-superscript nil
	   )

	  ("html"
	   :base-directory "~/org/"
	   :publishing-directory "~/org/html/"
	   :base-extension "org"
	   :recursive t
	   :publishing-function org-html-publish-to-html

	   ;; see (org-html--build-head info)
	   :html-head-include-default-style nil ;; org-html-head-include-default-style
	   ;; :html-head                   ;; org-html-head
	   ;; :html-head "<link rel=\"stylesheet\" href=\"../other/mystyle.css\" type=\"text/css\"/>"
	   ;; :html-head-extra             ;; org-html-head-extra
	   ;; :html-htmlized-css-url       ;; org-html-htmlized-css-url
	   :html-head-include-scripts nil       ;; org-html-head-include-scripts

	   ;; Don't emit  "Created: 2016-02-12 Fri 09:28 Emacs 24.5.1 (Org mode 8.3.3)"
	   :html-postamble nil

	   :with-toc nil

	   :html-use-infojs nil
	   :html-validation-link ""
	   :html-home/up-format ""
	   :html-link-up ""
	   :html-link-home ""
	   ;; :html-checkbox-type 'html   ;; use CSS to format them
	   :html-metadata-timestamp-format "%Y-%m-%d %H:%M"

	   ;; General export settings
	   :archived-trees nil
	   :headline-levels 3
	   :section-numbers nil
	   :with-author nil ;; Only one author ever
	   :with-date nil
	   :with-latex nil
	   :with-sub-superscript nil
	   )

	  ("static"
	   :base-directory "~/org/"
	   :base-extension "jpg\\|gif\\|png\\|css\\|js"
	   :recursive t
	   :publishing-directory "~/org/out/"
	   :publishing-function org-publish-attachment)

	  ("site" :components ("twbs" "html"))))
  (defun my-publish ()
    (interactive)
    (org-publish "site" t))
)
#+END_SRC
*** htmlize
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t
  :defer t
  :defines (htmlize-version)
)
#+END_SRC
** flyspell

#+BEGIN_SRC emacs-lisp
(use-package flyspell
 :diminish flyspell-mode
 :commands (flyspell-mode flyspell-prog-mode)
 :config
 (add-to-list 'flyspell-dictionaries-that-consider-dash-as-word-delimiter "german-new8")
 (setq flyspell-issue-welcome-flag nil)
 ;; M-Tab is owned by the window manager, correct with C-M-i
 (setq flyspell-use-meta-tab nil)
 ;; Flyspell hijacked C-., which I want to use for tags
 (define-key flyspell-mode-map [(control ?\.)] nil)
 )

#+END_SRC

Flyspell is in elisp mode. And this in turn loads flyspell directly
after launching emacs, which is a bit unfortunate.

#+BEGIN_SRC emacs-lisp
(defun my-flyspell-prog-mode ()
  (interactive)
  (unless (string= (buffer-name) "*scratch*")
    (flyspell-prog-mode)))
(add-hook 'prog-mode-hook  #'my-flyspell-prog-mode)
(add-hook 'text-mode-hook  #'flyspell-mode)
(add-hook 'org-mode-hook   #'flyspell-mode)
(add-hook 'latex-mode-hook #'flyspell-mode)
(add-hook 'LaTeX-mode-hook #'flyspell-mode)
#+END_SRC

*** helm-flyspell
https://github.com/pronobis/helm-flyspell

#+BEGIN_SRC emacs-lisp
(use-package helm-flyspell
  :commands helm-flyspell-correct
  :config
  (bind-key "C-;" 'helm-flyspell-correct flyspell-mode-map)
  )
#+END_SRC
* Programming
** Tabs and indentation
*** Tab width 4
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC
*** tabify only leading whitespace
#+BEGIN_SRC emacs-lisp
(use-package tabify
  :defer t
  :commands (tabify untabify)
  :config
  ;; only initial whitespace
  (setq tabify-regexp "^\t* [ \t]+"))
#+END_SRC

*** Deleting past a tab
Deleting past a tab normally changes tab into spaces. Don't do that,
kill the tab instead.

#+BEGIN_SRC emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+END_SRC
*** RET is newline-and-indent
And if we ever need it, =C-j= is now newline.

#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)
(bind-key "C-j" 'newline)
#+END_SRC
*** Clean wrong indentation
Nice tip from tuhdo, see https://www.emacswiki.org/emacs/CleanAutoIndent
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
  :config
  (add-hook 'prog-mode-hook #'clean-aindent-mode)
)
#+END_SRC
*** Guess indent mode
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
  :config
  (dtrt-indent-mode 1)
)
#+END_SRC
** Disable vc backends
We only use git, not other version controls:

#+BEGIN_SRC emacs-lisp
(setq vc-handled-backends nil)
#+END_SRC

** Commenting

#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" 'comment-dwim)
#+END_SRC

** Compilation
set initial compile-command to nothing, so that F7 will prompt for one

#+BEGIN_SRC emacs-lisp
(setq compile-command nil)


(defvar compile-commands nil
  "The compile commands are an alist where the key is
   is the command and the value is the time when it was
   executed the last time. The latter is used for sorting.

   Example:

   '((\"make\" .  \"1448748904\")
     (\"make -C ~/test\" . \"1448748866\"))")

;; automatically save our compile-commands
(add-to-list 'savehist-minibuffer-history-variables 'compile-commands)


(defun comp--sort-command-alist ()
  "Sorts compile-commands by the value of their cons elements.
   This sorts the entries so that recently used compile commands
   are near the top."

  (setq compile-commands (sort compile-commands (lambda (x y)
							(not (string< (cdr x) (cdr y)))))))

(defun comp--add-command (cmd)
  "Adds a command to compile-commands if it isn't already in it.

  It inserts the seconds since 1970 into the value."

  ;; (message "adding command '%s'" cmd)
  (unless (assoc cmd compile-commands)
    (add-to-list 'compile-commands (cons cmd (format-time-string "%s")))))


(defun comp--get-compile-commands-from-buffers ()
  "Searches all open buffers that have a file-name associated
   and adds compile commands from to compile-commands. Valid
   forms for compile commands in the source code are:

   // @command: make
   ## @command: make
   /* @command: make */
   (setq compile-command \"make\")"

  ;; (message "loading commands from buffers")
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (buffer-file-name)
	(save-excursion
	  (goto-char (point-min))
	  (while (re-search-forward "^.. @compile: \\(.*\\)$" nil t)
	    (let ((s (match-string-no-properties 1)))
	      ;; \s- whitespace character class
	      (setq s (replace-regexp-in-string "\s-*\\*/$" "" s))
	      (comp--add-command s)))
	  (goto-char (point-min))
	  (while (re-search-forward "(setq compile-command \"\\(.*\\)\")" nil t)
	    ;; (message "via setq '%s'" (match-string-no-properties 1))
	    (comp--add-command (match-string-no-properties 1))))))))


(defun comp--delete-command (candidate)
  "This deletes the selected compile-command from compile-commands."

  (assq-delete-all candidate compile-commands)
  (setq compile-commands (delq (assoc candidate compile-commands) compile-commands))
  ;; (message "deleted: %s" candidate)
  nil)


(defun comp--persistent-action (candidate)
  (with-selected-window (minibuffer-window)
	(delete-minibuffer-contents)
	(set-text-properties 0 (length candidate) nil candidate)
	(insert candidate)))

;; http://wikemacs.org/wiki/How_to_write_helm_extensions
(defun comp--helm-compile-command (arg)
  "Interactively select a compile-command.

   Releads possible commends from open buffers when run with argument."

  (interactive "P")
  (unless compile-commands
    (setq arg 1))
  (when arg
    (comp--get-compile-commands-from-buffers))
  (comp--sort-command-alist)
  ;; compile-commands is now something like:
  ;; '(("make -C foo" . 1) ("ccmake && make" . 2))
  ;; (message "commands: %s" compile-commands)
  (let* ((src (helm-build-sync-source "Select compile command"
		:candidates (mapcar 'car compile-commands)
		:action '(("Select" . identity)
			  ("Delete" . comp--delete-command))
		:mode-line "F1 select, F2 delete"
		:persistent-action 'comp--persistent-action
		;; :volatile nil
		))
	 (ent (helm-build-dummy-source "Or enter new compile command ..."
		:mode-line ""
		))
	 (cmd (helm :sources '(src ent)
		    :prompt "cmd: "
		    :buffer "*compile-command*"
		    )))
    (when cmd
      (message "command: %s" cmd)
      (comp--add-command cmd)
      (setq compile-command cmd)
      )))
(bind-key "S-<f7>" 'comp--helm-compile-command)


(defun comp--compile ()
  (interactive)
  (delete-other-windows)
  (save-buffer)
  (unless compile-command
    (comp--helm-compile-command nil))
  (when compile-command
    (message "compile command: %s" compile-command)
    (let ((cmd (assoc compile-command compile-commands)))
      (when cmd
	(message "assoc: %s" (assoc compile-command compile-commands))
	(setcdr cmd (format-time-string "%s"))
	(message "assoc: %s" (assoc compile-command compile-commands))
	)))
    (compile compile-command))
(bind-key "<f7>" 'comp--compile)
#+END_SRC

** CANCELED Auto close compile log if there are no errors
[[http://www.emacswiki.org/emacs/ModeCompile]]

#+BEGIN_SRC emacs-lisp
(defun compile-autoclose (buffer string)
  (cond ((string-match "finished" string)
	 ;; (message "Build maybe successful: closing window.")
	 (run-with-timer 1 nil
			 'delete-window
			 (get-buffer-window buffer t)))
	(t
	 (message "Compilation exited abnormally: %s" string))))
(use-package compile
    :diminish compilation-in-progress
    :config
    (setq compilation-finish-functions 'compile-autoclose)
    (setq compilation-ask-about-save nil)
    (setq compilation-scroll-output t))
#+END_SRC

*** Error navigation
#+BEGIN_SRC emacs-lisp
(bind-key "<f8>" 'next-error)
(bind-key "S-<f8>" 'previous-error)
#+END_SRC
** Make files with shebang executable
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Mode: C, C++
*** Open *.h files normally in c++ mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.h$" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-mode))
#+END_SRC
*** CANCELED c-syntactic-element?
#+BEGIN_SRC emacs-lisp
(defvar c-syntactic-element)
(eval-when-compile (require 'cc-mode))
#+END_SRC

*** CANCELED from linux/Documentation/CodingStyle, used in coding style "linux-tabs-only"

#+BEGIN_SRC emacs-lisp
(defun c-lineup-arglist-tabs-only (ignored)
  "Line up argument lists by tabs, not spaces"
  (let* ((anchor (c-langelem-pos c-syntactic-element))
         (column (c-langelem-2nd-pos c-syntactic-element))
         (offset (- (1+ column) anchor))
         (steps (floor offset c-basic-offset)))
    (* (max steps 1)
       c-basic-offset)))

(defun my-c-electric-brace-open (arg)
  "This just inserts the spaces, a newline, and indents into the
newline to the correct position"
  (interactive "*P")
  (self-insert-command (prefix-numeric-value arg))
  (newline-and-indent))
#+END_SRC

*** CANCELED c initialization
Somehow a the first visited file stays in "gnu" style when I set the c-default-style
just in the common hook

#+BEGIN_SRC emacs-lisp
(defun my-c-initialization-setup ()
  ;; Default style
  (c-add-style "linux-tabs-only"
	       '("linux" (c-offsets-alist (arglist-cont-nonempty
					   c-lineup-gcc-asm-reg
					   c-lineup-arglist-tabs-only))))
  (setq c-default-style '((java-mode . "javax")
			  (awk-mode . "awk")
			  (other . "linux"))))
(add-hook 'c-initialization-hook 'my-c-initialization-setup)
#+END_SRC

*** CANCELED c-mode-hook (for C files)
Thinks that will only ever apply to .C files

#+BEGIN_SRC emacs-lisp
(defun my-c-mode-setup ()
  (when (and buffer-file-name
                 (string-match "linux" buffer-file-name))
    (progn (c-set-style "linux-tabs-only")
	   (setq tab-width 8
		 c-basic-offset 8))))
(add-hook 'c-mode-hook 'my-c-mode-setup)
#+END_SRC

*** CANCELED c-mode-common-hook (for C and C++ files)
Things that will apply to .C and .CPP files

#+BEGIN_SRC emacs-lisp
(defun my-c-mode-common-setup ()
  (bind-key "(" 'self-insert-command c-mode-map)
  (bind-key ")" 'self-insert-command c-mode-map)
  (bind-key "{" 'my-c-electric-brace-open c-mode-map)
  (turn-off-auto-fill)
  ;; Normally electric mode should be off
  (electric-indent-local-mode -1)
  ;; This makes things like super_function_for_you a word
  (modify-syntax-entry ?_ "w")
  (setq fill-column 78
	;; indent by 4 (almost) everywhere
	tab-width 4
	c-basic-offset 4
	;; Let RET break and continue a comment
	;; C doesn't start functions with a ( in the first column
	open-paren-in-column-0-is-defun-start nil
	;; Insert TABs inside literals
	c-tab-always-indent 1
	;; Tell cc-mode not to check for old-style (K&R) function
	;; declarations. This speeds up indenting a lot (I hear).
	c-recognize-knr-p nil
	;; Jump to errors, please
	compilation-auto-jump-to-first-error t
	;; Keep electric mode on for now
	;; c-electric-flag nil
	;; But if it's on, let a "#" go to the left, for #if/#else/#endif
	c-electric-pound-behavior '(alignleft)
	;; No abbrevs
	abbrev-mode nil
	))
(add-hook 'c-mode-common-hook 'my-c-mode-common-setup)
#+END_SRC
** Mode: Ediff
http://oremacs.com/2015/01/17/setting-up-ediff/

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :commands (ediff-setup-keymap)
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")
  (defun my--ediff-hook ()
    (ediff-setup-keymap)
    (bind-key "j" 'ediff-next-difference ediff-mode-map)
    (bind-key "k" 'ediff-previous-difference ediff-mode-map))
  (add-hook 'ediff-mode-hook 'my--ediff-hook)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo))
#+END_SRC

** TODO Mode: ELisp

#+BEGIN_SRC emacs-lisp
(defun my--elisp-setup ()
  ;; Setup imenu TODO
  (add-to-list 'imenu-generic-expression '(""  "^;;;_ \\(.*\\)" 1) t)
  ;; automatically give help about function syntax
  (eldoc-mode t)
  ;; "-" is almost always part of a function- or variable-name
  (modify-syntax-entry ?- "w")
  ;; TODO
  ;; (unless (string= (buffer-name) "*scratch*")
  ;;   (auto-compile-mode 1))
  )
(add-hook 'emacs-lisp-mode-hook 'my--elisp-setup)
#+END_SRC

** Mode: JS2-Mode
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :mode ("\\.js\\'" . js2-mode)
  :interpreter ("node" . js2-mode)
  :config
  (setq js2-basic-offset 2
	js2-highlight-level 3)
  ;; we can run a nodejs REPL locally or over TRAMP, and it works out-of-the-box!
  (defalias 'run-node 'nodejs-repl)
)
#+END_SRC
** Mode: Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode (("\\.md\\'"       . markdown-mode)
	 ("\\.markdown\\'" . markdown-mode)))
#+END_SRC

** Mode: Python

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'python))
(defun my-python-setup ()
  (interactive)
  (setq indent-tabs-mode t
	python-indent-offset 4
	tab-width 4
	;; this fixes the weird indentation when entering a colon
	;; from http://emacs.stackexchange.com/questions/3322/python-auto-indent-problem
	electric-indent-chars (delq ?: electric-indent-chars)))
(add-hook 'python-mode-hook 'my-python-setup)
#+END_SRC
** Mode: Qt project files
From  https://raw.githubusercontent.com/chriskonstad/emacs/master/elisp/qt-pro.el
#+BEGIN_SRC emacs-lisp
(use-package qt-pro
  :defer t
  :commands (qt-pro-mode)
  :mode ("\\.pr[io]\\'" . qt-pro-mode)
)
#+END_SRC

** Mode: Rust

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :mode (("\\.rs\\'" . rust-mode)))
#+END_SRC

** Mode: Shell

#+BEGIN_SRC emacs-lisp
(defun my-shell-tab-setup ()
  (interactive)
  (setq indent-tabs-mode t)
  (setq tab-width 4)
  (setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84))
  (bind-key "C-i" 'self-insert-command text-mode-map))
(add-hook 'shell-mode-hook 'my-shell-tab-setup)
(add-hook 'sh-mode-hook    'my-shell-tab-setup)
#+END_SRC

** Mode: web-mode
Home page: http://web-mode.org/

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :commands web-mode
  :mode (("\\.html\\'" . web-mode)
	 ("\\.css\\'" . web-mode)
	 ("\\.json\\'" . web-mode)
	 )
  :config
  (defun my-web-mode-hook ()
    ;; (whitespace-turn-off)
    ;; (rainbow-turn-off)
    ;; (visual-line-mode)
    ;; (local-set-key (kbd "RET") 'newline-and-indent)
    (setq web-mode-markup-indent-offset 2
	  web-mode-css-indent-offset 2
	  web-mode-code-indent-offset 2
	  web-mode-indent-style 2
	  web-mode-style-padding 1
	  web-mode-script-padding 1
	  web-mode-block-padding 0))
  (add-hook 'web-mode-hook 'my-web-mode-hook)
)
#+END_SRC

** Package: ansi-term
This term understands ansi escape sequences.

On Debian, one should install the =ansi-term= debian package so that
the terminal "eterm-color" is available.

#+BEGIN_SRC emacs-lisp
(use-package ansi-term
  :commands (ansi-term ansi-shell)
  :bind ("M-g a" . ansi-shell)
  :init
  (defun ansi-shell ()
    "Start ansi-term with bash"
    (interactive)
    (ansi-term "/bin/bash"))
  :config

  ;; don't linger around when closing
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
    (if (memq (process-status proc) '(signal exit))
	(let ((buffer (process-buffer proc)))
	  ad-do-it
	  (kill-buffer buffer))
      ad-do-it))
  (ad-activate 'term-sentinel)

  (defun term-toggle-mode ()
    (interactive)
    (if (term-in-line-mode)
	(term-char-mode)
      (term-line-mode)))

  (defun my-term-hook ()
    (goto-address-mode)
    ;; (bind-key "C-c C-j" #'term-toggle-mode term-mode-map)
    ;; (bind-key "C-c C-k" #'term-toggle-mode term-mode-map)
    (setq global-hl-line-mode nil)
    (setq term-buffer-maximum-size 10000)
    (setq-local ml-interactive? t) ;; for mode line
    (setq-local show-dir-in-mode-line? t) ;; also mode linec'
    (setq show-trailing-whitespace nil)
    ;; disable company in favor of shell completion
    ;;(company-mode -1)
    )
  (add-hook 'term-mode-hook 'my-term-hook)
)
#+END_SRC
** Package: column-marker

#+BEGIN_SRC emacs-lisp
(use-package column-marker
  :ensure t
  :commands (column-marker-1 column-marker-2)
  :init
  (defun my--column-marker-at-80 ()
    (interactive)
    (column-marker-2 80))
  (add-hook 'c-mode-hook 'my--column-marker-at-80)
  )
#+END_SRC

** CANCELED Package: auto-compile

#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :ensure t
  :config
  (auto-compile-on-load-mode 1)
  (auto-compile-on-save-mode 1)
  )
#+END_SRC

** Package: eshell
https://www.masteringemacs.org/article/complete-guide-mastering-eshell

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :defer t
  :bind ("M-g e" . eshell)
  :config
  (defun eshell/clear ()
    "Deletes the contents of eshell buffer, except the last prompt"
    (save-excursion
      (goto-char eshell-last-output-end)
      (let ((lines (count-lines 1 (point)))
	    (inhibit-read-only t))
	(beginning-of-line)
	(let ((pos (point)))
	  (if (bobp)
	      (if (interactive-p)
		  (error "Buffer too short to truncate"))
	    (delete-region (point-min) (point)))))))

  ;; We don't need no banner
  (setq eshell-banner-message "")

  ;; If I ever want my own eshell/foo commands overwrite real commands ...
  (setq eshell-prefer-lisp-functions t)

  ;; check if this is ok for my usage
  ;; eshell-visual-commands
 
  (defun my--eshell-hook ()
    (eshell-read-aliases-list)
    (setq global-hl-line-mode nil)
    (setq show-trailing-whitespace nil)
    (add-to-list 'eshell-visual-commands "ssh")
    (add-to-list 'eshell-visual-commands "htop")
    (add-to-list 'eshell-visual-commands "ncmpcpp")
    (add-to-list 'eshell-visual-commands "tail")
    (setq-local ml-interactive? t) ;; for mode line
    (eshell/addpath "~/bin"))
  (add-hook 'eshell-mode-hook 'my--eshell-hook)
)
#+END_SRC

** Package: helm-tags
#+BEGIN_SRC emacs-lisp
(use-package helm-tags
  :defer t
  :bind (("M-." . helm-etags-select))
)
#+END_SRC
** CANCELED Package: helm-gtags
http://tuhdo.github.io/c-ide.html

#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :ensure t
  :config
  (setq helm-gtags-ignore-case t
	helm-gtags-auto-update t
	helm-gtags-use-input-at-cursor t
	helm-gtags-pulse-at-cursor t
	helm-gtags-prefix-key "\C-cg"
	helm-gtags-suggested-key-mapping t)
  (add-hook 'dired-mode-hook 'helm-gtags-mode)
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)

  (bind-key "C-c g a" 'helm-gtags-tags-in-this-function helm-gtags-mode-map)
  (bind-key "C-c g r" 'helm-gtags-find-rtag helm-gtags-mode-map)
  (bind-key "C-j" 'helm-gtags-select helm-gtags-mode-map)
  (bind-key "M-." 'helm-gtags-dwim helm-gtags-mode-map)
  (bind-key "M-," 'helm-gtags-pop-stack helm-gtags-mode-map)
  (bind-key "C-c <" 'helm-gtags-previous-history helm-gtags-mode-map)
  (bind-key "C-c >" 'helm-gtags-next-history helm-gtags-mode-map)
)
#+END_SRC

** Package: magit
Must be set before magit is loaded. It will remove the new key
bindings that use pop-up buffers.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :diminish magit-auto-revert-mode  ;; disable "MRev" in the status line
  :defines (magit-rigid-key-bindings)
  :init
  ;; disable warning about magit-auto-revert-mode
  (setq magit-last-seen-setup-instructions "1.4.0")
  (setq magit-rigid-key-bindings t)
  :config
  (progn
    ;; Save modified buffers without asking
    (setq magit-save-some-buffers 'dontask)
    ;; (setq magit-commit-all-when-nothing-staged nil)
    (setq magit-stage-all-confirm nil)
    (setq magit-unstage-all-confirm nil)
    ;; switch the current window to magit-status (was pop-to-buffer)
    (setq magit-status-buffer-switch-function 'switch-to-buffer)
    ;; (setq magit-refresh-file-buffer-hook '(revert-buffer))
    (setq magit-use-overlays nil)
    (setq magit-item-highlight-face nil)
    (setq magit-completing-read-function 'completing-read)
    ;; (set-face-foreground 'magit-diff-add "green4")
    ;; (set-face-foreground 'magit-diff-del "red3")
     )
  :bind ("C-c m" . magit-status)
  :commands (magit-get-top-dir))
#+END_SRC

** Package: magit-timemachine

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands git-timemachine
  )
#+END_SRC
** Package: rainbow-mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :defer t
  :commands (rainbow-mode)
)
#+END_SRC
