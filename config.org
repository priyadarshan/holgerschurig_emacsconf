#+TITLE: Holger Schurig's Emacs configuration
# @compile: (message "FOO")
# @compile: (byte-compile-file "config.el")
# @compile: (org-twbs-export-to-html)

* License

All code sections in this =.org= file are licensed under
[[GPLv2][http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html]] except
otherwise noted. For example, I derives some functions from notmuch.
And as notmuch uses GPLv3 or higher, this functions got the same
license.

* About this file
Inspired by the [[http://eschulte.me/emacs24-starter-kit/#installation][Emacs Starter Kit]], I set up my configuration file
using org-babel. You may use it as-is, but I guess (and suggest) that
you only look here to get ideas. Create your own Emacs config, in the
same pace as your knowledge about Emacs grows.

* Optional debug
Use the following if there is some nasty bug that you cannot find with
=emacs --debug-init=:

#+BEGIN_SRC emacs-lisp :tangle no
(toggle-debug-on-error)
#+END_SRC
* Loading of elisp
** Loading config.org
   :PROPERTIES:
   :TITLE:    Efficiently untangling Elisp from .org files
   :HUGO_TAGS: Emacs, org-mode
   :HUGO_TOPICS: Emacs
   :HUGO_FILE: en/emacs-efficiently-untangling-elisp.md
   :HUGO_DATE: [2016-05-12 23:01]
   :END:
Many people keep their Emacs config in and org-mode file because it's
easier to manage.

However, we need to extract the Elisp parts out of the org file and
evaluate them somehow. org-mode has a built-in command for this:
=(org-babel-load-file "config.org")=. However, this is an org-mode
command, and org-mode is huge. So your init.el needs to load a good
amount of org-mode just to get the elisp out of it.
But to be able to do this you'd
need to load a good amount of the org-mode file. 

I wanted to have something better. Something that is flexible and
gives me a quicker startup time.

#+HTML: <!--more-->

My method is to do the following:

1. If the =config.org= is newer than =config.el=, then *efficiently*
   extract all *eligible* Elisp source code blocks from the =.org=
   file and write them into the =.el= file. Even when done efficiently,
   this is relatively slow. But it almost never happens.
2. then load the =config.el= file. This is quite fast.

I wrote two words in bold:

- efficiently :: to un-tangle the source-code blocks I could have
     used =(org-babel-tangle nil "config.el")=. But it opens and
     closes the target file for every single source code blocks. You
     can hear the churn if you still use spinning rust (a hard disk).
     My code fixes this.
- eligible :: we all know than org-tangle honors "=:tangle no=". But
     it doesn't care for the todo-state of a section. I wrote my code
     so that it will skip over items marked as "CANCELED". It's just
     nicer to mark one section with "CANCELED" --- compared to change
     everyone of it's five source-code blocks with =:tangle no=.

*** The tangling

First I define a function that --- when the point is at some source-code block ---
goes back to the section header and checks if there entry has been canceled:

#+BEGIN_SRC emacs-lisp :tangle no
;; This is GPLv2. If you still don't know the details, read
;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

(defun my-tangle-section-canceled ()
  "Return t if the current section header was CANCELED, else nil."
  (save-excursion
    (if (re-search-backward "^\\*+\\s-+\\(.*?\\)?\\s-*$" nil t)
        (string-prefix-p "CANCELED" (match-string 1))
      nil)))
#+END_SRC

With that done, we can untangle source-code blocks like this:

- disabled garbage collection
- defines the regexp (stolen from org-mode) to parse org-mode source blocks
- uses a while-loop to search every source-block
- checks that the source block is neither untangleable nor in a CANCELED section
- appends the body of the source block to =body-list=
- finally, it uses a temporary file and insert all the collected bodies into it
- and writes the result out into a =.el=-file

#+BEGIN_SRC emacs-lisp :tangle no
;; This uses partially derived code from ob-core.el. So this snippet
;; is GPLv3 or later. If you still don't know the details, read
;; http://www.gnu.org/licenses/

(defun my-tangle-config-org (orgfile elfile)
  "This function will write all source blocks from =config.org= into
=config.el= that are ...

- not marked as :tangle no
- have a source-code of =emacs-lisp=
- doesn't have the todo-marker CANCELED"
  (let* ((body-list ())
		 (gc-cons-threshold most-positive-fixnum)
         (org-babel-src-block-regexp   (concat
                                        ;; (1) indentation                 (2) lang
                                        "^\\([ \t]*\\)#\\+begin_src[ \t]+\\([^ \f\t\n\r\v]+\\)[ \t]*"
                                        ;; (3) switches
                                        "\\([^\":\n]*\"[^\"\n*]*\"[^\":\n]*\\|[^\":\n]*\\)"
                                        ;; (4) header arguments
                                        "\\([^\n]*\\)\n"
                                        ;; (5) body
                                        "\\([^\000]*?\n\\)??[ \t]*#\\+end_src")))
    (with-temp-buffer
      (insert-file-contents orgfile)
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
        (let ((lang (match-string 2))
              (args (match-string 4))
              (body (match-string 5))
              (canc (my-tangle-section-canceled)))
          (when (and (string= lang "emacs-lisp")
                     (not (string-match-p ":tangle\\s-+no" args))
                     (not canc))
              (add-to-list 'body-list body)))))
    (with-temp-file elfile
      (insert (format ";; Don't edit this file, edit %s instead ...\n\n" orgfile))
      (apply 'insert (reverse body-list)))
    (message "Wrote %s ..." elfile)))
#+END_SRC

*** The Usage

Now I can use this function. If either the =.el= file doesn't exist or
the =.org= file is newer, I'll re-create the =.el= file.

#+BEGIN_SRC emacs-lisp :tangle no
;; This is GPLv2. If you still don't know the details, read
;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

(let ((orgfile (concat user-emacs-directory "config.org"))
      (elfile (concat user-emacs-directory "config.el")))
  (when (or (not (file-exists-p elfile))
            (file-newer-than-file-p orgfile elfile))
    (my-tangle-config-org orgfile elfile))
  (load-file elfile))
#+END_SRC

This code is mostly active when I update my emacs configuration with
=git pull=, e.g. when switching from desktop to laptop or vica versa.

*** Also tangle on save

But normally I'd like to avoid even this. I wrote a function that is
called whenever I save a file. It checks if the file is indeed the
.org file.

#+BEGIN_SRC emacs-lisp
;; This is GPLv2. If you still don't know the details, read
;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

(defun my-tangle-config-org-hook-func ()
  (when (string= "config.org" (buffer-name))
	(let ((orgfile (concat user-emacs-directory "config.org"))
		  (elfile (concat user-emacs-directory "config.el")))
	  (my-tangle-config-org orgfile elfile))))
(add-hook 'after-save-hook #'my-tangle-config-org-hook-func)
#+END_SRC
*** Some benchmark results

| Task                                                    | Duration |
|---------------------------------------------------------+----------|
| /                                                       |        > |
| Loading with (org-babel-load-file "config.org")         |   1.31 s |
| Loading with my code, config.el is up-to-date           |   0.99 s |
| Loading with my code, after byte-compiling              |   0.85 s |
| Loading with my code, but need to re-generate config.el |   1.10 s |

You'll see that ...

- my approach is 0.32 seconds faster than using =org-babel-load-file=.
  But I have the added benefit that I can mark sections as CANCELED
  :-)
- after a fresh "git pull", I pay a very low price of 0.09 seconds
- byte-compilation doesn't bring much for this file ...

All measurements were done on my laptop. My desktop is about double as fast.

** add =git/*= to =load-path=
#+BEGIN_SRC emacs-lisp
(let ((emacs-git (expand-file-name "git/" user-emacs-directory)))
  (mapc (lambda (x)
		  (add-to-list 'load-path (expand-file-name x emacs-git)))
		(delete ".." (directory-files emacs-git))))
#+END_SRC
** package
We already have part of the package initialization in =init.el=, so here is the rest:

#+BEGIN_SRC emacs-lisp
(package-initialize nil)
(setq package-enable-at-startup nil)
#+END_SRC

Seems that we need certificate pinning before accessing some https sites:

#+BEGIN_SRC emacs-lisp :tangle no
(when (fboundp 'gnutls-available-p)
  (fmakunbound 'gnutls-available-p))
(setq tls-program '("gnutls-cli --tofu -p %p %h")
      imap-ssl-program '("gnutls-cli --tofu -p %p %s")
      smtpmail-stream-type 'starttls
      starttls-extra-arguments '("--tofu"))
#+END_SRC

Now enable =packages.el= with MELPA:

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil
            package-archives
            '(("gnu"             . "http://elpa.gnu.org/packages/")
              ("melpa"           . "http://melpa.org/packages/")
              ;; ("melpa-stable" . "http://stable.melpa.org/packages/")
              ;; ("elpy"         . "http://jorgenschaefer.github.io/packages/")
              ;; ("org"          . "http://orgmode.org/elpa/") ;; for org-plus-contrib
              ))
#+END_SRC

** use-package
See http://github.com/jwiegley/use-package/
or http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html

Basic syntax:

#+BEGIN_EXAMPLE
(use-package package-name
	 [:keyword [option]]...)

:init          Code to run before PACKAGE-NAME has been loaded.
:config        Code to run after PACKAGE-NAME has been loaded.  Note that if
			   loading is deferred for any reason, this code does not execute
			   until the lazy load has occurred.
:preface       Code to be run before everything except `:disabled'; this can
			   be used to define functions for use in `:if', or that should be
			   seen by the byte-compiler.
:mode          Form to be added to `auto-mode-alist'.
:interpreter   Form to be added to `interpreter-mode-alist'.
:commands      Define autoloads for commands that will be defined by the
			   package.  This is useful if the package is being lazily loaded,
			   and you wish to conditionally call functions in your `:init'
			   block that are defined in the package.
:bind          Bind keys, and define autoloads for the bound commands.
:bind*         Bind keys, and define autoloads for the bound commands,
			   *overriding all minor mode bindings*.
:bind-keymap   Bind a key prefix to an auto-loaded keymap defined in the
			   package.  This is like `:bind', but for keymaps.
:bind-keymap*  Like `:bind-keymap', but overrides all minor mode bindings
:defer         Defer loading of a package -- this is implied when using
			   `:commands', `:bind', `:bind*', `:mode' or `:interpreter'.
			   This can be an integer, to force loading after N seconds of
			   idle time, if the package has not already been loaded.
:after         Defer loading of a package until after any of the named
			   features are loaded.
:demand        Prevent deferred loading in all cases.
:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.
:disabled      The package is ignored completely if this keyword is present.
:defines       Declare certain variables to silence the byte-compiler.
:functions     Declare certain functions to silence the byte-compiler.
:load-path     Add to the `load-path' before attempting to load the package.
:diminish      Support for diminish.el (if installed).
:ensure        Loads the package using package.el if necessary.
:pin           Pin the package to an archive.
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
;; You can turn this on to see when exactly a package get's configured
;; (setq use-package-verbose t)
#+END_SRC

** paradox
https://github.com/Malabarba/paradox

| Key   | Function                        |
|-------+---------------------------------|
| =v=   | visit homepage                  |
| =l=   | list recent commits             |
| =f r= | filter by regexp                |
| =f u= | filter by upgradeable packages  |
| =f k= | filter by keyword               |
| =f s= | filter by user-starred packages |
|-------+---------------------------------|

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :ensure t
  :bind (("M-g p" . paradox-list-packages-no-fetch)
		 ("M-g P" . paradox-list-packages))
  :config
  (defun paradox-list-packages-no-fetch ()
	"Shows you the packages without actually fetching new ones."
	(interactive)
	(paradox-list-packages t))

  ;; disable the github token generation
  (setq paradox-github-token t)

  (setq paradox-execute-asynchronously t
		paradox-display-download-count t)
)
#+END_SRC

* Personal information
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Holger Schurig")
(setq user-mail-address "holgerschurig@gmail.com")
#+END_SRC

Passwords that shouldn't end up in my public git tree. Also not that I
make =freenode-password= known via =(defvar=, so that the
byte-compiler won't bark at me.

#+BEGIN_SRC emacs-lisp
(defvar freenode-password)
(require 'private nil 'noerror)
#+END_SRC
* Visual elements
** GUI elements

Disable toolbars and the scroll-bar

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(unless (eq system-type 'windows-nt)
  (scroll-bar-mode -1))
#+END_SRC

You may also put something like this into =~/.Xresources= to enable/disable
certain things as soon as Emacs starts, e.g. before this script executes:

#+BEGIN_EXAMPLE
Emacs.verticalScrollBars: off
Emacs.toolBar: off
#+END_EXAMPLE

Disabling greeting in the echo area is rather nasty, because a simple
setting of this variable by setq is deliberately ignored. Sigh.

#+BEGIN_SRC emacs-lisp
(eval-after-load "startup" '(fset 'display-startup-echo-area-message 'ignore))
; Empty scratch message
(setq initial-scratch-message nil)
; Include current buffer name in the title bar
(setq frame-title-format '(buffer-file-name "%f" ("%b")))
#+END_SRC

** Window manager interaction
Avoid Emacs hanging for a while after changing default font:

#+BEGIN_SRC emacs-lisp
(modify-frame-parameters nil '((wait-for-wm . nil)))
#+END_SRC

** Theme

=my-theme= is derived from kooten-theme, I just changed it to a real black background.

#+BEGIN_SRC emacs-lisp
(use-package my-theme
  :if (display-graphic-p)
)
#+END_SRC

You may also put something like this into =~/.Xresources= to define
the font:

#+BEGIN_EXAMPLE
Emacs.geometry: 120x55
Emacs.Font:     Terminus 11
#+END_EXAMPLE

** Blend fringe
http://emacs.stackexchange.com/a/5343/115

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'fringe nil
					  :foreground (face-foreground 'default)
					  :background (face-background 'default))
#+END_SRC

** Let parenthesis behave

#+BEGIN_SRC emacs-lisp
(use-package paren
  :config
  (show-paren-mode 1)
  (setq show-paren-delay 0)
)
#+END_SRC
** Font locking
#+BEGIN_SRC emacs-lisp
(use-package font-lock
  :config
  (setq jit-lock-stealth-time 2
		jit-lock-contextually t  ;; was 'syntax-driven
		jit-lock-stealth-nice 0.3
		font-lock-maximum-decoration 2)
  (setq-default font-lock-multiline t)
)
#+END_SRC
** Highlight keywords

See https://www.emacswiki.org/emacs/AddKeywords for the example and
https://www.emacswiki.org/emacs-test/RegularExpression for regular
expession description. Currently, I use:

- \\< :: start of word
- \\( :: start of group
- \\) :: end of group
- \\| :: or
- \\? :: optional

Add font locking for =FIXME=, =TODO=, =XXX= and =HINT= to all modes
except diff-mode and org-mode.

#+BEGIN_SRC emacs-lisp
(defface my-todo-face
  '((t :foreground "red"
	   :weight bold))   
  "Font for showing TODO words."
  :group 'basic-faces)

(defun my-add-font-lock-keywords ()
  (unless (or (eq 'diff-mode major-mode)
		  (eq 'org-mode major-mode))
	(font-lock-add-keywords nil
							'(("\\<\\(\\(FIXME\\|TODO\\|XXX\\|HINT\\):?\\)" 1 'font-lock-warning-face prepend)))))
(add-hook 'find-file-hook #'my-add-font-lock-keywords)
#+END_SRC

Mark =\todo= in LaTeX mode:

#+BEGIN_SRC emacs-lisp :tangle no
(font-lock-add-keywords 'latex-mode '(("\\(\\\\todo\\)" 1 'font-lock-warning-face prepend)))
#+END_SRC

** Line truncation
Don't display continuation lines

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

Do `M-x toggle-truncate-lines` to toggle truncation mode.
`truncate-partial-width-windows' has to be nil for `toggle-truncate-lines'
to work in split windows

#+BEGIN_SRC emacs-lisp
(setq truncate-partial-width-windows nil)
#+END_SRC

** Show trailing whitespace

#+BEGIN_SRC emacs-lisp
(defun my--show-trailing-whitespace ()
  (interactive)
  (setq show-trailing-whitespace t))
(defun my--hide-trailing-whitespace ()
  (interactive)
  (message "hide trailing whitespace")
  (setq show-trailing-whitespace nil))
(add-hook 'prog-mode-hook 'my--show-trailing-whitespace)
#+END_SRC

** Buffers without toolbar, extra frame etc

#+BEGIN_SRC emacs-lisp
(add-to-list 'special-display-buffer-names "*Backtrace*")
(add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))
#+END_SRC

** Misc settings for text vs. windowing systems

#+BEGIN_SRC emacs-lisp
(if window-system
	;; X11, Windows, etc
	(progn
	  ;; Windowing systems are fast enought
	  (column-number-mode t)
	  ;; Turn off blinking
	  (blink-cursor-mode -1)
	  )
  ;; Text mode
  (progn
	;; No "very" visible cursor
	(setq visible-cursor nil)))
#+END_SRC

** No audible bell

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

** Let emacs react faster to keystrokes

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
(setq idle-update-delay 0.35)
#+END_SRC

** Mode line setup
Show line and column numbers in the mode-line

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

** Powerline mode line
*** Powerline faces
Without this we have some proportional font on Windows:

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (set-face-attribute 'mode-line nil :font "Courier New"))
#+END_SRC

Define new faces for elements on an active powerline:

#+BEGIN_SRC emacs-lisp
;; Base faces, face1 is active, face2 is inactive
(defface my-pl-face1 '((t (:foreground "white" :background "blue1" :inherit mode-line))) nil :group 'powerline)
(defface my-pl-face2 '((t (:foreground "dimgray" :background "#000040" ))) nil :group 'powerline)
(defface my-pl-face3 '((t (:foreground "black" :background "dark orange" :inherit mode-line))) nil :group 'powerline)
(defface my-pl-face4 '((t (:foreground "dimgray" :background "#402000"))) nil :group 'powerline)

(defface my-pl-indi-romod-face1 '((t (:inherit my-pl-face1))) nil :group 'powerline)
(defface my-pl-indi-romod-face2 '((t (:inherit my-pl-face2))) nil :group 'powerline)
(defface my-pl-indi-narrow-face1 '((t (:inherit my-pl-face1))) nil :group 'powerline)
(defface my-pl-indi-narrow-face2 '((t (:inherit my-pl-face2))) nil :group 'powerline)
(defface my-pl-size-face1 '((t (:inherit my-pl-face1))) nil :group 'powerline)
(defface my-pl-size-face2 '((t (:inherit my-pl-face2))) nil :group 'powerline)
(defface my-pl-mule-face1 '((t (:inherit my-pl-face1))) nil :group 'powerline)
(defface my-pl-mule-face2 '((t (:inherit my-pl-face2))) nil :group 'powerline)
(defface my-pl-name-face1 '((t (:inherit my-pl-face3 :foreground "white" :background "darkred"))) nil :group 'powerline)
(defface my-pl-name-face2 '((t (:inherit my-pl-face4 :background "#400000"))) nil :group 'powerline)
(defface my-pl-dir-face1 '((t (:inherit mode-line :foreground "dimgray"))) nil :group 'powerline)
(defface my-pl-dir-face2 '((t (:inherit mode-line-inactive :foreground "dimgray"))) nil :group 'powerline)
(defface my-pl-major-face1 '((t (:inherit my-pl-face1))) nil :group 'powerline)
(defface my-pl-major-face2 '((t (:inherit my-pl-face2))) nil :group 'powerline)
(defface my-pl-process-face1 '((t (:inherit my-pl-face1))) nil :group 'powerline)
(defface my-pl-process-face2 '((t (:inherit my-pl-face2))) nil :group 'powerline)
(defface my-pl-minor-face1 '((t (:inherit my-pl-face3))) nil :group 'powerline)
(defface my-pl-minor-face2 '((t (:inherit my-pl-face4))) nil :group 'powerline)
(defface my-pl-lincol-face1 '((t (:inherit my-pl-face1))) nil :group 'powerline)
(defface my-pl-lincol-face2 '((t (:inherit my-pl-face2))) nil :group 'powerline)
(when (display-graphic-p)
  (set-face-attribute 'mode-line-highlight nil :foreground "white" :weight 'bold)
  (set-face-attribute 'my-pl-indi-romod-face1 nil :weight 'bold)
  (set-face-attribute 'my-pl-name-face1 nil :weight 'bold))
#+END_SRC

*** Powerline functions
Here I define [[http://amitp.blogspot.com/2011/08/emacs-custom-mode-line.html][Amit's]] shorten-directory function, so that the directory
in the mode-line isn't too long.

#+BEGIN_SRC emacs-lisp
(defun shorten-directory (dir max-length)
  "Show up to `max-length' characters of a directory name `dir'."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
		(output ""))
	(when (and path (equal "" (car path)))
	  (setq path (cdr path)))
	(while (and path (< (length output) (- max-length 4)))
	  (setq output (concat (car path) "/" output))
	  (setq path (cdr path)))
	(when path
	  (setq output (concat ".../" output)))
	output))
#+END_SRC

*** finally the mode line
And finally we build our mode line:

- [X] buffer-read-only
- [X] buffer-modified-p
- [X] narrow-status
- [-] buffer size
- [-] mule environment
- [ ] unread mail
- [ ] directory
- [ ] projectile-project-name
- [ ] buffer name
- [-] which function information?
- [X] major mode
- [X] minor mode
- [X] process status
- [X] line number
- [X] column number
- [-] percent
- [?] flycheck status
- [?] battery status

- [?] global-mode-string?
- [?] GIT branch?
- [?] time?

#+BEGIN_SRC emacs-lisp
(use-package powerline
  :if (display-graphic-p)
  :ensure t
  :config
  (powerline-default-theme)
  (setq powerline-default-separator 'arrow)
  (setq powerline-height 18)
  (setq powerline-display-buffer-size nil)
  (setq powerline-display-mule-info nil)
  (setq powerline-display-hud nil)

  ;; used for modes + line numbers
  (set-face-attribute 'powerline-active1   nil :foreground "black" :background "dark orange")
  (set-face-attribute 'powerline-inactive1 nil :foreground "black" :background "DarkOrange4")
  ;; used for left/right border, indicator + empty space
  (set-face-attribute 'powerline-active2   nil :background "blue1")
  (set-face-attribute 'powerline-inactive2 nil :background "blue4")

  ;; This detects the current state of narrowing. It is a slight
  ;; modification of the original function powerline-narrow from
  ;; powerline.el: It displays a unicode flag as well.
  (defpowerline my-powerline-narrow
	(let (real-point-min real-point-max)
	  (save-excursion
		(save-restriction
		  (widen)
		  (setq real-point-min (point-min)
				real-point-max (point-max))))
	  (when (or (/= real-point-min (point-min))
				(/= real-point-max (point-max)))
		(propertize (char-to-string #x2691)
					'mouse-face 'mode-line-highlight
					'help-echo "mouse-1: Remove narrowing from the current buffer"
					'local-map (make-mode-line-mouse-map
								'mouse-1 'mode-line-widen)))))

  (setq-default mode-line-format
				'("%e"
				  (:eval
				   (let* ((active (powerline-selected-window-active))
						  (mode-line (if active 'mode-line 'mode-line-inactive))
						  (indi-romod-face (if active 'my-pl-indi-romod-face1 'my-pl-indi-romod-face2))
						  (indi-narrow-face (if active 'my-pl-indi-narrow-face1 'my-pl-indi-narrow-face2))
						  (size-face (if active 'my-pl-size-face1 'my-pl-size-face2))
						  (mule-face (if active 'my-pl-mule-face1 'my-pl-mule-face2))
						  (name-face (if active 'my-pl-name-face1 'my-pl-name-face2))
						  (dir-face (if active 'my-pl-dir-face1 'my-pl-dir-face2))
						  (major-face (if active 'my-pl-major-face1 'my-pl-major-face2))
						  (process-face (if active 'my-pl-process-face1 'my-pl-process-face2))
						  (minor-face (if active 'my-pl-minor-face1 'my-pl-minor-face2))
						  (lincol-face (if active 'my-pl-lincol-face1 'my-pl-lincol-face2))

						  (separator-left (intern (format "powerline-%s-%s"
														  (powerline-current-separator)
														  (car powerline-default-separator-dir))))
						  (separator-right (intern (format "powerline-%s-%s"
														   (powerline-current-separator)
														   (cdr powerline-default-separator-dir))))

						  (lhs (append (list ;; modified/readonly status
										(powerline-raw "%*" indi-romod-face 'l)
										(my-powerline-narrow indi-narrow-face 'l)
										(powerline-raw " " indi-narrow-face)

										;; buffer size
										(when powerline-display-buffer-size
										  (powerline-buffer-size size-face 'l))

										;; Multilingual environment
										(when powerline-display-mule-info
										  (powe3rline-raw mode-line-mule-info mule-face 'l))

										;; Directory, Buffer
										(funcall separator-right mule-face name-face)
										;; (powerline-buffer-id name-face 'l) ;; this gives wrong foreground
										(powerline-raw "%b " name-face 'l)
										(funcall separator-left name-face dir-face)

										(when (and (buffer-file-name)
												   (not (file-remote-p default-directory)))
										  (powerline-raw (shorten-directory default-directory 25)
														 dir-face 'l))

										(powerline-raw " " dir-face)
										(funcall separator-right dir-face major-face)

										;; Major mode
										(powerline-major-mode major-face 'l)

										;; Empty space
										(powerline-raw " " major-face)

										;; Some process status
										(powerline-process process-face))

									   ;; Minor mode
									   (append (if (split-string (format-mode-line minor-mode-alist))
												   (list (powerline-minor-modes minor-face 'l)
														 (funcall separator-left minor-face mode-line))
												 (list (funcall separator-left major-face mode-line))))
									 ))

						  (rhs (list ;; (powerline-raw global-mode-string face2 'r)
									 (funcall separator-right mode-line lincol-face)

									 ;; line number, column number
									 (powerline-raw "%l:%c " lincol-face 'l)

									 ;; XPM containing the position
									 (when powerline-display-hud
									   (powerline-hud my-pl-face1 my-pl-face3))
									 ))
							   )
			 (concat (powerline-render lhs)
				 (powerline-fill mode-line (powerline-width rhs))
				 (powerline-render rhs))))))
)
#+END_SRC

** Whitespace
The following can visualize white space quite neatly:

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :defer t
  :bind ("C-c w" . global-whitespace-mode)
  :config
  (setq whitespace-style
	'(face
	  trailing
	  tabs
	  spaces
	  lines
	  lines-tail
	  newline
	  ;;empty
	  space-before-tab
	  indentation
	  empty
	  space-after-tab
	  space-mark
	  tab-mark
	  ;;newline-mark
	  ))
)
#+END_SRC

** Unhighlight if out of focus
I got the idea from here: http://amitp.blogspot.de/2013/05/emacs-highlight-active-buffer.html

#+BEGIN_SRC emacs-lisp
(defun highlight-focus:app-focus-in ()
  (global-font-lock-mode 1)
  (set-face-attribute 'default nil :foreground "white"))
(defun highlight-focus:app-focus-out ()
  (global-font-lock-mode -1)
  (set-face-attribute 'default nil :foreground "#555555"))

(add-hook 'focus-in-hook  #'highlight-focus:app-focus-in)
(add-hook 'focus-out-hook #'highlight-focus:app-focus-out)

#+END_SRC
* Misc settings
** Emacs internals

#+BEGIN_SRC emacs-lisp
(setq message-log-max 10000)
#+END_SRC

Use new byte codes from Emacs 24.4

#+BEGIN_SRC emacs-lisp
(setq byte-compile--use-old-handlers nil)
(setq ad-redefinition-action 'accept)
#+END_SRC

** Fixup system-name
Normally, I could use the =system-name= variable to get the current
hostname, but it seems to return the value of =hostname -f=, e.g.
"holger.schurig.local". Therefore, I find the hostname manually by
calling =shell-command-to-string= and stripping some whitespace. This
will probably /not/ work on windows.

#+BEGIN_SRC emacs-lisp
(setq system-name
   (replace-regexp-in-string "\\`[ \t\n]*" ""
	  (replace-regexp-in-string "[ \t\n]*\\'" ""
		 (shell-command-to-string "hostname"))))
#+END_SRC
** History
Delete identical history entries
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC
** Save mini-buffer history
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :init
   (setq savehist-file (concat user-emacs-directory "tmp/history.el")
	 history-length 1000)
  :config
  (savehist-mode 1))
#+END_SRC
** Enable some disabled commands

#+BEGIN_SRC emacs-lisp
(put 'erase-buffer 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Default browser

#+BEGIN_SRC emacs-lisp
(use-package browse-url
  :defer t
  :config
  (setq browse-url-browser-function 'browse-url-generic
	browse-url-generic-program "x-www-browser"))
#+END_SRC

** Simpler yes or no prompt

#+BEGIN_SRC emacs-lisp
;  Get rid of yes-or-no questions - y or n is enough
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Customization
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load-file custom-file))
#+END_SRC

Keep lisp names in the custom buffers, don't capitalize. And kill old
buffers.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :defer t
  :config
  (setq custom-unlispify-tag-names nil
		custom-buffer-done-kill t)
)
#+END_SRC

** Localisation
A sentence doesn't end with two spaces:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
** Dash
Add =-difference= as a deferred load to silence the byte-compiler.
#+BEGIN_SRC emacs-lisp
(use-package dash
  :ensure t
  :defer t
  :commands (-difference)
)
#+END_SRC
** Emacs server

- always start the emacs-server, except when run in daemon mode
- already Disable prompt asking you if you want to kill a buffer
  with a live process attached to it.
  http://stackoverflow.com/questions/268088/how-to-remove-the-prompt-for-killing-emacsclient-buffers

#+BEGIN_SRC emacs-lisp
(use-package server
  :config
  (unless (or (daemonp) (server-running-p))
	(server-mode 1))
  (add-hook 'server-switch-hook 'raise-frame)
)
#+END_SRC

A good way to start emacsclient is with this line in =/etc/bash.bashrc=:

#+BEGIN_EXAMPLE
alias e="emacsclient --no-wait --alternate-editor=\"\" --create-frame"
#+END_EXAMPLE

May may also set the environment variables =EDITOR= and/or =VISUAL=,
but then you better omit the "=--no-wait=" option.

* Editing
** CANCELED Transpose
http://endlessparentheses.com/transposing-keybinds-in-emacs.html

#+BEGIN_SRC emacs-lisp
(bind-key "\C-t" #'transpose-lines)
(bind-key "\C-t" #'transpose-chars ctl-x-map)
#+END_SRC
** Undo-Tree
This lets you use =C-z= (undo-tree-visualize) to visually walk through
the changes you've made, undo back to a certain point (or redo), and
go down different branches.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :commands (undo-tree-visualize)
  :bind ("C-z" . undo-tree-visualize)
  :config
  (progn
	(global-undo-tree-mode)
	(setq undo-tree-visualizer-timestamps t)
	(setq undo-tree-visualizer-diff t)))
#+END_SRC
* Cursor movement
First we define code that allows us to bind multiple functions to
repeated commands. Taken from
[[http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding]]:

#+BEGIN_SRC emacs-lisp
(defvar seq-times 0
  "Stores number of times command was executed.  It cotnains
random data before `seq-times' macro is called.")

(defmacro seq-times (&optional name max &rest body)
  "Returns number of times command NAME was executed and updates
`seq-times' variable accordingly.  If NAME is nil `this-command'
will be used.  If MAX is specified the counter will wrap around
at the value of MAX never reaching it.  If body is given it will
be evaluated if the command is run for the first time in a
sequence."
  (declare (indent 2))

  ;; Build incrementation part
  (setq max (cond ((null max) '(setq seq-times (1+ seq-times)))
		  ((atom max) (if (and (integerp max) (> max 0))
				  `(setq seq-times (% (1+ seq-times) ,max))
				'(setq seq-times (1+ seq-times))))
		  (t          `(let ((max ,max))
				 (if (and (integerp max) (> max 0))
					 (setq seq-times (% (1+ seq-times) max))
				   (setq seq-times (1+ seq-times)))))))

  ;; Make macro
  (if (eq name 'last-command)
	  max
	(cond ((null  name) (setq name 'this-command))
	  ((consp name) (setq name `(or ,name this-command))))
	`(if (eq last-command ,name)
	 ,max
	   ,@body
	   (setq seq-times 0))))

(defmacro seq-times-nth (name body &rest list)
  "Calls `seq-times' with arguments NAME, length and BODY
and (where length is the number of elements in LIST) then returns
`seq-times'th element of LIST."
  (declare (indent 2))
  `(nth (seq-times ,name ,(length list) ,body) ',list))

(defmacro seq-times-do (name body &rest commands)
  "Calls `seq-times' with arguments NAME, length and BODY (where
length is the number of COMMANDS) and then runs `seq-times'th
command from COMMANDS."
  (declare (indent 2))
  `(eval (nth (seq-times ,name ,(length commands) ,body) ',commands)))
#+END_SRC

** Home / End

#+BEGIN_SRC emacs-lisp
(defvar my--previous-position)

(defun my-home ()
  "Depending on how many times it was called moves the point to:

   - begin of indentation
   - beginning of line
   - begin of function
   - beginning of buffer
   - back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
	(back-to-indentation)
	(beginning-of-line)
	(beginning-of-defun)
	(goto-char (point-min))
	(goto-char my--previous-position)))
#+END_SRC

(substitute-key-definition 'move-beginning-of-line 'my-home (current-global-map))

#+BEGIN_SRC emacs-lisp
(bind-key "C-a" 'my-home)
(bind-key "<home>" 'my-home)


(defun my-end ()
  "Depending on how many times it was called moves the point to:

   - end of line
   - end of function
   - end of buffer
   - back to where it was"
  (interactive)
  (seq-times-do nil (setq my--previous-position (point))
	(end-of-line)
	(forward-paragraph)
	(end-of-defun)
	(goto-char (point-max))
	(goto-char my--previous-position)))
(bind-key "C-e" 'my-end)
(bind-key "<end>" 'my-end)
#+END_SRC

** Recenter

#+BEGIN_SRC emacs-lisp
(setq recenter-positions '(middle 4 -4))
#+END_SRC

** Nicer goto-line
Doesn't modify minibuffer-history, but use it's own little history
list.

#+BEGIN_SRC emacs-lisp
(defvar my-goto-line-history '())
(defun my-goto-line (line &optional buffer)
  "Goto LINE, counting from line 1 at beginning of buffer.
Normally, move point in the current buffer, and leave mark at the
previous position.  With just \\[universal-argument] as argument,
move point in the most recently selected other buffer, and switch to it.

If there's a number in the buffer at point, it is the default for LINE.

This function is usually the wrong thing to use in a Lisp program.
What you probably want instead is something like:
  (goto-char (point-min)) (forward-line (1- N))
If at all possible, an even better solution is to use char counts
rather than line counts."
  (interactive
   (if (and current-prefix-arg (not (consp current-prefix-arg)))
	   (list (prefix-numeric-value current-prefix-arg))
	 ;; Look for a default, a number in the buffer at point.
	 (let* ((default
		  (save-excursion
		(skip-chars-backward "0-9")
		(if (looking-at "[0-9]")
			(buffer-substring-no-properties
			 (point)
			 (progn (skip-chars-forward "0-9")
				(point))))))
		;; Decide if we're switching buffers.
		(buffer
		 (if (consp current-prefix-arg)
		 (other-buffer (current-buffer) t)))
		(buffer-prompt
		 (if buffer
		 (concat " in " (buffer-name buffer))
		   "")))
	   ;; Read the argument, offering that number (if any) as default.
	   (list (read-from-minibuffer (format (if default "Goto line%s (%s): "
						 "Goto line%s: ")
					   buffer-prompt
					   default)
				   nil nil t
				   'my-goto-line-history
				   default)
		 buffer))))
  ;; Switch to the desired buffer, one way or another.
  (if buffer
	  (let ((window (get-buffer-window buffer)))
	(if window (select-window window)
	  (switch-to-buffer-other-window buffer))))
  ;; Leave mark at previous position
  (or (region-active-p) (push-mark))
  ;; Move to the specified line number in that buffer.
  (save-restriction
	(widen)
	(goto-char (point-min))
	(if (eq selective-display t)
	(re-search-forward "[\n\C-m]" nil 'end (1- line))
	  (forward-line (1- line)))))
(bind-key "M-g g"   'my-goto-line)
(bind-key "M-g M-g" 'my-goto-line)
#+END_SRC

** expand-region
Home page: https://github.com/magnars/expand-region.el

C-+ Expand region increases the selected region by semantic units.

You can then either continue to press C-+ to expand even further, or
use + and - after the first expand to expand further / shrink again.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-+" . er/expand-region)
  :config
  (setq expand-region-reset-fast-key    "<ESC><ESC>"))
#+END_SRC

** bookmark

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :config
  (setq bookmark-default-file (concat user-emacs-directory "tmp/bookmarks.el"))
  )
#+END_SRC

** avy (alternative to ace-jump-mode)

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind ("C-#" . avy-goto-char-timer)
  :config (progn
		(setq avy-keys (append (number-sequence ?a ?z)
					(number-sequence ?0 ?9)))
		(setq avy-style 'at-full)
		(setq avy-all-windows nil)
		(setq avy-highlight-first t)))
#+END_SRC

** smartscan
This makes =M-n= and =M-p= look for the symbol at point. This is
very un-intrusive, no pop-up, no nothing,

#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :ensure t
  :commands (global-smartscan-mode)
  :config
  (global-smartscan-mode t)
  )
#+END_SRC

** Mouse scrolling
Smooth scrolling (default is 5).

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(2 ((shift) . 1) ((control) . nil))
	  mouse-wheel-progressive-speed nil)
#+END_SRC
* Yank and Delete
** Delete word or yank
The following may be of interest to people who (a) are happy with
"C-w" and friends for killing and yanking, (b) use
"transient-mark-mode", (c) also like the traditional Unix tty
behaviour that "C-w" deletes a word backwards. It tweaks "C-w" so
that, if the mark is inactive, it deletes a word backwards instead
of killing the region. Without that tweak, the C-w would create an
error text without an active region.
http://www.emacswiki.org/emacs/DefaultKillingAndYanking#toc2

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before unix-werase activate compile)
  "When called interactively with no active region, delete a single word
	backwards instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
	 (list (save-excursion (backward-word 1) (point)) (point)))))
#+END_SRC

** Selection deletion
Use delete-selection mode:

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Deletion in readonly buffer
Be silent when killing text from read only buffer:

#+BEGIN_SRC emacs-lisp
(setq kill-read-only-ok t)
#+END_SRC

** Join lines at killing
If at end of line, join with following; otherwise kill line.
Deletes whitespace at join.

#+BEGIN_SRC emacs-lisp
(defun kill-and-join-forward (&optional arg)
  "If at end of line, join with following; otherwise kill line.
Deletes whitespace at join."
  (interactive "P")
  (if (and (eolp) (not (bolp)))
	  (delete-indentation t)
	(kill-line arg)))
(bind-key "C-k" 'kill-and-join-forward)
#+END_SRC

** Dynamic char deletion
The following is from Boojum's post in
[[http://www.reddit.com/r/emacs/comments/b1r8a/remacs_tell_us_about_the_obscure_but_useful/]].

I don't want to kill the comment, just the prefix to it. So that

// The quick brown fox[]
// jumps over the lazy dog.

becomes

// The quick brown fox[] jumps over the lazy dog.

#+BEGIN_SRC emacs-lisp
(defun delete-char-dynamic (&optional arg)
  "If at end of line, intelligently join to the following;
otherwise delete."
  (interactive "p")
  (if (or (not (eolp)) (bolp))
	  (delete-char arg)
	(let ((start (point))
		  (in-comment (eq (get-text-property (point) 'face)
						  'font-lock-comment-face)))
	  (forward-char)
	  (skip-chars-forward " \  ")
	  (if (and in-comment (looking-at comment-start-skip))
		  (goto-char (match-end 0)))
	  (delete-region start (point))
	  (when (and (not (eolp))
				 (/= (char-before) ? )
				 (/= (char-before) ?\  ))
		(insert-char ?  1)
		(backward-char)))))
#+END_SRC

Make delete-selection-mode work with it

#+BEGIN_SRC emacs-lisp
(put 'delete-char-dynamic 'delete-selection 'supersede)
#+END_SRC

Rebind DELETE and friends to our version

#+BEGIN_SRC emacs-lisp
(bind-key "<deletechar>" 'delete-char-dynamic)
(bind-key "<delete>" 'delete-char-dynamic)
(bind-key "C-d" 'delete-char-dynamic)
#+END_SRC

** X11 clipboard

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

** Mouse yank
Paste at text-cursor, not at mouse-cursor:

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
** Package avy-zap: delete up to a character
This makes =M-z= ask via avy to which character text should be
deleted. The character itself will stay. If you use =M-Z=, then this
character will be gone, too.

#+BEGIN_SRC emacs-lisp
(use-package avy-zap
  :ensure t
  :bind (("M-z" . avy-zap-up-to-char-dwim)
		 ("M-Z" . avy-zap-to-char-dwim))
)
#+END_SRC
* Completion
** Case
Ignore case when reading a file name completion

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Do not consider case significant in completion (GNU Emacs default)

#+BEGIN_SRC emacs-lisp
(setq completion-ignore-case t)
#+END_SRC

** Tab
Lets TAB do completion as well

#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
#+END_SRC

** CANCELED company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :bind ("C-<tab>" . company-complete)
  :init
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  (setq company-idle-delay              0.3
		company-tooltip-flip-when-above t
		company-tooltip-limit           20
		company-backends '(;; company-bbdb
						   company-nxml
						   company-css
						   ;; company-eclim
						   company-semantic
						   ;; company-clang
						   ;; company-xcode
						   company-cmake
						   company-capf
						   company-files
						   (company-dabbrev-code
							;; company-gtags
							company-etags
							company-keywords)
						   ;; company-oddmuse
						   company-dabbrev)
		)
)
#+END_SRC
* Windows handling
** delete-window
If only one window in frame, `delete-frame'.
From http://www.emacswiki.org/emacs/frame-cmds.el

#+BEGIN_SRC emacs-lisp
(defadvice delete-window (around delete-window (&optional window) activate)
  (interactive)
  (save-current-buffer
	(setq window (or window (selected-window)))
	(select-window window)
	(if (one-window-p t)
	(delete-frame)
	  ad-do-it (selected-window))))
#+END_SRC

** new kill-buffer-and-window
Replacement for interactive `kill-buffer'. We cannot redefine
`kill-buffer', because other elisp code relies on it's exact
behavior.

#+BEGIN_SRC emacs-lisp
(defun my--kill-buffer-and-window (&optional buffer)
  "Kill buffer BUFFER-OR-NAME.
The argument may be a buffer or the name of an existing buffer.
Argument nil or omitted means kill the current buffer. Return t
if the buffer is actually killed, nil otherwise.

Unlike `kill-buffer', this also will delete the current window if
there are several windows open."
  (interactive)
  (setq buffer (or buffer (current-buffer)))
  (unless (one-window-p)
	(delete-window))
  (kill-buffer buffer))
(bind-key "C-x k" 'my--kill-buffer-and-window)
#+END_SRC

** Window sizing

#+BEGIN_SRC emacs-lisp
(bind-key "<M-down>" 'enlarge-window)
(bind-key "<M-up>" 'shrink-window)
#+END_SRC

** Window zooming (F5)
If there is only one window displayed, act like =C-x 2=. If there are
two windows displayed, act like =C-x 1=.

#+BEGIN_SRC emacs-lisp
(defun my-zoom-next-buffer2 ()
  (let ((curbuf (current-buffer))
	(firstbuf nil))
	(dolist (buffer (buffer-list))
	  (with-current-buffer buffer
	;(princ (format "name %s, fn %s\n" (buffer-name) buffer-file-name))
	(unless (or
		 ;; Don't mention internal buffers.
		 (string= (substring (buffer-name) 0 1) " ")
		 ;; No buffers without files.
		 (not buffer-file-name)
		 ;; Skip the current buffer
		 (eq buffer curbuf)
		 )
	  ;(princ (format " nme %s, fn %s\n" (buffer-name) buffer-file-name))
	  (unless firstbuf
		(setq firstbuf buffer))
		;;(print buffer)
	  )))
	(when firstbuf
	  ;(princ (format "new buffer: %s.\n" firstbuf))
	  (bury-buffer)
	  (switch-to-buffer firstbuf))))
(defun my-explode-window ()
  "If there is only one window displayed, act like C-x2. If there
are two windows displayed, act like C-x1:"
  (interactive)
  (if (one-window-p t)
	  (progn
	(split-window-vertically)
	(other-window 1)
	(my-zoom-next-buffer2)
	(other-window -1))
	(delete-other-windows)))
(bind-key "<f5>" 'my-explode-window)
#+END_SRC
** Windows toggle / Buffer switching (F6)
If there is only one window displayed, swap it with previous buffer.
If there are two windows displayed, act like =C-x o=.

#+BEGIN_SRC emacs-lisp
(defun my-switch-to-buffer ()
  "If there is only one window displayed, swap it with previous buffer.
If there are two windows displayed, act like =C-x o=."
  (interactive)
  (if (one-window-p t)
	  (switch-to-buffer (other-buffer (current-buffer) 1))
	(other-window -1)))
(bind-key "<f6>" 'my-switch-to-buffer)
#+END_SRC

** Winner mode

#+BEGIN_SRC emacs-lisp
(use-package winner
  :defer 10
  :init
  (winner-mode 1))
#+END_SRC
** Other window
#+BEGIN_SRC emacs-lisp
(bind-key "M-o" #'other-window)
#+END_SRC
* Buffers
** Insert buffer
|-------+---------------|
| C-x i | insert file   |
|-------+---------------|
| C-x I | insert buffer |
|-------+---------------|
Insert buffer at current position

#+BEGIN_SRC emacs-lisp
(bind-key "C-x I" 'insert-buffer)
#+END_SRC

** Protect buffers
https://raw.githubusercontent.com/lewang/le_emacs_libs/master/keep-buffers.el

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'cl))
(define-minor-mode keep-buffers-mode
  "when active, killing protected buffers results in burying them instead.
Some may also be erased, which is undo-able."
  :init-value nil
  :global t
  :group 'keep-buffers
  :lighter ""
  :version "1.4"
  (if keep-buffers-mode
	  ;; Setup the hook
	  (add-hook 'kill-buffer-query-functions 'keep-buffers-query)
	(remove-hook 'kill-buffer-query-functions 'keep-buffers-query)))
(defcustom keep-buffers-protected-alist
  '(("\\`\\*scratch\\*\\'" . erase)
	("\\`\\*Messages\\*\\'" . nil))
  "an alist '((\"regex1\" . 'erase) (\"regex2\" . nil))

CAR of each cons cell is the buffer matching regexp.  If CDR is
not nil then the matching buffer is erased then buried.

If the CDR is nil, then the buffer is only buried."
  :type '(alist)
  :group 'keep-buffers)
(defun keep-buffers-query ()
  "The query function that disable deletion of buffers we protect."
  (let ((crit (dolist (crit keep-buffers-protected-alist)
				(when (string-match (car crit) (buffer-name))
				  (return crit)))))
	(if crit
		(progn
		  (when (cdr crit)
			(erase-buffer))
		  (bury-buffer)
		  nil)
	  t)))
(keep-buffers-mode 1)
#+END_SRC

** Easier kill buffers with processes
Don't asks you if you want to kill a buffer with a live process
attached to it:
http://www.masteringemacs.org/articles/2010/11/14/disabling-prompts-emacs/

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
	  (remq 'process-kill-buffer-query-function
		 kill-buffer-query-functions))
#+END_SRC

** Cycle buffers

** iflipb
http://www.emacswiki.org/emacs/iflipb

#+BEGIN_SRC emacs-lisp
(use-package iflipb
  :ensure t
  :commands (iflipb-next-buffer iflipb-previous-buffer)
  :bind ("S-<f6>" . my-iflipb-previous-buffer)
  :config
  (setq iflipb-wrap-around t)

  (defvar my-iflipb-auto-off-timeout-sec 4.5)
  (defvar my-iflipb-auto-off-timer-canceler-internal nil)
  (defvar my-iflipb-ing-internal nil)
  (defun my-iflipb-auto-off ()
	(message nil)
	(setq my-iflipb-auto-off-timer-canceler-internal nil
	  my-iflipb-ing-internal nil))
  (defun my-iflipb-next-buffer (arg)
	(interactive "P")
	(iflipb-next-buffer arg)
	(if my-iflipb-auto-off-timer-canceler-internal
	(cancel-timer my-iflipb-auto-off-timer-canceler-internal))
	(run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
	(setq my-iflipb-ing-internal t))
  (defun my-iflipb-previous-buffer ()
	(interactive)
	(iflipb-previous-buffer)
	(if my-iflipb-auto-off-timer-canceler-internal
	(cancel-timer my-iflipb-auto-off-timer-canceler-internal))
	(run-with-idle-timer my-iflipb-auto-off-timeout-sec 0 'my-iflipb-auto-off)
	(setq my-iflipb-ing-internal t))
  (defun iflipb-first-iflipb-buffer-switch-command ()
	"Determines whether this is the first invocation of
  iflipb-next-buffer or iflipb-previous-buffer this round."
	(not (and (or (eq last-command 'my-iflipb-next-buffer)
		  (eq last-command 'my-iflipb-previous-buffer))
		  my-iflipb-ing-internal))))
#+END_SRC

** ace-jump-buffer DISABLED

#+BEGIN_SRC emacs-lisp
(use-package ace-jump-buffer
  :disabled t
  :bind ("C-c C-j" . ace-jump-buffer)
  )
#+END_SRC

* File opening/saving
** Basic settings
Never show GTK file open dialog

#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil)
#+END_SRC

don't add newlines to end of buffer when scrolling, but show them

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines nil)
#+END_SRC

Preserve hard links to the file you´re editing (this is
especially important if you edit system files)

#+BEGIN_SRC emacs-lisp
(setq backup-by-copying-when-linked t)
#+END_SRC

Just never create backup files at all
make-backup-files nil

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist (list (cons "." (concat user-emacs-directory "tmp/bak/"))))
#+END_SRC

Make sure your text files end in a newline

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Disable auto-save (#init.el# file-names)

#+BEGIN_SRC emacs-lisp
(setq auto-save-default nil)
(setq auto-save-list-file-prefix (concat user-emacs-directory "tmp/auto-save-list/saves-"))
#+END_SRC

Kill means kill, not asking. Was:

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions nil)
#+END_SRC

** Automatically load .Xresources after changes
Sample ~/.Xresources:

Emacs.geometry: 120x55
Emacs.Font:	terminus 11

#+BEGIN_SRC emacs-lisp
(defun merge-x-resources ()
  (let ((file (file-name-nondirectory (buffer-file-name))))
	(when (or (string= file ".Xdefaults")
		  (string= file ".Xresources"))
	  (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
	  (message (format "Merged %s into X resource database" file)))))
(add-hook 'after-save-hook 'merge-x-resources)
#+END_SRC

** Autorevert
Revert all buffers, including dired buffers. And do it silently.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC

Don't ask when running revert-buffer when reverting files in this
list of regular expressions:

#+BEGIN_SRC emacs-lisp
(setq revert-without-query '(""))
#+END_SRC

** Decompress compressed files

#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC

** Quickly save (F2)

#+BEGIN_SRC emacs-lisp
(bind-key "<f2>" 'save-buffer)
#+END_SRC

** Unique buffer names

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

** recentf

#+BEGIN_SRC emacs-lisp
(setq recentf-save-file (concat user-emacs-directory "tmp/recentf.el")
	  recentf-exclude '("^/tmp/"
						"/.newsrc"
						"bbdb$"
						"svn-commit.tmp$"
						".png$"
						"COMMIT_EDITMSG" "COMMIT_EDITMSG" "TAG_EDITMSG")
	  recentf-max-saved-items 1000
	  recentf-auto-cleanup 300
	  recentf-max-menu-items 20)
(recentf-mode 1)
#+END_SRC
** save local variables

The following change allows me to have some files flychecked in
german-new8 and others in english (the default). I just need to put
this line into the file:

#+BEGIN_EXAMPLE
# -*- ispell-local-dictionary: "german-new8" -*-
#+END_EXAMPLE

into the file.

#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-variable-values '(ispell-dictionary . german-new8))
#+END_SRC
* Minibuffer
Don't insert current directory into minubuffer

#+BEGIN_SRC emacs-lisp
(setq insert-default-directory nil)
#+END_SRC

Minibuffer window expands vertically as necessary to hold the text
that you put in the minibuffer

#+BEGIN_SRC emacs-lisp
(setq resize-mini-windows t) ;; was grow-only
#+END_SRC

Read quoted chars with radix 16

#+BEGIN_SRC emacs-lisp
(setq read-quoted-char-radix 16)
#+END_SRC

Allow to type space chars in minibuffer input (for `timeclock-in',
for example).

#+BEGIN_SRC emacs-lisp
(define-key minibuffer-local-completion-map " " nil)
(define-key minibuffer-local-must-match-map " " nil)
#+END_SRC
* Searching
** isearch (incremental search)
Scrolling while searching

#+BEGIN_SRC emacs-lisp
(setq isearch-allow-scroll t)
(bind-key "C-y" 'isearch-yank-kill isearch-mode-map)
#+END_SRC

** Command; my-grep
Prompts you for an expression, defaulting to the symbol that your
cursor is on, and greps for that in the current directory and all
subdirectories:

#+BEGIN_SRC emacs-lisp
(defun my-grep ()
  "grep the whole directory for something defaults to term at cursor position"
  (interactive)
  (let ((default (thing-at-point 'symbol)))
	(let ((needle (or (read-string (concat "grep for '" default "': ")) default)))
	  (setq needle (if (equal needle "") default needle))
	  (grep (concat "egrep -s -i -n -r " needle " *")))))
(bind-key "M-s g" 'my-grep)
#+END_SRC
* Help
** Go to back to previous help buffer
Make 'b' (back) go to the previous position in emacs help.
[[http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks]]

#+BEGIN_SRC emacs-lisp
(add-hook 'help-mode-hook
	  '(lambda ()
		 (bind-key "b" 'help-go-back help-mode-map)))
#+END_SRC

** F1 key searches in help or opens man page
This is from https://www.emacswiki.org/emacs/DescribeThingAtPoint

#+BEGIN_SRC emacs-lisp
(defun my-help ()
		  "Show the documentation of the Elisp function and variable near point.
	This checks in turn:
	-- for a function name where point is
	-- for a variable name where point is
	-- for a surrounding function call
	"
	  (interactive)
	  (let (sym)
		;; sigh, function-at-point is too clever.  we want only the first half.
		(cond ((setq sym (ignore-errors
							   (with-syntax-table emacs-lisp-mode-syntax-table
								 (save-excursion
								   (or (not (zerop (skip-syntax-backward "_w")))
									   (eq (char-syntax (char-after (point))) ?w)
									   (eq (char-syntax (char-after (point))) ?_)
									   (forward-sexp -1))
								   (skip-chars-forward "`'")
							   (let ((obj (read (current-buffer))))
									 (and (symbolp obj) (fboundp obj) obj))))))
				   (describe-function sym))
				  ((setq sym (variable-at-point)) (describe-variable sym))
				  ;; now let it operate fully -- i.e. also check the
				  ;; surrounding sexp for a function call.
				  ((setq sym (function-called-at-point)) (describe-function sym)))))
(bind-key "<f1>" 'my-help)
#+END_SRC

** Apropos

#+BEGIN_SRC emacs-lisp
(bind-key "C-h a" 'apropos)
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :defer 2
  :diminish which-key-mode
  :config
  (which-key-mode)
  (which-key-setup-side-window-right-bottom)
)
#+END_SRC
* Miscelleanous functions
** dos2unix

#+BEGIN_SRC emacs-lisp
(defun dos2unix()
  "convert dos (^M) end of line to unix end of line"
  (interactive)
  (goto-char(point-min))
  (while (search-forward "\r" nil t) (replace-match "")))
#+END_SRC

** 822date
Inserts something like "Fri,  1 Dec 2006 15:41:36 +0100"

#+BEGIN_SRC emacs-lisp
(defun 822date ()
  "Insert date at point format the RFC822 way."
  (interactive)
  (insert (format-time-string "%a, %e %b %Y %H:%M:%S %z")))
#+END_SRC
** Calculate region
From https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/:

Write some expression, e.g. =2+2*4= and then press C-=.

#+BEGIN_SRC emacs-lisp

(defun calc-eval-region (arg)
  "Evaluate an expression in calc and communicate the result.

If the region is active evaluate that, otherwise search backwards
to the first whitespace character to find the beginning of the
expression. By default, replace the expression with its value. If
called with the universal prefix argument, keep the expression
and insert the result into the buffer after it. If called with a
negative prefix argument, just echo the result in the
minibuffer."
  (interactive "p")
  (let (start end)
	(if (use-region-p)
	(setq start (region-beginning) end (region-end))
	  (progn
	(setq end (point))
	(setq start (search-backward-regexp "\\s-\\|\n" 0 1))
	(setq start (1+ (if start start 0)))
	(goto-char end)))
	(let ((value (calc-eval (buffer-substring-no-properties start end))))
	  (pcase arg
	(1 (delete-region start end))
	(4 (insert " = ")))
	  (pcase arg
	((or 1 4) (insert value))
	(-1 (message value))))))
(bind-key "C-=" #'calc-eval-region)
#+END_SRC
* helm
Very good intro: http://tuhdo.github.io/helm-intro.html

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure helm
  :diminish helm-mode
  :bind (
	 ("C-h a"   . helm-apropos)
	 ("C-x C-f" . helm-find-files)
	 ("M-s o"   . helm-occur)
	 ("M-x"     . helm-M-x)
	 ("M-y"     . helm-show-kill-ring)
	 ("C-x C-b" . helm-mini)
	 )
  :init
  (require 'helm-config)
  (helm-mode t)
  :config
  ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
  ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
  ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
  ;; (from http://tuhdo.github.io/helm-intro.html)
  (bind-key "C-c h" 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  ;; allow "find man at point" for C-c h m (helm-man-woman)
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

  (setq helm-candidate-number-limit 100)
  (setq helm-quick-update t)

  ;; Open full helm frame
  ;; (setq helm-full-frame t)
  ;; Put helm window on somewhere else
  (setq helm-split-window-default-side 'below)

  ;; move to end or beginning of source when reaching top or bottom of source.
  (setq helm-move-to-line-cycle-in-source t)
  ;; scroll 8 lines other window using M-<next>/M-<prior>
  (setq helm-scroll-amount 8)
#+END_SRC
** Helm faces

#+BEGIN_SRC emacs-lisp
  ;; see (customize-group "helm-files-faces")
  (set-face-attribute 'helm-ff-directory        nil :foreground "red" :background 'unspecified)
  (set-face-attribute 'helm-ff-dotted-directory nil :foreground "red" :background 'unspecified)
  (set-face-attribute 'helm-ff-executable       nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-ff-file             nil :foreground 'unspecified :background 'unspecified :inherit 'unspecified)
  (set-face-attribute 'helm-ff-invalid-symlink  nil :foreground 'unspecified :background 'unspecified)
  ;;(set-face-attribute 'helm-ff-prefix         nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-ff-symlink          nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-history-deleted     nil :foreground 'unspecified :background 'unspecified)
  (set-face-attribute 'helm-history-remote      nil :foreground 'unspecified :background 'unspecified)
#+END_SRC
** Hide mode lines
Hide modelines of other windows while helm is open, again from
https://github.com/hatschipuh/better-helm.

#+BEGIN_SRC emacs-lisp
  (defvar my-helm-bottom-buffers nil
	"List of bottom buffers before helm session.
	Its element is a pair of `buffer-name' and `mode-line-format'.")

  (defun my-helm-bottom-buffers-init ()
	(setq-local mode-line-format (default-value 'mode-line-format))
	(setq my-helm-bottom-buffers
	  (cl-loop for w in (window-list)
		   when (window-at-side-p w 'bottom)
		   collect (with-current-buffer (window-buffer w)
				 (cons (buffer-name) mode-line-format)))))

  (defun my-helm-bottom-buffers-hide-mode-line ()
	(setq-default cursor-in-non-selected-windows nil)
	(mapc (lambda (elt)
		(with-current-buffer (car elt)
		  (setq-local mode-line-format nil)))
	  my-helm-bottom-buffers))

  (defun my-helm-bottom-buffers-show-mode-line ()
	(setq-default cursor-in-non-selected-windows t)
	(when my-helm-bottom-buffers
	  (mapc (lambda (elt)
		  (with-current-buffer (car elt)
		(setq-local mode-line-format (cdr elt))))
		my-helm-bottom-buffers)
	  (setq my-helm-bottom-buffers nil)))

  (defun my-helm-keyboard-quit-advice (orig-func &rest args)
	(my-helm-bottom-buffers-show-mode-line)
	(apply orig-func args))

  (add-hook 'helm-before-initialize-hook #'my-helm-bottom-buffers-init)
  (add-hook 'helm-after-initialize-hook #'my-helm-bottom-buffers-hide-mode-line)
  (add-hook 'helm-exit-minibuffer-hook #'my-helm-bottom-buffers-show-mode-line)
  (add-hook 'helm-cleanup-hook #'my-helm-bottom-buffers-show-mode-line)
  (advice-add 'helm-keyboard-quit :around #'my-helm-keyboard-quit-advice)
#+END_SRC

** Hide minibuffer
Hide minibuffer while helm is active

#+BEGIN_SRC emacs-lisp
  (defun my-helm-hide-minibuffer-maybe ()
	(when (with-helm-buffer helm-echo-input-in-header-line)
	  (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
	(overlay-put ov 'window (selected-window))
	(overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
				`(:background ,bg-color :foreground ,bg-color)))
	(setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)
#+END_SRC

** end of use-package
#+BEGIN_SRC emacs-lisp
;; this closes "(use-package helm" from way above!
)
#+END_SRC

** helm-descbinds
#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :commands helm-descbinds
  :bind (("C-h b" . helm-descbinds)
	 ("C-h w" . helm-descbinds)) ;; used to be where-is
  )
#+END_SRC

** helm-files
#+BEGIN_SRC emacs-lisp
(use-package helm-files
  :defer t
  :config
  (setq helm-ff-skip-boring-files t)

  ;; search for library in `require' and `declare-function' sexp.
  (setq helm-ff-search-library-in-sexp t)
  (setq helm-ff-file-name-history-use-recentf t)
  (setq helm-ff-newfile-prompt-p nil)

  ;; ignore Emacs save files
  (add-to-list 'helm-boring-file-regexp-list "\\.#")

  ;; Make DEL delete one character or the last path (if before a '/')
  ;; from https://github.com/hatschipuh/better-helm
  (defun my-dwim-helm-find-files-up-one-level-maybe ()
	(interactive)
	(if (looking-back "/" 1)
	(call-interactively 'helm-find-files-up-one-level)
	  (delete-char -1)))
  (bind-key "<backspace>" #'my-dwim-helm-find-files-up-one-level-maybe helm-read-file-map)
  (bind-key "<backspace>" #'my-dwim-helm-find-files-up-one-level-maybe helm-find-files-map)
  (bind-key "DEL" #'my-dwim-helm-find-files-up-one-level-maybe helm-read-file-map)
  (bind-key "DEL" #'my-dwim-helm-find-files-up-one-level-maybe helm-find-files-map)

  ;; This stops helm-find-files from pre-setting the input to the file
  ;; under point and/or changing to another directory. Somehow setting
  ;; setq helm-ff-guess-ffap-filenames and helm-ff-guess-ffap-urls
  ;; didn't do the job.
  (defun helm-find-files-initial-input (&optional input)
    "Dummy function from my config.el to disable this helm feature"
	nil
    )

  ;; If on a directory, switch helm to this directory. Don't call it with dired.
  ;; from https://github.com/hatschipuh/better-helm
  (defun my-dwim-helm-find-files-navigate-forward (orig-fun &rest args)
  "Adjust how helm-execute-persistent actions behaves, depending on context"
  (if (file-directory-p (helm-get-selection))
	  (apply orig-fun args)
	(helm-maybe-exit-minibuffer)))
  (advice-add 'helm-execute-persistent-action :around #'my-dwim-helm-find-files-navigate-forward)
  (bind-key "<return>" 'helm-maybe-exit-minibuffer helm-map)
  (bind-key "RET" 'helm-maybe-exit-minibuffer helm-map)
  (bind-key "<return>" 'helm-execute-persistent-action helm-find-files-map)
  (bind-key "<return>" 'helm-execute-persistent-action helm-read-file-map)
  (bind-key "RET" 'helm-execute-persistent-action helm-find-files-map)
  (bind-key "RET" 'helm-execute-persistent-action helm-read-file-map)
)
#+END_SRC

** helm-imenu
#+BEGIN_SRC emacs-lisp
(use-package helm-imenu
  :defer t
  :config
  (setq helm-imenu-delimiter " ")
)
#+END_SRC

** helm-net
#+BEGIN_SRC emacs-lisp
(use-package helm-net
  :defer t
  :config
  (when (executable-find "curl")
	(setq helm-net-prefer-curl t))
  (setq helm-browse-url-chromium-program "x-www-browser")
  (setq helm-google-suggest-default-browser-function 'helm-browse-url-chromium)
  (setq helm-home-url "http://www.google.de")
  (setq helm-autoresize-mode t)
)
#+END_SRC
** helm-ring
#+BEGIN_SRC emacs-lisp
(use-package helm-ring
  :defer t
  :bind (:map helm-command-map
			  ("g" . helm-all-mark-rings))
)
#+END_SRC

** helm-swoop
https://github.com/ShingoFukuyama/helm-swoop

#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :commands (helm-swoop helm-swoop-back-to-last-point)
  :bind (("M-s s"  . helm-swoop)
		 ("M-s M-s" . helm-swoop)
		 ("M-s S"   . helm-swoop-back-to-last-point))
  :config
  (setq helm-swoop-split-direction 'split-window-sensibly)
  ;; Switch to edit mode with C-c C-e, and exit edit mode with C-c C-c
  (bind-key "C-c C-c" 'helm-swoop--edit-complete helm-swoop-edit-map)
  ;; When doing isearch, hand the word over to helm-swoop
  (bind-key "M-s s"   'helm-swoop-from-isearch isearch-mode-map)
  (bind-key "M-s M-s" 'helm-swoop-from-isearch isearch-mode-map)
  ;; Move up and down like isearch
  (bind-key "C-r" 'helm-previous-line helm-swoop-map)
  (bind-key "C-s" 'helm-next-line     helm-swoop-map)
  (bind-key "C-r" 'helm-previous-line helm-multi-swoop-map)
  (bind-key "C-s" 'helm-next-line     helm-multi-swoop-map)
  ;; always pop at bottom
  ;; from https://github.com/hatschipuh/better-helm
  (setq helm-swoop-split-with-multiple-windows nil
		helm-swoop-split-direction 'split-window-vertically
		helm-swoop-split-window-function 'helm-default-display-buffer)
)
#+END_SRC

** helm-goto-recent-directory

This is from http://blog.binchen.org/posts/use-ivy-to-open-recent-directories.html, but 
adapted to helm.

#+BEGIN_SRC emacs-lisp
(defun helm-goto-recent-directory ()
  "Open recent directory with dired"
  (interactive)
  (unless recentf-mode
	(recentf-mode 1))
  (let ((src (helm-build-sync-source "Recent directories"
			   :candidates (delete-dups (mapcar 'file-name-directory recentf-list))
			   :action (lambda (candidate)
						 (dired candidate)))))
	(helm :sources src
		  :buffer "*helm recentf dir*"
		  :preselect default-directory)))

(bind-key "M-g d" #'helm-goto-recent-directory)

#+END_SRC
* org-mode
*** org itself

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (("C-c l" . org-store-link)
		 ("C-c o" . org-open-at-point-global))
  :commands (org-open-file orgstruct++-mode)
  :init
  ;; allow Shift-Cursor to mark stuff
  (setq org-replace-disputed-keys t)

  ;; modules to load together with org-mode
  (setq org-modules '(
					  ;; org-annotate-file
					  ;; org-bbdb
					  ;; org-bibtex
					  ;; org-collector
					  ;; org-docview
					  ;; org-drill
					  ;; org-eval
					  ;; org-expiry
					  ;; org-gnus
					  ;; org-habit
					  ;; org-info
					  ;; org-interactive-query
					  ;; org-irc
					  ;; org-jsinfo
					  ;; org-man
					  ;; org-mhe
					  ;; org-mouse
					  ;; org-panel
					  ;; org-protocol
					  ;; org-rmail
					  ;; org-screen
					  ;; org-toc
					  ;; org-w3m
					  ))

  :config
  ;; My main file
  (setq org-default-notes-file (expand-file-name "todo.org" user-emacs-directory))

  ;; Handle deletion inside elipsis
  (setq org-catch-invisible-edits 'error)

  ;; don't fold for now
  (setq org-startup-folded 'content)

  ;; Time stamp format
  (setq org-display-custom-times t)
  (setq org-time-stamp-formats '("<%Y-%m-%d>" . "<%Y-%m-%d %H:%M>"))
  (setq org-time-stamp-custom-formats '("<%Y-%m-%d>"))

  ;; :bind cannot bind into a different map
  (bind-key "C-TAB"   'org-cycle org-mode-map)
  (bind-key "C-c C-j" 'helm-org-in-buffer-headings org-mode-map) ;; was org-goto
  (bind-key "C-c k"   'org-cut-subtree org-mode-map)
  (bind-key "C-c R"   'org-reveal org-mode-map)
  ;; (bind-key "C-c t"   'org-show-todo-tree org-mode-map)

  ;; adjust level
  (setq org-yank-adjusted-subtrees t)

  (add-hook 'org-mode-hook #'visual-line-mode)
  (add-hook 'org-mode-hook #'toggle-word-wrap)

  ;; make enter open the link
  (setq org-return-follows-link t)

  ;; some speed commands, use ? at the start of an org-header to see which one we have
  (add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
  (add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
  (add-to-list 'org-speed-commands-user '("!" my/org-clock-in-and-track))
  (add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
  (add-to-list 'org-speed-commands-user '("i" call-interactively 'org-clock-in))
  (add-to-list 'org-speed-commands-user '("o" call-interactively 'org-clock-out))
  (add-to-list 'org-speed-commands-user '("$" call-interactively 'org-archive-subtree))
  (add-to-list 'org-speed-commands-user '("N" org-narrow-to-subtree))
  (add-to-list 'org-speed-commands-user '("W" widen))
  (add-to-list 'org-speed-commands-user '("k" org-cut-subtree))
  ;; (add-to-list 'org-speed-commands-user '("P" call-interactively 'org2blog/wp-post-subtree))

  ;; "!"    record time stamp
  ;; "@"    add note with time
  ;; "x/y"  use x when entering state, y when leaving state
  ;; the first letter can be used with C-c C-t
  (setq org-todo-keywords
	;; '((sequence "TODO(t)" "STARTED(s!)" "|" "DONE(x!)")
	;;   (sequence "WAIT(w@/!)" "DELEGATED(d@/!)" "|" "CANCELED(c@)")
	'((sequence "TODO(t)" "STARTED(s)" "|" "DONE(x)")
	  (sequence "WAIT(w)" "DELEGATED(d)" "|" "CANCELED(c)")
	  ))

  (setq org-todo-keyword-faces
	  '(("TODO"      . (:foreground "red" :weight bold))
		("STARTED"   . (:foreground "#b70101" :weight bold))
		("DONE"      . (:foreground "forestgreen" :weight bold))
		("WAIT"      . (:foreground "orange" :weight bold))
		("DELEGATED" . (:foreground "forestgreen" :weight bold))
		("CANCELED"  . shadow)))

  ;; use extra drawer
  (setq org-log-into-drawer t)

  ;; when my day ends
  (setq org-use-effective-time t
	org-extend-today-until 17)

  ;; Resume clocking tasks when emacs is restarted
  ;; (org-clock-persistence-insinuate)

  ;; TODO creates error
  ;; (setq org-global-properties
  ;; 	'("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 8:00"))

  ;; Try column with this:
  ;; (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")

  ;; misc refile settings
  (setq org-reverse-note-order t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))

  ;; (setq org-blank-before-new-entry nil)

  ;; export and open
  (defun my-org-export-to-html-and-open ()
	(interactive)
	(org-open-file (org-html-export-to-html)))
  (bind-key "<M-f7>" 'my-org-export-to-html-and-open org-mode-map)

  ;; make "<l" to insert an emacs-lisp source block
  ;; and use "<x" for the old latex export
  (setq org-structure-template-alist
	'(("s" "#+BEGIN_SRC ?\n\n#+END_SRC")
	  ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE")
	  ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE")
	  ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE")
	  ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM")
	  ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER")
	  ("l" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
	  ;; ("l" "#+BEGIN_EXPORT latex\n?\n#+END_EXPORT")
	  ("x" "#+BEGIN_EXPORT latex\n?\n#+END_EXPORT")
	  ("L" "#+LaTeX: ")
	  ("h" "#+BEGIN_EXPORT html\n?\n#+END_EXPORT")
	  ("H" "#+HTML: ")
	  ("a" "#+BEGIN_EXPORT ascii\n?\n#+END_EXPORT")
	  ("A" "#+ASCII: ")
	  ("i" "#+INDEX: ?")
	  ("I" "#+INCLUDE: %file ?")
	  ))
)
#+END_SRC

*** org-agenda
http://www.suenkler.info/docs/emacs-orgmode/

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :bind (("M-g a" . org-agenda)
		 ("M-g w" . org-agenda-list))
  :config
  (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map)
  ;; (bind-key "!" 'my/org-clock-in-and-track org-agenda-mode-map)

  ;; Highlight current line
  (add-hook 'org-agenda-mode-hook (defun my-org-agenda-hookfunc () (hl-line-mode 1 )))

  ;; which files the agenda should consider
  (setq org-agenda-files (list org-default-notes-file))

  ;; Let date stand out
  (setq org-agenda-format-date
	"%Y-%m-%d ---------------------------------------------------------------------")

  (setq org-agenda-show-outline-path t)

  ;; colorize priorities
  (setq org-agenda-fontify-priorities
	'((65 (:foreground "Red"))
	  (66 (:foreground "Blue"))
	  (67 (:foreground "Darkgreen"))))

  ;; hide done tasks
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)

  ;; normally hide the "someday" (nice-to-have) things
  (setq org-agenda-filter-preset '("-someday"))

  ;; show day schedule, not week schedule
  (setq org-agenda-span 'day)

  ;; own views
  (setq org-agenda-custom-commands
	'(("n" "Agenda and all TODO's"
	   ((agenda "")
		(alltodo "")))
	  ;; ("f" "Agenda and flagged tasks"
	  ;;  ((tags "flagged")
	  ;;   (agenda "")))
	  ("s" "Tagged 'someday'" tags "someday" ((org-agenda-filter-preset '("+someday"))
						  (org-agenda-todo-ignore-with-date nil)))
	  ))

  ;; show clock report
  ;; (setq org-agenda-start-with-clockreport-mode nil)

  ;; Keine Links, maximal bis Level 4 herunter:
  ;; (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 4))
  )
#+END_SRC

*** org-capture

#+BEGIN_SRC emacs-lisp
(use-package org-capture
  :bind ("C-c r" . my-org-capture-todo)
  ;; ("<f9> <f8>" . (lambda () (interactive) (org-capture nil "r")))
  :config
  (defun my-org-capture-todo ()
	(interactive)
	(org-capture nil "o"))
  (setq org-capture-templates
	`(("o" "Open task" entry
	   (file+headline org-default-notes-file "Unsortiert")
	   "* TODO %?\n\n")
	  ("n" "Note" item
	   (file+headline org-default-notes-file "Infos"))
	   ))
  )
#+END_SRC

*** org-clock

#+BEGIN_SRC emacs-lisp
(use-package org-clock
  :bind ("C-c j" . org-clock-goto) ;; jump to current task from anywhere
  :config
  (setq org-clock-into-drawer "CLOCK")

  ;; Yes it's long... but more is better ;)
  (setq org-clock-history-length 35)

  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)

  ;; Change task state to STARTED when clocking in
  (setq org-clock-in-switch-to-state "STARTED")

  ;; this removes clocked tasks with 0:00 duration
  ;; (setq org-clock-out-remove-zero-time-clocks t)

  ;; Don't clock out when moving task to a done state
  ;; (setq org-clock-out-when-done nil)

  ;; Save the running clock and all clock history when exiting Emacs,
  ;; load it on startup
  ;; (setq org-clock-persist t)

  ;; Disable auto clock resolution
  (setq org-clock-auto-clock-resolution nil)
  )
#+END_SRC

*** org-list

#+BEGIN_SRC emacs-lisp
(use-package org-list
  :defer t
  :functions (org-item-re)
  :config
  ;; tab changes visibility of lists like headers
  (setq org-cycle-include-plain-lists 'integrate)

  ;; speed commands are fun, not only on the headers, but also on lists
  (defun my/org-use-speed-commands-for-headings-and-lists ()
	"Activate speed commands on list items too."
	(or (and (looking-at org-outline-regexp) (looking-back "^\**"))
	(save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))
  (setq org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)
)
#+END_SRC

*** org-src

#+BEGIN_SRC emacs-lisp
(use-package org-src
  :defer t
  :config
  ;; Open source editor in current window
  (setq org-src-window-setup 'current-window)
  ;; inside src block use the colors like the major mode of the src type
  (setq org-src-fontify-natively t)
  ;; inside a src block let tab act like it was in major mode of the src type
  (setq org-src-tab-acts-natively t)
  ;; don't add two indentation spaces into src blocks
  (setq org-src-preserve-indentation t)

  ;; normally I'd need C-c ' to exit, but this enables the same exit
  ;; method I have in when doing a commit in magit.
  (bind-key "C-c C-c" 'org-edit-src-exit org-src-mode-map)
)
#+END_SRC

*** ox

#+BEGIN_SRC emacs-lisp
(use-package ox
  :defer t
  :config
  ;; The following make some +OPTIONS permanent:
  ;; #+OPTIONS ':t
  (setq org-export-with-smart-quotes t)
  ;; #+OPTIONS num:nil
  (setq org-export-with-section-numbers nil)
  ;; #+OPTIONS stat:t
  ;; (setq org-export-with-statistics-cookies nil)
  ;; #+OPTIONS toc:nil, use "#+TOC: headlines 2" or similar if you need a headline
  (setq org-export-with-toc nil)
  ;; #+OPTIONS ^:{}
  (setq org-export-with-sub-superscripts nil)

  ;; This exports broken links as [BROKEN LINK %s], so we can actually
  ;; find them. The default value nil just aborts the export process
  ;; with an error message "Unable to resolve link: nil". This doesn't
  ;; give any hint on which line the broken link actually is :-(
  (setq org-export-with-broken-links 'mark)
)
#+END_SRC

*** ox-html
#+BEGIN_SRC emacs-lisp
(use-package ox-html
  :defer t
  :commands org-html-export-to-html
  :config
  (setq org-html-postamble-format '(("en" "<p class=\"author\">Author: %a</p><p class=\"creator\">Created with %c</p>")))
  (setq org-html-validation-link nil)
  (setq org-html-postamble nil)
  (setq org-html-style-default "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/\n  body { text-align: center; font-family: \"Aria\", sans-serif; }\n  #content { margin: 0 auto; width: 860px; text-align: left; }\n  #text-table-of-contents > ul > li { margin-top: 1em; }\n  .title  { text-align: center; }\n  .todo   { color: red; }\n  .done   { color: green; }\n  .WAIT, .DELEGATED   { color: blue; }\n  .done   { color: green; }\n  .tag    { background-color: #eee; font-family: monospace;\n            padding: 2px; font-size: 80%; font-weight: normal; }\n  .timestamp { color: #bebebe; }\n  .timestamp-kwd { color: #5f9ea0; }\n  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }\n  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }\n  .center { margin-left: auto; margin-right: auto; text-align: center; }\n  .underline { text-decoration: underline; }\n  #postamble p, #preamble p { font-size: 90%; margin: .2em; }\n  p.verse { margin-left: 3%; }\n  pre {\n    border: 1px solid #ccc;\n    box-shadow: 3px 3px 3px #eee;\n    padding: 8pt;\n    font-family: monospace;\n    overflow: auto;\n    margin: 1em 0;\n  }\n  pre.src {\n    position: relative;\n    overflow: visible;\n    padding-top: 8pt;\n  }\n  pre.src:before {\n    display: none;\n    position: absolute;\n    background-color: white;\n    top: -10px;\n    right: 10px;\n    padding: 3px;\n    border: 1px solid black;\n  }\n  pre.src:hover:before { display: inline;}\n  pre.src-sh:before    { content: 'sh'; }\n  pre.src-bash:before  { content: 'sh'; }\n  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }\n  pre.src-R:before     { content: 'R'; }\n  pre.src-perl:before  { content: 'Perl'; }\n  pre.src-java:before  { content: 'Java'; }\n  pre.src-sql:before   { content: 'SQL'; }\n\n  table { border-collapse:collapse; }\n  caption.t-above { caption-side: top; }\n  caption.t-bottom { caption-side: bottom; }\n  td, th { vertical-align:top;  }\n  th.right  { text-align: center;  }\n  th.left   { text-align: center;   }\n  th.center { text-align: center; }\n  td.right  { text-align: right;  }\n  td.left   { text-align: left;   }\n  td.center { text-align: center; }\n  dt { font-weight: bold; }\n  .footpara:nth-child(2) { display: inline; }\n  .footpara { display: block; }\n  .footdef  { margin-bottom: 1em; }\n  .figure { padding: 1em; }\n  .figure p { text-align: center; }\n  .inlinetask {\n    padding: 10px;\n    border: 2px solid gray;\n    margin: 10px;\n    background: #ffffcc;\n  }\n  #org-div-home-and-up\n   { text-align: right; font-size: 70%; white-space: nowrap; }\n  textarea { overflow-x: auto; }\n  .linenr { font-size: smaller }\n  .code-highlighted { background-color: #ffff00; }\n  .org-info-js_info-navigation { border-style: none; }\n  #org-info-js_console-label\n    { font-size: 10px; font-weight: bold; white-space: nowrap; }\n  .org-info-js_search-highlight\n    { background-color: #ffff00; color: #000000; font-weight: bold; }\n  .ulClassNameOrID > li {}\n  /*]]>*/-->\n</style>")
  (setq org-html-table-default-attributes '(:border "2" :cellspacing "0" :cellpadding "6"))
  (setq org-html-postamble t))
#+END_SRC

*** ox-publish
#+BEGIN_SRC emacs-lisp
(use-package ox-publish
  :defer t
  :if (or (string= "holger" system-name)
		  (string= "laptop" system-name))
  :bind ("C-c p" . my-publish)
  :config
  (setq org-publish-project-alist
	'(("twbs"
	   :base-directory "~/org/"
	   :publishing-directory "~/org/twbs/"
	   :base-extension "org"
	   :recursive t
	   :publishing-function org-twbs-publish-to-html

	   ;; See http://orgmode.org/manual/Publishing-options.html#Publishing-options

	   ;; Don't emit  "Created: 2016-02-12 Fri 09:28 Emacs 24.5.1 (Org mode 8.3.3)"
	   :html-postamble nil

	   ;; This is the Table of Contents on the right side, you can turn it off
	   ;; per page with "#+OPTIONS: toc:nil"
	   :with-toc t

	   :html-use-infojs nil
	   :html-validation-link ""
	   :html-home/up-format ""
	   :html-link-up ""
	   :html-link-home ""
	   ;; :html-checkbox-type 'html   ;; use CSS to format them
	   :html-metadata-timestamp-format "%Y-%m-%d %H:%M"

	   ;; General export settings
	   :archived-trees nil
	   :headline-levels 3
	   :section-numbers nil
	   :with-author nil ;; Only one author ever
	   :with-date nil
	   :with-latex nil
	   :with-sub-superscript nil
	   )

	  ("html"
	   :base-directory "~/org/"
	   :publishing-directory "~/org/html/"
	   :base-extension "org"
	   :recursive t
	   :publishing-function org-html-publish-to-html

	   ;; see (org-html--build-head info)
	   :html-head-include-default-style nil ;; org-html-head-include-default-style
	   ;; :html-head                   ;; org-html-head
	   ;; :html-head "<link rel=\"stylesheet\" href=\"../other/mystyle.css\" type=\"text/css\"/>"
	   ;; :html-head-extra             ;; org-html-head-extra
	   ;; :html-htmlized-css-url       ;; org-html-htmlized-css-url
	   :html-head-include-scripts nil       ;; org-html-head-include-scripts

	   ;; Don't emit  "Created: 2016-02-12 Fri 09:28 Emacs 24.5.1 (Org mode 8.3.3)"
	   :html-postamble nil

	   :with-toc nil

	   :html-use-infojs nil
	   :html-validation-link ""
	   :html-home/up-format ""
	   :html-link-up ""
	   :html-link-home ""
	   ;; :html-checkbox-type 'html   ;; use CSS to format them
	   :html-metadata-timestamp-format "%Y-%m-%d %H:%M"

	   ;; General export settings
	   :archived-trees nil
	   :headline-levels 3
	   :section-numbers nil
	   :with-author nil ;; Only one author ever
	   :with-date nil
	   :with-latex nil
	   :with-sub-superscript nil
	   )

	  ("static"
	   :base-directory "~/org/"
	   :base-extension "jpg\\|gif\\|png\\|css\\|js"
	   :recursive t
	   :publishing-directory "~/org/out/"
	   :publishing-function org-publish-attachment)

	  ("site" :components ("twbs" "html"))))
  (defun my-publish ()
	(interactive)
	(org-publish "site" t))
)
#+END_SRC
*** ox-twbs
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
  :defer t
  :commands (org-twbs-publish-to-html)
)
#+END_SRC
*** htmlize
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t
  :defer t
  :defines (htmlize-version)
)
#+END_SRC
* Single packages
** circe (IRC client)
see some configuration ideas at https://github.com/jorgenschaefer/circe/wiki/Configuration

#+BEGIN_SRC emacs-lisp
(use-package circe
  :defer t
  :ensure t
  :commands (circe)
  :config
  (setq circe-default-part-message "Fire on mainboard error")
  (setq circe-quit-part-message "Fire on mainboard error")
  (setq circe-reduce-lurker-spam t)
  ;; (circe-set-display-handler "JOIN" (lambda (&rest ignored) nil))
  ;; (circe-set-display-handler "QUIT" (lambda (&rest ignored) nil))
  ;; (setq circe-use-cycle-completion t)
  (setq circe-format-say "{nick}: {body}")
  (setq circe-server-killed-confirmation 'ask-and-kill-all)
  ;; Network settings
  (setq circe-default-ip-family 'ipv4)
  (setq circe-default-nick "schurig")
  (setq circe-default-user "schurig")
  (setq circe-server-auto-join-default-type 'after-auth) ; XXX try after-nick
  (setq circe-network-options `(("Freenode"
				  :host "kornbluth.freenode.net"
				  :port (6667 . 6697)
				  :channels ("#emacs" "#emacs-circe")
				  :nickserv-password ,freenode-password)
				 ))
  ;; Misc
  ;; (setq circe-format-server-topic "*** Topic change by {userhost}: {topic-diff}")
  (use-package lui-autopaste
	:config
	(add-hook 'circe-channel-mode-hook 'enable-lui-autopaste)
	)
)

(defun irc ()
  "Connect to IRC"
  (interactive)
  (circe "Freenode"))
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
(use-package dired
  :commands dired
  :bind ("C-x C-d" . dired) ;; used to be list-directory, quite useless
  :init
  (setq dired-listing-switches "-laGh1v --group-directories-first"))
#+END_SRC

** dired-x
#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :commands dired-jump
)
#+END_SRC
** flyspell

#+BEGIN_SRC emacs-lisp
(use-package flyspell
 :diminish flyspell-mode
 :commands (flyspell-mode flyspell-prog-mode)
 :config
 (add-to-list 'flyspell-dictionaries-that-consider-dash-as-word-delimiter "german-new8")
 (setq flyspell-issue-welcome-flag nil)
 ;; M-Tab is owned by the window manager, correct with C-M-i
 (setq flyspell-use-meta-tab nil)
 ;; Flyspell hijacked C-., which I want to use for tags
 (define-key flyspell-mode-map [(control ?\.)] nil)
 )

#+END_SRC

Flyspell is in elisp mode. And this in turn loads flyspell directly
after launching emacs, which is a bit unfortunate.

#+BEGIN_SRC emacs-lisp
(defun my-flyspell-prog-mode ()
  (interactive)
  (unless (string= (buffer-name) "*scratch*")
	(flyspell-prog-mode)))
(add-hook 'prog-mode-hook  #'my-flyspell-prog-mode)
(add-hook 'text-mode-hook  #'flyspell-mode)
(add-hook 'org-mode-hook   #'flyspell-mode)
(add-hook 'latex-mode-hook #'flyspell-mode)
(add-hook 'LaTeX-mode-hook #'flyspell-mode)
#+END_SRC

#+END_SRC
*** helm-flyspell
https://github.com/pronobis/helm-flyspell

#+BEGIN_SRC emacs-lisp
(use-package helm-flyspell
  :commands helm-flyspell-correct
  :config
  (bind-key "C-;" 'helm-flyspell-correct flyspell-mode-map)
  )
#+END_SRC
** hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :defer t
  :ensure t
  :commands (defhydra
		  hydra-default-pre
		  hydra-keyboard-quit
		  hydra-set-transient-map)
  )
(use-package lv
  :defer t
  :commands (lv-message))
#+END_SRC
* Mail & News
** smtpmail
http://emacs.stackexchange.com/questions/6105/how-to-set-proper-smtp-gmail-settings-in-emacs-in-order-to-be-able-to-work-with
http://superuser.com/questions/476714/how-to-configure-emacs-smtp-for-using-a-secure-server-gmail

#+BEGIN_SRC emacs-lisp
(use-package smtpmail
  :defer t
  :config
  (setq smtpmail-default-smtp-server "smtp.gmail.com"
		smtpmail-smtp-server "smtp.gmail.com"
		smtpmail-stream-type 'starttls
		smtpmail-smtp-service 587
		smtpmail-debug-info t))
#+END_SRC
** sendmail
http://www.emacswiki.org/emacs/MuttInEmacs
http://dev.mutt.org/trac/wiki/MuttFaq/Editor

#+BEGIN_SRC emacs-lisp
(use-package sendmail
  :defer t
  :commands (mail-mode mail-text)
  :defines (send-mail-function)
  :mode (("/tmp/mutt-*" . mail-mode))
  :config
  (defun my-mail-quit ()
	(interactive)
	(not-modified)
	(server-edit))
  (defun my-mail-save ()
	(interactive)
	(save-buffer)
	(server-edit))
  (defun my-mail-mode-hook ()
	(flush-lines "^\\(> \n\\)*> -- \n\\(\n?> .*\\)*") ; kill quoted sigs
	;; (visual-line-mode t)
	(auto-fill-mode)
	(delete-trailing-whitespace)
	(mail-text)
	(fill-region (point) (point-max))
	(not-modified)
	(setq make-backup-files nil))

  ;; Sending mail
  (setq send-mail-function 'smtpmail-send-it)

  (add-hook 'mail-mode-hook 'my-mail-mode-hook)
  (bind-key "C-c C-c" 'my-mail-done mail-mode-map)
  (bind-key "C-x k" 'my-mail-quit mail-mode-map)
  )
#+END_SRC

** message
#+BEGIN_SRC emacs-lisp
(use-package message
  :defer t
  :commands (message-mode message-cite-original-without-signature)
  :config

  ;; When composing a mail, start the auto-fill-mode.
  (add-hook 'message-mode-hook 'turn-on-auto-fill)
  ;; (add-hook 'message-setup-hook 'bbdb-define-all-aliases)

  ;; Generate the mail headers before you edit your message.
  (setq message-generate-headers-first t)

  ;; The message buffer will be killed after sending a message.
  (setq message-kill-buffer-on-exit t)
)
#+END_SRC

** notmuch
*** notmuch itself
#+BEGIN_SRC emacs-lisp
(use-package notmuch
  :bind ("M-g n" . notmuch-hello)
  :config
  ;; Change flagged lines to be dark blue in the background, not blue
  ;; in the foreground. This harmonizes much more with my dark theme.
  (add-to-list 'notmuch-search-line-faces
  			   '("flagged" :background "dark blue"))

  (setq notmuch-search-result-format
		'(("date" . "%12s ")
		  ("count" . "%6s ")
		  ("authors" . "%-23s ")
		  ("subject" . "%s ")
		  ;; ("tags" . "(%s)")
		  ))

  ;; remove archiving commands
  (define-key notmuch-search-mode-map "a" nil)
)
#+END_SRC
*** notmuch-hello
	:PROPERTIES:
	:TITLE:    notmuch: a nicer notmuch-hello screen for Emacs
	:HUGO_TAGS: Emacs, notmuch
	:HUGO_TOPICS: Emacs
	:HUGO_FILE: en/emacs-notmuch-hello.md
	:HUGO_DATE: [2016-05-03 10:29]
	:END:

Here I define my own hello screen for [[http://notmuchmail.org/][notmuch]]. However, I didn't like it's original
"hello" screen not that much. So I wrote something to replace it.

#+HTML: <!--more-->

This is how it used to look:

[[./emacs-notmuch-hello-orig.png]]

That's nice for a start.

- Notmuch's hello page is using Emacs' config feature. I however like
  to write everything out, and document the things while I doing them
  in my [[https://bitbucket.org/holgerschurig/emacsconf/raw/HEAD/config.org][config.org]] file. &rarr; Get rid of buttons like "Save" or the
  "Customize ..." text.
- Notmuch doesn't show the amount of messages. Okay, when I add query
  to =notmuch-saved-searches=, it will show them. But at an awkward
  position: around the center of the screen. Also it won't
  differentiate between new and total counts .. or it would need two
  queries, not just one. &rarr; Present the queries better.
- I see elements that i never use, e.g. the header, the footer, or the
  "Clear" button. &rarr; Get rid of them.

What I wrote now looks like this:

[[./emacs-notmuch-hello-mine.png]]

**** The implementation

Let's start simple: define the queries.

Note that I define basic queries, e.g. at this point in time I don't
create two queries for the unread/total amount of messages.

#+BEGIN_SRC emacs-lisp
;; This is GPLv2. If you still don't know the details, read
;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

(use-package notmuch-hello
  :defer t
  :config
  (setq notmuch-saved-searches
		'((:key "i" :name "inbox" :query "folder:INBOX")
		  (:key "b" :name "barebox" :query "folder:barebox")
		  (:key "c" :name "linux-can" :query "folder:linux-can")
		  (:key "a" :name "linux-arm-kernel" :query "folder:linux-arm-kernel")
		  (:key "m" :name "linux-mmc" :query "folder:linux-mmc")
		  (:key "9" :name "ath9k-devel" :query "folder:ath9k-devel")
		  (:key "e" :name "elecraft" :query "folder:elecraft")
		  (:key "p" :name "powertop" :query "folder:powertop")
		  (:key "D" :name "Deleted" :query "tag:deleted")
		  (:key "F" :name "Flagged" :query "tag:flagged")
		  (:key "S" :name "Sent" :query "folder:sent")
		  (:key "u" :name "unread" :query "tag:unread")
		  ))

  ;; We add items later in reverse order with (add-to-list ...):
  (setq notmuch-hello-sections '())

  ;; Add a thousand separator
  (setq notmuch-hello-thousands-separator ".")
#+END_SRC
#+BEGIN_SRC emacs-lisp :exports none
  ;; don't display columns
  (setq notmuch-column-control 1.0)
#+END_SRC

We set =notmuch-hello-sections= to the empty list, so we add
hello-section after hello-section with =(add-to-list=. This prepends,
so we add the sections in reverse order. 

**** List of recent searches

[[./emacs-notmuch-hello-recent.png]]

At the bottom are the recent searches, just without the "Save" and
"Clear" buttons. This is just a slightly modified reimplementation of
=notmuch-hello-insert-recent-searches=:

#+BEGIN_SRC emacs-lisp
;; This is GPLv3. If you still don't know the details, read
;; http://www.gnu.org/licenses/gpl-3.0.en.html

(defun my-notmuch-hello-insert-recent-searches ()
  "Insert recent searches."
  (when notmuch-search-history
    (widget-insert "Recent searches:")
    (widget-insert "\n\n")
    (let ((start (point)))
      (loop for i from 1 to notmuch-hello-recent-searches-max
	    for search in notmuch-search-history do
	    (let ((widget-symbol (intern (format "notmuch-hello-search-%d" i))))
	      (set widget-symbol
		   (widget-create 'editable-field
				  ;; Don't let the search boxes be
				  ;; less than 8 characters wide.
				  :size (max 8
					     (- (window-width)
						;; Leave some space
						;; at the start and
						;; end of the
						;; boxes.
						(* 2 notmuch-hello-indent)
						;; 1 for the space
						;; before the `[del]'
						;; button. 5 for the
						;; `[del]' button.
						1 5))
				  :action (lambda (widget &rest ignore)
					    (notmuch-hello-search (widget-value widget)))
				  search))
	      (widget-insert " ")
	      (widget-create 'push-button
			     :notify (lambda (widget &rest ignore)
				       (when (y-or-n-p "Are you sure you want to delete this search? ")
					 (notmuch-hello-delete-search-from-history widget)))
			     :notmuch-saved-search-widget widget-symbol
			     "del"))
	    (widget-insert "\n"))
      (indent-rigidly start (point) notmuch-hello-indent))
    nil))

  (add-to-list 'notmuch-hello-sections #'my-notmuch-hello-insert-recent-searches)
#+END_SRC

**** Simple search line

[[./emacs-notmuch-hello-search.png]]

Then I want a simple search method. The original implementation suited
my needs quite fine, I use it unmodified:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'notmuch-hello-sections #'notmuch-hello-insert-search)
#+END_SRC

**** Header face for the search screen

And finally we want out improved hello screen. Let's start with the
face for the header:

#+BEGIN_SRC emacs-lisp
  ;; This is GPLv2. If you still don't know the details, read
  ;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

  (defface my-notmuch-hello-header-face
	'((t :foreground "white"
		 :background "blue"
		 :weight bold))
	"Font for the header in `my-notmuch-hello-insert-searches`."
	:group 'notmuch-faces)
#+END_SRC

**** Helper function to count messages

I implemented a simpler version of =notmuch-hello-query-counts=:

#+BEGIN_SRC emacs-lisp
  ;; This is GPLv3. If you still don't know the details, read
  ;; http://www.gnu.org/licenses/gpl-3.0.en.html

  (defun my-count-query (query)
	(with-temp-buffer
	  (insert query "\n")
	  (unless (= (call-process-region (point-min) (point-max) notmuch-command
									  t t nil "count" "--batch") 0)
		(notmuch-logged-error "notmuch count --batch failed"
"Please check that the notmuch CLI is new enough to support `count
--batch'. In general we recommend running matching versions of
the CLI and emacs interface."))

	  (goto-char (point-min))
	  (let ((n (read (current-buffer))))
		(if (= n 0)
			nil
		  (notmuch-hello-nice-number n)))))
#+END_SRC

This function can be called like this:

#+BEGIN_EXAMPLE
(my-count-query "folder:linux-arm-kernel tag:unread")
#+END_EXAMPLE

It will return either nil or a string containing the nicely
formatted amount of messages. Note that it doesn't return the integer
0 or the string "0" but nil. I've done it so that I can easier depend
on the return value in an =(if ...)= form --- if considers "0" to be
true.

**** Create query widget

The following either inserts a ='push-button= widget (if the query has
a count associated) or some empty spaces:

#+BEGIN_SRC emacs-lisp
  ;; This is GPLv2. If you still don't know the details, read
  ;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

  (defun my-notmuch-hello-query-insert (cnt query elem)
	(if cnt
		(let* ((str (format "%s" cnt))
			   (widget-push-button-prefix "")
			   (widget-push-button-suffix "")
			   (oldest-first (case (plist-get elem :sort-order)
							   (newest-first nil)
							   (oldest-first t)
							   (otherwise notmuch-search-oldest-first))))
		  (widget-create 'push-button
						 :notify #'notmuch-hello-widget-search
						 :notmuch-search-terms query
						 :notmuch-search-oldest-first oldest-first
						 :notmuch-search-type 'tree
						 str)
		  (widget-insert (make-string (- 8 (length str)) ? )))
	  (widget-insert "        ")))
#+END_SRC

**** Binding everything together

And finally we iterate over the =notmuch-saved-searches=, get the base
query, calculate the count of total messages into =q_tot= and the
count of new messages into =q_new=. We use that information to create
the widgets accordingly.

[[./emacs-notmuch-hello.png]]

#+BEGIN_SRC emacs-lisp
  ;; This is GPLv2. If you still don't know the details, read
  ;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

  (defun my-notmuch-hello-insert-searches ()
	"Insert the saved-searches section."
	(widget-insert (propertize "New     Total      Key  List\n" 'face 'my-notmuch-hello-header-face))
	(mapc (lambda (elem)
			(when elem
			  (let* ((q_tot (plist-get elem :query))
					 (q_new (concat q_tot " AND tag:unread"))
					 (n_tot (my-count-query q_tot))
					 (n_new (my-count-query q_new)))
				(my-notmuch-hello-query-insert n_new q_new elem)
				(my-notmuch-hello-query-insert n_tot q_tot elem)
				(widget-insert "   ")
				(widget-insert (plist-get elem :key))
				(widget-insert "    ")
				(widget-insert (plist-get elem :name))
				(widget-insert "\n")
			  ))
			)
		  notmuch-saved-searches))
#+END_SRC


#+BEGIN_SRC emacs-lisp :exports none
  (defun my-notmuch-hello-reposition-after-refresh ()
	(goto-char (point-min))
	(forward-line 1))
  (add-hook 'notmuch-hello-refresh-hook #'my-notmuch-hello-reposition-after-refresh)

  (add-to-list 'notmuch-hello-sections #'my-notmuch-hello-insert-searches)

;; this is the end of use-package notmuch:
)
#+END_SRC

That's all, folks.

*** motmuch-lib
#+BEGIN_SRC emacs-lisp
(use-package notmuch-lib
  :defer t
  :config
  (setq notmuch-search-oldest-first nil)

  ;; remove poll function
  (define-key notmuch-common-keymap "G" nil)
  ;; remove search function (we already have a search field)
  (define-key notmuch-common-keymap "s" nil)
)
#+END_SRC
*** notmuch-show
#+BEGIN_SRC emacs-lisp
(use-package notmuch-show
  :defer t
  :config
  (setq notmuch-show-relative-dates nil)

  ;; remove archiving commands
  (define-key notmuch-show-mode-map "x" 'my-notmuch-export-patch)
  (define-key notmuch-show-mode-map "X" nil)  
  (define-key notmuch-show-mode-map "a" nil)  
  (define-key notmuch-show-mode-map "A" nil) 
  ; M-TAB is in use by the window manager
  (define-key notmuch-show-mode-map (kbd "M-TAB") nil)

)
#+END_SRC
*** notmuch-tag
#+BEGIN_SRC emacs-lisp
(use-package notmuch-tag
  :defer t
  :config

  ;; change "unread" into an icon
  (add-to-list 'notmuch-tag-formats
			   '("unread"
				 (notmuch-tag-format-image-data tag (notmuch-tag-tag-icon))))

  ;; hide "attachment" and "signed" properties
  (add-to-list 'notmuch-tag-formats '("attachment" (propertize tag 'invisible t)))
  (add-to-list 'notmuch-tag-formats '("signed" (propertize tag 'invisible t)))
)
#+END_SRC
*** notmuch-tree
#+BEGIN_SRC emacs-lisp
(use-package notmuch-tree
  :defer t
  :config
  (setq notmuch-tree-result-format
		'(("date" . "%12s  ")
		  ("authors" . "%-23s")
		  ((("tree" . "%s")
			("subject" . "%s"))
		   . " %-54s ")
		  ;;("tags" . "(%s)")
		  ))

  ;; view selected messages in full window instead of split-pane
  (setq notmuch-tree-show-out t)

  ;; add unread tree command
  (defun notmuch-tree-tag-thread-read ()
	"Mark whole tree as read"
	(interactive)
	(notmuch-tree-tag-thread '("-unread"))
	(notmuch-tree-refresh-view))
  (bind-key "." #'notmuch-tree-tag-thread-read notmuch-tree-mode-map)

  ;; remove archiving commands
  (define-key notmuch-tree-mode-map "a" nil)  
  (define-key notmuch-tree-mode-map "A" nil)
  ;; Use "Z" to switch back to non-tree view
  (define-key notmuch-tree-mode-map "S" nil)
  (define-key notmuch-tree-mode-map "Z" #'notmuch-search-from-tree-current-query)
  ;; M-TAB is in use by the window manager
  (define-key notmuch-tree-mode-map (kbd "M-TAB") nil)
  ;; "x" to close the tree and exit isn't needed, we have "q" for this
  (define-key notmuch-tree-mode-map "x" #'my-notmuch-export-patch)
)
#+END_SRC
*** notmuch-mua
#+BEGIN_SRC emacs-lisp
(use-package notmuch-mua
  :defer t
  :config
  (setq notmuch-mua-cite-function #'message-cite-original-without-signature)
)
#+END_SRC
** notmuch patch exporting
   :PROPERTIES:
   :TITLE:    Easy export of Linux patches from Emacs' Notmuch
   :HUGO_TAGS: Emacs, notmuch
   :HUGO_TOPICS: Emacs
   :HUGO_FILE: en/emacs-notmuch-export-patch.md
   :HUGO_DATE: [2016-06-01 11:00]
   :END:

I'm reading several Linux related mailing lists. They are full of
proposed patches, and from time to time a few of them look
interesting.

Here I present a function that makes exporting such patches simple.

#+HTML: <!--more-->

If you ever contributed a patch to Linux, you'd know that your patch
must follow some formatting rules, or it might be ignored. Some of those
rules are import for my purpose:

- if a patch isn't self, consistent, it should have some 1/4 (1 of 4)
  marking in the subject
- patches should have a [PATCH ...] tag
- patches cannot have an attachment, they must be inside the e-mail itself.
  This effectively means that I don't have to deal with MIME parts.

Here are some examples of patch subjects, just to get you an idea:

#+BEGIN_EXAMPLE
[PATCH] mmc: host: use pr_err for sdhci_dumpregs
[PATCH 3/9] clocksource/drivers/rockchip_timer: Convert init function to return error
#+END_EXAMPLE

We'll massage the subjects into some suitable file name. For this we need the
variables =subject= and =patchnum=.

But we need some more variables. Later, when I create the patch file,
I want to write some of the message properties into the file. But I
cannot call =(notmuch-...)= functions inside of
=(with-current-buffer=. And so I do that now and store it away.

#+BEGIN_SRC emacs-lisp
(defun my-notmuch-export-patch ()
  (interactive)
  (let* ((from (notmuch-show-get-from))
		 (date (notmuch-show-get-date))
		 (subject (notmuch-show-get-subject))
		 (id (notmuch-show-get-message-id))
		 (filename subject)
		 (patchnum))
#+END_SRC

The first step is to extract the patch number.

#+BEGIN_SRC emacs-lisp
	(when (string-match "\\[PATCH.+?0*\\([0-9]+\\)/[0-9]+\\]" filename)
	  (setq patchnum (string-to-number (match-string 1 filename))))
#+END_SRC

And now massage to subject to a safe and suitable filename

- remove the optional [PATCH ...] prefix
- replace everything that is nota  normal letters or digit with a dash
- convert consecutive dashes into one dash
- make sure we don't have a dash at the start
- make sure we don't have a dash at the end

#+BEGIN_SRC emacs-lisp
	(setq filename (replace-regexp-in-string "\\[PATCH.*\\]" "" filename))
	(setq filename (replace-regexp-in-string "\[^a-zA-Z0-9]" "-" filename))
	(setq filename (replace-regexp-in-string "\\-+" "-" filename))
	(setq filename (replace-regexp-in-string "^-" "" filename))
	(setq filename (replace-regexp-in-string "-$" "" filename))
#+END_SRC

Now prepend the patchnum, if we have any:

#+BEGIN_SRC emacs-lisp
	(when patchnum
	  (setq filename (concat (format "%04d" patchnum) "-" filename)))
#+END_SRC

Currently, I've hard-coded that all paths shouild be written to
=/tmp/=. Maybe you can do better?

#+BEGIN_SRC emacs-lisp
	(setq filename (concat "/tmp/" filename ".patch"))
#+END_SRC

And now we need write things out.

First we create a temporary buffer and insert some of message properties
as a header. Then we call the notmuch program and let it get us mime part
1 if the message. Because Linux patches must always be part of the body
and can't contain attachments, this is save for my needs.

The =t= as the 3rd argument to =(call-process= makes the output of the
notmuch command end in my temporary buffer.

All i then need to do is to write the buffer out and kill the temporary
buffer.

#+BEGIN_SRC emacs-lisp
	(save-excursion
	  (let ((buf (generate-new-buffer (concat "*notmuch-export-patch-" id "*"))))
		(with-current-buffer buf
		  (insert (format "Subject: %s\n" subject))
		  (insert (format "From: %s\n" from))
		  (insert (format "Date: %s\n" date))
		  (insert (format "Message-Id: %s\n\n" (substring id 3)))
		  (let ((coding-system-for-read 'no-conversion))
			(call-process notmuch-command nil t nil "show" "--part:1" id))
		  (write-file filename))
		(kill-buffer buf)))))
#+END_SRC

And the last step is to bind this to some keys. As the function works
both in tree-view and in message-show mode, I bind it to both places.

#+BEGIN_SRC emacs-lisp :tangle no
(define-key notmuch-show-mode-map "x" #'my-notmuch-export-patch)
(define-key notmuch-tree-mode-map "x" #'my-notmuch-export-patch)
#+END_SRC
* Blogging
  :PROPERTIES:
  :TITLE:    Blog from Org-Mode to Hugo
  :HUGO_TAGS: Emacs, Hugo, org-mode
  :HUGO_TOPICS: Emacs
  :HUGO_FILE: en/emacs-blog-from-org-to-hugo.md
  :HUGO_DATE: [2016-03-31 11:46]
  :END:

I use the static web-site generator [[https://gohugo.io/][Hugo]] to create my home page. I
also use [[https://www.gnu.org/software/emacs/][Emacs]] as my main editor. Hugo is good with [[https://help.github.com/categories/writing-on-github/][Markdown]]. Emacs is
good at Markdown, too. But much better with [[http://orgmode.org/][Org-Mode]].

If you want ...

- export one =.org= file as one web page, look at Giles Paterson
  [[https://vurt.co.uk/post/blogging-with-emacs-and-hugo/][solution]]
- export just a subtree of an org-file (e.g. from your org-based Emacs
  configuration), then look here.

#+HTML: <!--more-->

I wanted a nice way to publish single sub-trees of an org-file to
Hugo. So I wrote my own "publish this specific subtree" export. The
interactive function is simply called =hugo=, and I bind it to some
key combination, in my case to =Alt-g h=, g like go, and h like go. So
I type "go hugo", more or less.

** Usage

One question is how we store Hugo-specific information. So far I only
care for the title, tags, topics and, of course, the file name. As I
don't want to have one-file per blog post, but instead use subtrees of
my org-file, I need to store this information into org's property
drawers.

But writing them by hand is tedious. So I added code that ensures that
all needed properties exists. Before I started blogging this article, 
my org-mode buffer looked like this:

[[./start.png]]

Then I called the =(hugo)= function and my buffer looked like this:

[[./started.png]]

The cursor is positioned at the first empty field.

(Note that I later changed the code below from =HUGO_CATEGORIES= to
=HUGO_TOPICS=, because that's how I now have defined my taxonomy in
Hugo.)

Note that the title and date fields are pre-filled. 
You can of course change them. Only when everything is filled in ...

[[./ready.png]]

... does the export to Hugo create the markdown file with the properly
formatted TOML front matter.

** Implementation

Let's start simple. First we define where our contents should be stored:

#+BEGIN_SRC emacs-lisp
;; This is GPLv2. If you still don't know the details, read
;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

(defvar hugo-content-dir "~/www.hugo/content/"
  "Path to Hugo's content directory")
#+END_SRC

The next two functions care that all needed property drawers exist:

#+BEGIN_SRC emacs-lisp
;; This is GPLv2. If you still don't know the details, read
;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

(defun hugo-ensure-property (property)
  "Make sure that a property exists. If not, it will be created.

Returns the property name if the property has been created,
otherwise nil."
  (if (org-entry-get nil property)
	  nil
	(progn (org-entry-put nil property "")
		   property)))

(defun hugo-ensure-properties ()
  "This ensures that several properties exists. If not, these
properties will be created in an empty form. In this case, the
drawer will also be opened and the cursor will be positioned
at the first element that needs to be filled.

Returns list of properties that still must be filled in"
  (require 'dash)
  (let ((current-time (format-time-string (org-time-stamp-format t t) (org-current-time)))
		first)
	(save-excursion
	  (unless (org-entry-get nil "TITLE")
		(org-entry-put nil "TITLE" (nth 4 (org-heading-components))))
	  (setq first (--first it (mapcar #'hugo-ensure-property '("HUGO_TAGS" "HUGO_TOPICS" "HUGO_FILE"))))
	  (unless (org-entry-get nil "HUGO_DATE")
		(org-entry-put nil "HUGO_DATE" current-time)))
	(when first
	  (goto-char (org-entry-beginning-position))
	  ;; The following opens the drawer
	  (forward-line 1)
	  (beginning-of-line 1)
	  (when (looking-at org-drawer-regexp)
		(org-flag-drawer nil))
	  ;; And now move to the drawer property
	  (search-forward (concat ":" first ":"))
	  (end-of-line))
	first))
#+END_SRC

And this is the main function. It simply gathers all information from org-mode,
formats it correctly, and writes it out.

In case you have the =ox-gfm.el= elisp package is available, the
export will use "Github Flavored Markdown". Otherwise, the normal
markdown export backend will be use. The benefit of ='gfm= is that
code blocks can be highlighted.

#+BEGIN_SRC emacs-lisp
;; This is GPLv2. If you still don't know the details, read
;; http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

(defun hugo ()
  (interactive)
  (unless (hugo-ensure-properties)
	(let* ((title    (concat "title = \"" (org-entry-get nil "TITLE") "\"\n"))
		   (date     (concat "date = \"" (format-time-string "%Y-%m-%d" (apply 'encode-time (org-parse-time-string (org-entry-get nil "HUGO_DATE"))) t) "\"\n"))
		   (topics   (concat "topics = [ \"" (mapconcat 'identity (split-string (org-entry-get nil "HUGO_TOPICS") "\\( *, *\\)" t) "\", \"") "\" ]\n"))
		   (tags     (concat "tags = [ \"" (mapconcat 'identity (split-string (org-entry-get nil "HUGO_TAGS") "\\( *, *\\)" t) "\", \"") "\" ]\n"))
		   (fm (concat "+++\n"
					   title
					   date
					   tags
					   topics
					   "+++\n\n"))
		   (file     (org-entry-get nil "HUGO_FILE"))
		   (coding-system-for-write buffer-file-coding-system)
		   (backend  'md)
		   (blog))
	  ;; try to load org-mode/contrib/lisp/ox-gfm.el and use it as backend
	  (if (require 'ox-gfm nil t)
		  (setq backend 'gfm)
		(require 'ox-md))
	  (setq blog (org-export-as backend t))
	  ;; Normalize save file path
	  (unless (string-match "^[/~]" file)
		(setq file (concat hugo-content-dir file))
	  (unless (string-match "\\.md$" file)
		(setq file (concat file ".md")))
	  ;; save markdown
	  (with-temp-buffer
		(insert fm)
		(insert blog)
		(untabify (point-min) (point-max))
		(write-file file)
		(message "Exported to %s" file))
	  ))))
#+END_SRC

And finally I set my preferred key-binding with =(bind-key)=. I like
this method over over the standard keybinding methods because it works
together with =(describe-personal-keybindings)=. And because I'm
already a [use-package](https://github.com/jwiegley/use-package) user
it's already loaded anyway :-)
#+BEGIN_SRC emacs-lisp
(bind-key "M-g h" #'hugo)
#+END_SRC

** Images

In this blog post are 3 pictures. My current code does *not* copy them to
Hugo's contents directory, and I don't really plan this. I don't want to
maintain images as part of my Emacs configuration. Instead, I added text like
this into my org-mode buffer and do the rest in my Hugo setup:

#+BEGIN_EXAMPLE
[[./ready.png]]
#+END_EXAMPLE

** Separate description (teaser) from main content

In Hugo, you can separate your normal content fromt he teaser at the
top with a "<!--more-->" marker. Generate this HTML with
"#+HTML: <!--more-->" in a line by itself.

* Programming
** Tabs and indentation
*** Tab width 4
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC
*** tabify only leading whitespace
#+BEGIN_SRC emacs-lisp
(use-package tabify
  :defer t
  :commands (tabify untabify)
  :config
  ;; only initial whitespace
  (setq tabify-regexp "^\t* [ \t]+"))
#+END_SRC

*** Deleting past a tab
Deleting past a tab normally changes tab into spaces. Don't do that,
kill the tab instead.

#+BEGIN_SRC emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+END_SRC
*** RET is newline-and-indent
And if we ever need it, =C-j= is now newline.

#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)
(bind-key "C-j" 'newline)
#+END_SRC
*** Clean wrong indentation
Nice tip from tuhdo, see https://www.emacswiki.org/emacs/CleanAutoIndent
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
  :ensure t
  :commands (clean-aindent-mode)
  :config
  (add-hook 'prog-mode-hook #'clean-aindent-mode)
)
#+END_SRC
*** Guess indent mode
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
  :config
  (dtrt-indent-mode 1)
  (setq dtrt-indent-verbosity 0)
)
#+END_SRC
** Expansion
*** CANCELED yasnippet
Now try yasnippet again now that it's faster.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :if (not noninteractive)
  :defer t
  :ensure t
  :bind (("C-c C-s" . yas-insert-snippet)  ;; used in org-mode for org-schedule
		 ("C-c s"   . yas-insert-snippet))
  ;; :diminish yas-minor-mode

  :config
  (setq yas-indent-line nil)

  ;; No dropdowns please.
  (setq yas-prompt-functions '(yas-completing-prompt))

  ;; No need to be so verbose
  (setq yas-verbosity 1)

  ;; Wrap around region
  (setq yas-wrap-around-region t)

  ;; Set my own
  ;; (setq yas-snippet-dirs '((concat user-emacs-directory "yasnippet")))

  ;; This creates errors when I open ansi-term
  ;; (yas-global-mode 1)
)
#+END_SRC
*** Completion for programmers
#+BEGIN_SRC emacs-lisp
(use-package company-c-headers
  :ensure t
  :config
  (add-to-list 'company-backends 'company-c-headers)
  (add-to-list 'company-c-headers-path-system "/usr/include/qt4/qt/")
  (add-to-list 'company-c-headers-path-system "/usr/include/qt4/QtCore/")
  (add-to-list 'company-c-headers-path-system "/usr/include/qt4/QtGui/")
)
#+END_SRC
** Disable vc backends
We only use git, not other version controls:

#+BEGIN_SRC emacs-lisp
(setq vc-handled-backends nil)
#+END_SRC

** Commenting

#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" 'comment-dwim)
#+END_SRC

** CANCELED Smart parens
Cancelled till I find out how to make it do it's magic only if there
rest of the line is empty.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :defer t
  :diminish smartparens-mode
  :commands (show-smartparens-global-mode smartparens-global-mode sp-with-modes sp-local-pair)
)
(defun my-smart-parens-setup ()
  (show-smartparens-mode +1)
  (smartparens-mode 1)

  ;; when you press RET, the curly braces automatically
  ;; add another newline
  (sp-with-modes '(c-mode c++-mode)
	(sp-local-pair "{" nil
				   ;; :when '(sp-point-before-eol-p)
				   :post-handlers '(("||\n[i]"     "RET")))
	(sp-local-pair "/*" "*/"
				   ;; :when '(sp-point-before-eol-p)
				   :post-handlers '((" | "       "SPC")
									("* ||\n[i]" "RET"))))
  ;; (dolist (old-pair (cdr (assq t sp-pairs)))
  ;; 	(sp-pair (plist-get old-pair :open) nil :when '(sp-point-before-eol-p)))
  )
(add-hook 'c-mode-common-hook 'my-smart-parens-setup)
;; (add-hook 'emacs-lisp-mode-hook 'my-smart-parens-setup)
#+END_SRC
** Compilation
set initial compile-command to nothing, so that F7 will prompt for one

#+BEGIN_SRC emacs-lisp
;; Prevent from "make -k" popping up whenever I start emacs
(setq compile-command "")

(defvar compile-commands nil
  "The compile commands are an alist where the key is
   is the command and the value is the time when it was
   executed the last time. The latter is used for sorting.

   Example:

   '((\"make\" .  \"1448748904\")
	 (\"make -C ~/test\" . \"1448748866\"))")

;; automatically save our compile-commands
(add-to-list 'savehist-minibuffer-history-variables 'compile-commands)


(defun comp--sort-command-alist ()
  "Sorts compile-commands by the value of their cons elements.
   This sorts the entries so that recently used compile commands
   are near the top."

  (setq compile-commands (sort compile-commands (lambda (x y)
												  (not (string< (cdr x) (cdr y)))))))

(defun comp--add-command (cmd)
  "Adds a command to compile-commands if it isn't already in it.

  It inserts the seconds since 1970 into the value."

  ;; (message "adding command '%s'" cmd)
  (unless (string= "" cmd)
	(unless (assoc cmd compile-commands)
	  (add-to-list 'compile-commands (cons cmd (format-time-string "%s"))))))

(defun comp--del-command (cmd)
  "This deletes CMD from the compile-commands list."

  (setq compile-commands (delq (assoc cmd compile-commands) compile-commands)))
;; (setq compile-commands nil)
;; (comp--add-command "make 1")
;; (comp--add-command "make 2")
;; (comp--del-command "make 1")

(defun comp--get-compile-commands-from-buffers ()
  "Searches all open buffers that have a file-name associated
   and adds compile commands from to compile-commands. Valid
   forms for compile commands in the source code are:

   // @compile: make
   ## @compile: make
   /* @compile: make */
   (setq compile-command \"make\")"

  (save-excursion
	(goto-char (point-min))
	(while (re-search-forward "^..? @compile: \\(.*\\)$" nil t)
	  (let ((s (match-string-no-properties 1)))
		;; \s- whitespace character class
		;; (message "FOUND '%s'" s)
		(setq s (replace-regexp-in-string "\s-*\\*/$" "" s))
		(comp--del-command s)
		(comp--add-command s)))
	(goto-char (point-min))
	(while (re-search-forward "(setq compile-command \"\\(.*\\)\")" nil t)
	  (let ((s (match-string-no-properties 1)))
		;; (message "via setq '%s'" s)
		(comp--del-command s)
		(comp--add-command s)))))

(defun comp--default-action (cmd &optional _r1 _r2)
  (message "comp--default-action: '%s'" cmd)
  (when cmd
  	(comp--add-command cmd)
  	(setq compile-command cmd)
	(comp--compile)))

(defun comp--del-action (cmd)
  "This deletes CMD from the compile-commands list and clears compile-command if needed."

  (message "comp--del-action: '%s'" cmd)
  (comp--del-command cmd)
  (when (string= compile-command cmd)
	(setq compile-command nil)))

(defun helm-compile-command ()
  "Interactively select a compile-command.

   Releads possible commends from open buffers when run with argument."

  (interactive)

  ;; Always get list of compilation commands and sort them
  (comp--get-compile-commands-from-buffers)
  (comp--sort-command-alist)
  ;; compile-commands is now something like:
  ;; '(("make -C foo" . 1) ("ccmake && make" . 2))

  (let ((cmds (helm-build-sync-source "Select compile command"
				:candidates (delq "" (mapcar 'car compile-commands))
				:action '(("Run"    . comp--default-action)
						  ("Delete" . comp--del-action))
				:mode-line "F1 run, F2 delete"
				))
		(dummy (helm-build-dummy-source "Or enter new command ..."
				 :mode-line ""
				 :action #'comp--default-action)))
	(helm :sources '(cmds dummy)
		  :buffer "*helm compile command*"
		  :prompt "cmd: ")))

(bind-key "S-<f7>" #'helm-compile-command)

(defun comp--compile ()
  (interactive)
  (delete-other-windows)
  (save-buffer)
  (if (string= compile-command "")
	  (helm-compile-command)
	;; (message "compile command: %s" compile-command)
	(let ((cmd (assoc compile-command compile-commands)))
	  (when cmd
		;; (message "assoc: %s" (assoc compile-command compile-commands))
		(setcdr cmd (format-time-string "%s"))
		;; (message "assoc: %s" (assoc compile-command compile-commands))
		))
	(if (string= (substring compile-command 0 1) "(")
		(eval (car (read-from-string compile-command)))
	  (progn
		(let ((default-directory (or (magit-get-top-dir) default-directory)))
		  (compile compile-command))))))
(bind-key "<f7>" 'comp--compile)
#+END_SRC

** Auto close compile log if there are no errors
[[http://www.emacswiki.org/emacs/ModeCompile]]

#+BEGIN_SRC emacs-lisp
(defun compile-autoclose (buffer string)
  (when (string-match "finished" string)
	(delete-window (get-buffer-window buffer t))
	(bury-buffer-internal buffer)))
(use-package compile
	:diminish compilation-in-progress
	:config
	(setq compilation-finish-functions 'compile-autoclose)
	(setq compilation-ask-about-save nil)
	(setq compilation-scroll-output t))
#+END_SRC

** Error navigation
#+BEGIN_SRC emacs-lisp
(bind-key "<f8>" 'next-error)
(bind-key "S-<f8>" 'previous-error)
#+END_SRC
** Make files with shebang executable
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Mode: C, C++
*** Open *.h files normally in c++ mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.h$" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-mode))
#+END_SRC

*** C initialization
Somehow a the first visited file stays in "gnu" style when I set the c-default-style
just in the common hook

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'cc-vars))
(defun my-c-initialization-setup ()
  ;; Default style
  (c-add-style "linux-tabs-only"
		   '("linux" (c-offsets-alist (arglist-cont-nonempty
					   c-lineup-gcc-asm-reg
					   c-lineup-arglist-tabs-only))))
  (setq c-default-style '((java-mode . "java")
						  (awk-mode . "awk")
						  (other . "linux")))
)
(add-hook 'c-initialization-hook 'my-c-initialization-setup)
#+END_SRC

*** c-mode-hook (for C files)
Things that will only ever apply to .C files

#+BEGIN_SRC emacs-lisp
(defun my-c-mode-setup ()
  (when (and buffer-file-name
				 (string-match "linux" buffer-file-name))
	(progn (c-set-style "linux-tabs-only")
	   (setq tab-width 8
		 c-basic-offset 8))))
(add-hook 'c-mode-hook 'my-c-mode-setup)
#+END_SRC

*** c-mode-common-hook (for C and C++ files)
Things that will apply to .C and .CPP files

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'cc-engine))
(defun my-c-mode-common-setup ()
  (turn-off-auto-fill)

  ;; This makes things like super_function_for_you a word
  (modify-syntax-entry ?_ "w")
  (setq fill-column 78
	;; indent by 4 (almost) everywhere
	tab-width 4
	c-basic-offset 4

	;; Let RET break and continue a comment
	;; C doesn't start functions with a ( in the first column
	open-paren-in-column-0-is-defun-start nil

	;; Tell cc-mode not to check for old-style (K&R) function
	;; declarations. This speeds up indenting a lot (I hear).
	c-recognize-knr-p nil)
  )
(add-hook 'c-mode-common-hook 'my-c-mode-common-setup)
#+END_SRC

*** from linux/Documentation/CodingStyle, used in coding style "linux-tabs-only"

#+BEGIN_SRC emacs-lisp
(defun c-lineup-arglist-tabs-only (ignored)
  "Line up argument lists by tabs, not spaces"
  (let* ((anchor (c-langelem-pos c-syntactic-element))
		 (column (c-langelem-2nd-pos c-syntactic-element))
		 (offset (- (1+ column) anchor))
		 (steps (floor offset c-basic-offset)))
	(* (max steps 1)
	   c-basic-offset)))

(defun my-c-electric-brace-open (arg)
  "This just inserts the spaces, a newline, and indents into the
newline to the correct position"
  (interactive "*P")
  (self-insert-command (prefix-numeric-value arg))
  (newline-and-indent))
#+END_SRC
*** CANCELED c-syntactic-element?
#+BEGIN_SRC emacs-lisp
(defvar c-syntactic-element)
(eval-when-compile (require 'cc-mode))
#+END_SRC
** Mode: Ediff
http://oremacs.com/2015/01/17/setting-up-ediff/

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :commands (ediff-setup-keymap)
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")
  (defun my--ediff-hook ()
	(ediff-setup-keymap)
	(bind-key "j" 'ediff-next-difference ediff-mode-map)
	(bind-key "k" 'ediff-previous-difference ediff-mode-map))
  (add-hook 'ediff-mode-hook 'my--ediff-hook)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo))
#+END_SRC

** TODO Mode: ELisp

#+BEGIN_SRC emacs-lisp
(defun my--elisp-setup ()
  ;; Setup imenu TODO
  (add-to-list 'imenu-generic-expression '(""  "^;;;_ \\(.*\\)" 1) t)
  ;; automatically give help about function syntax
  (eldoc-mode t)
  ;; "-" is almost always part of a function- or variable-name
  (modify-syntax-entry ?- "w")
  ;; TODO
  ;; (unless (string= (buffer-name) "*scratch*")
  ;;   (auto-compile-mode 1))
  )
(add-hook 'emacs-lisp-mode-hook 'my--elisp-setup)
#+END_SRC

** Mode: Go
#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t
  :defer t
)
#+END_SRC
** Mode: JS2-Mode
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :mode ("\\.js\\'" . js2-mode)
  :interpreter ("node" . js2-mode)
  :config
  (setq js2-basic-offset 2
	js2-highlight-level 3)
  ;; we can run a nodejs REPL locally or over TRAMP, and it works out-of-the-box!
  (defalias 'run-node 'nodejs-repl)
)
#+END_SRC
** Mode: lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :ensure t
  :init
  ;; normally long lines get the same face as comments, which is quite irritating
  (defun my-lua-hook ()
	(setq-local whitespace-line-column 132))
  (add-hook 'lua-mode-hook #'my-lua-hook)
)
#+END_SRC
** Mode: Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode (("\\.md\\'"       . markdown-mode)
	 ("\\.markdown\\'" . markdown-mode)))
#+END_SRC

** Mode: Python

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'python))
(defun my-python-setup ()
  (interactive)
  (setq indent-tabs-mode t
	python-indent-offset 4
	tab-width 4
	;; this fixes the weird indentation when entering a colon
	;; from http://emacs.stackexchange.com/questions/3322/python-auto-indent-problem
	electric-indent-chars (delq ?: electric-indent-chars)))
(add-hook 'python-mode-hook 'my-python-setup)
#+END_SRC
** Mode: Qt project files
From  https://raw.githubusercontent.com/chriskonstad/emacs/master/elisp/qt-pro.el
#+BEGIN_SRC emacs-lisp
(use-package qt-pro
  :defer t
  :commands (qt-pro-mode)
  :mode ("\\.pr[io]\\'" . qt-pro-mode)
)
#+END_SRC

** Mode: Rust

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :mode (("\\.rs\\'" . rust-mode)))
#+END_SRC

** Mode: Shell

#+BEGIN_SRC emacs-lisp
(defun my-shell-tab-setup ()
  (interactive)
  (setq indent-tabs-mode t)
  (setq tab-width 4)
  (setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84))
  (bind-key "C-i" 'self-insert-command text-mode-map))
(add-hook 'shell-mode-hook 'my-shell-tab-setup)
(add-hook 'sh-mode-hook    'my-shell-tab-setup)
#+END_SRC

** Mode: web-mode
Home page: http://web-mode.org/

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :commands (web-mode web-mode-guess-engine-and-content-type)
  :mode (("\\.html\\'" . web-mode)
		 ("\\.css\\'"  . web-mode)
		 ("\\.scss\\'" . web-mode)
		 ("\\.json\\'" . web-mode)
		 )
  :defines (web-mode-engines-alist)
  :config
  (unless (car (car (last web-mode-engines-auto-pairs)))
	(setq web-mode-engines-auto-pairs (butlast web-mode-engines-auto-pairs)))
  (defun my-web-mode-hook ()
	(visual-line-mode 1)
	(setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 4
		  web-mode-code-indent-offset 2
		  web-mode-indent-style 2
		  web-mode-style-padding 1
		  web-mode-script-padding 1
		  web-mode-block-padding 0
		  indent-tabs-mode t
		  tab-width 4
		  web-mode-engines-alist '(("go" . "\\.html\\'")))
	(web-mode-guess-engine-and-content-type)
	)
  (add-hook 'web-mode-hook 'my-web-mode-hook)
)
#+END_SRC

** Mode: whitespace
Here we set =C-c w= and =C-c C-w= to whitespace-mode. Note that the
former used to be subword-mode, but I rarely want to move by subwords.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :defer t
  :bind ("C-c w" . whitespace-mode)
)
#+END_SRC
** Package: ansi-term
This term understands ansi escape sequences.

On Debian, one should install the =ansi-term= debian package so that
the terminal "eterm-color" is available.

#+BEGIN_SRC emacs-lisp
(use-package ansi-term
  :bind ("M-g a" . ansi-shell)
  :commands (ansi-term ansi-shell
					   term-in-line-mode
					   term-line-mode
					   term-char-mode)
  :defines (term-buffer-maximum-size
			ml-interactive?
			show-dir-in-mode-line?)
  :init
  (defun ansi-shell ()
	"Start ansi-term with bash"
	(interactive)
	(ansi-term "/bin/bash"))
  :config

  ;; don't linger around when closing
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
	(if (memq (process-status proc) '(signal exit))
		(let ((buffer (process-buffer proc)))
		  ad-do-it
		  (kill-buffer buffer))
	  ad-do-it))
  (ad-activate 'term-sentinel)

  (defun term-toggle-mode ()
	(interactive)
	(if (term-in-line-mode)
		(term-char-mode)
	  (term-line-mode)))

  (defun my-term-hook ()
	(goto-address-mode)
	;; (bind-key "C-c C-j" #'term-toggle-mode term-mode-map)
	;; (bind-key "C-c C-k" #'term-toggle-mode term-mode-map)
	(setq global-hl-line-mode nil)
	(setq term-buffer-maximum-size 10000)
	(setq-local ml-interactive? t) ;; for mode line
	(setq-local show-dir-in-mode-line? t) ;; also mode linec'
	(setq show-trailing-whitespace nil)
	;; disable company in favor of shell completion
	;;(company-mode -1)
	)
  (add-hook 'term-mode-hook 'my-term-hook)
)
#+END_SRC
** Package: column-marker

#+BEGIN_SRC emacs-lisp
(use-package column-marker
  :ensure t
  :commands (column-marker-1 column-marker-2)
  :init
  (defun my--column-marker-at-80 ()
	(interactive)
	(column-marker-2 80))
  (add-hook 'c-mode-hook 'my--column-marker-at-80)
  )
#+END_SRC

** CANCELED Package: auto-compile

#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :ensure t
  :config
  (auto-compile-on-load-mode 1)
  (auto-compile-on-save-mode 1)
  )
#+END_SRC

** Package: eshell
https://www.masteringemacs.org/article/complete-guide-mastering-eshell

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :defer t
  :bind ("M-g e" . eshell)
  :commands (eshell/addpath eshell-read-aliases-list)
  :defines (eshell-visual-commands)
  :config
  (defun eshell/clear ()
	"Deletes the contents of eshell buffer, except the last prompt"
	(save-excursion
	  (goto-char eshell-last-output-end)
	  (let ((lines (count-lines 1 (point)))
		(inhibit-read-only t))
	(beginning-of-line)
	(let ((pos (point)))
	  (if (bobp)
		  (if (called-interactively-p 'interactive)
			  (error "Buffer too short to truncate"))
		(delete-region (point-min) (point)))))))

  ;; We don't need no banner
  (setq eshell-banner-message "")

  ;; If I ever want my own eshell/foo commands overwrite real commands ...
  (setq eshell-prefer-lisp-functions t)

  ;; check if this is ok for my usage
  ;; eshell-visual-commands
 
  (defun my--eshell-hook ()
	(eshell-read-aliases-list)
	(setq global-hl-line-mode nil)
	(setq show-trailing-whitespace nil)
	(add-to-list 'eshell-visual-commands "ssh")
	(add-to-list 'eshell-visual-commands "htop")
	(add-to-list 'eshell-visual-commands "ncmpcpp")
	(add-to-list 'eshell-visual-commands "tail")
	(setq-local ml-interactive? t) ;; for mode line
	(eshell/addpath "~/bin"))
  (add-hook 'eshell-mode-hook 'my--eshell-hook)
)
#+END_SRC

** Package: magit
Must be set before magit is loaded. It will remove the new key
bindings that use pop-up buffers.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :diminish magit-auto-revert-mode  ;; disable "MRev" in the status line
  :defines (magit-rigid-key-bindings)
  :commands (magit-get-top-dir)
  :bind ("M-g m" . magit-status)
  :init
  ;; disable warning about magit-auto-revert-mode
  (setq magit-last-seen-setup-instructions "1.4.0")
  (setq magit-rigid-key-bindings t)
  :config
  ;; Save modified buffers without asking
  (setq magit-save-some-buffers 'dontask)
  ;; (setq magit-commit-all-when-nothing-staged nil)
  (setq magit-stage-all-confirm nil)
  (setq magit-unstage-all-confirm nil)
  ;; switch the current window to magit-status (was pop-to-buffer)
  (setq magit-status-buffer-switch-function 'switch-to-buffer)
  ;; (setq magit-refresh-file-buffer-hook '(revert-buffer))
  (setq magit-use-overlays nil)
  (setq magit-item-highlight-face nil)
  (setq magit-completing-read-function 'completing-read)
  ;; (set-face-foreground 'magit-diff-add "green4")
  ;; (set-face-foreground 'magit-diff-del "red3")
)
#+END_SRC

** Package: magit-timemachine

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands git-timemachine
  )
#+END_SRC
** Package: rainbow-mode
Rainbow-mode turns color codes inside the editor into real colors.
Nice for elisp faces or CSS files.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :defer t
  :commands (rainbow-mode)
)
#+END_SRC
** Package: semantic
#+BEGIN_SRC emacs-lisp
(use-package semantic
  :defer t
  :config

  ;; maybe set semantic-default-submodes
)
#+END_SRC
