#+TITLE: Holger's Emacs Startup File
#+SEQ_TODO: TODO DISABLED | DONE
#+OPTIONS: H:2 num:nil toc:t
#+STARTUP: oddeven
#+STARTUP: overview

* Debugging

#+BEGIN_SRC emacs-lisp
;; Provide a useful error trace if loading this monster fails
					;(setq debug-on-error t)
(defun debug-on-error ()
  "Turn on debug on error"
  (interactive)
  (setq debug-on-error t))
#+END_SRC

* Mode: C, C++

#+BEGIN_SRC emacs-lisp
;; Tabs mode
(setq indent-tabs-mode t)

;; Silence byte-compiler
(require 'cc-mode)


(defun my-c-mode-common-setup ()
  (define-key c-mode-map (kbd "RET") 'newline)
  (turn-off-auto-fill)
  (c-toggle-auto-newline 1)
  (modify-syntax-entry ?_ "w")
  ;; c-mode overrides the global newline-and-indent. Strangely,
  ;; cc-mode keeps the global. We don't care, we always set it :-)
  (local-set-key (kbd "RET") 'newline-and-indent)
  (setq fill-column 76
	;; Let RET break and continue a comment
	;; C doesn't start functions with a ( in the first column
	open-paren-in-column-0-is-defun-start nil
	;; Insert TABs inside literals
	c-tab-always-indent 1
	;; Tell cc-mode not to check for old-style (K&R) function
	;; declarations. This speeds up indenting a lot (I hear).
	c-recognize-knr-p nil
	;; Jump to errors, please
	compilation-auto-jump-to-first-error t
	;; Turn of elect, TODO: consider hungry-delete
	c-electric-flag nil
	;; But if it's on, let a "#" go to the left, for #if/#else/#endif
	c-electric-pound-behavior '(alignleft)
	;; No abbrevs
	abbrev-mode nil
	;; Preferred tab width
	tab-width 4
	c-basic-offset 4
	;; Default style
	c-default-style '((java-mode . "java")
			  (awk-mode . "awk")
			  (other . "linux"))
	)
  )
(add-hook 'c-mode-common-hook 'my-c-mode-common-setup)

;; Search .obj dir as well:
(require 'find-file)
(add-to-list 'cc-search-directories ".obj")
(add-to-list 'cc-search-directories "..")



(defun my-format-buffer ()
  (interactive)
  (delete-trailing-whitespace)
  (indent-region 0 (buffer-size) nil)
  (tabify 0 (buffer-size)))
#+END_SRC

* Mode: CSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :mode "\\.[Cc][Ss][Vv]\\'")
#+END_SRC

* Mode: D

#+BEGIN_SRC emacs-lisp
(use-package d-mode
  :mode "\\.d[i]?\\'")
#+END_SRC

* Mode: Diff

#+BEGIN_SRC emacs-lisp
(defun my-diff-mode-hook ()
    (setq show-trailing-whitespace t)
    (setq def-file-header '((t nil)))
    (setq def-header '((t nil))))

(use-package diff-mode
  :config (progn
	    (add-hook 'diff-mode-hook 'my-diff-mode-hook)
	    (setq diff-switches "-u")))
#+END_SRC

* Mode: Dired

#+BEGIN_SRC emacs-lisp
(use-package dired
  :commands dired
  :config (setq dired-auto-revert-buffer t)
  :bind ("\C-x\C-d" . ido-dired)  ;;ORIGINAL: list-directory
)
#+END_SRC

* Mode: Generic-X

#+BEGIN_SRC emacs-lisp
(require 'generic-x)
#+END_SRC

* Mode: Info

#+BEGIN_SRC emacs-lisp
;; (add-to-list 'Info-default-directory-list (concat dotfiles-dir "info"))

(defun my-next-link-or-scroll-page-forward (next-point)
  "Scroll one page forward when no more next links on the current page."

  (if (and (> (window-end) next-point) (> next-point (point)))
      (goto-char next-point)
    (if (>= (window-end) (point-max))
        (goto-char (point-max))
      (progn (View-scroll-page-forward-set-page-size) (move-to-window-line 0)))))

(defun my-prev-link-or-scroll-page-backward (prev-point)
  "Scroll one page backward when no more previous links on the current page."

  (if (and (< (window-start) prev-point) (< prev-point (point)))
      (goto-char prev-point)
    (if (<= (window-start) (point-min))
        (goto-char (point-min))
      (progn (View-scroll-page-backward-set-page-size)))))

(eval-after-load "info"
  '(progn
     ;; TRY:
     (add-hook 'Info-selection-hook (lambda () (recenter 45)))
     ;; Keys
     (define-key Info-mode-map "\M-s" 'Info-search-next) ; obsoleted by C-M-s
     ;; Mozilla-like navigation:
     (define-key Info-mode-map [(meta right)] 'Info-follow-nearest-node)
     (define-key Info-mode-map [(meta left)]  'Info-last)
     (define-key Info-mode-map [(tab)]  'Info-next-reference)
     (define-key Info-mode-map [(shift tab)] 'Info-prev-reference)
     (define-key Info-mode-map [(shift iso-lefttab)] 'Info-prev-reference)
					;(define-key Info-mode-map [(shift f7)] (lambda () (interactive) (Info-search (car Info-search-history))))
     ;; Lynx-like navigation:
     (define-key Info-mode-map [(meta up)]
       (lambda ()
         (interactive)
         (my-prev-link-or-scroll-page-backward
          (save-excursion
            (ignore-errors
	     (Info-prev-reference))
            (point)))))
     (define-key Info-mode-map [(meta down)]
       (lambda ()
         (interactive)
         (my-next-link-or-scroll-page-forward
          (save-excursion
            (ignore-errors
	     (Info-next-reference))
            (point)))))
     ;; more/less scrolling style
     ;;(define-key Info-mode-map [return] 'View-scroll-line-forward)
     ))

;; Open Info-Screen in extra frame
(defadvice info (before info activate)
  (select-frame (make-frame))
  )
#+END_SRC

* Mode: Lisp

#+BEGIN_SRC emacs-lisp
(defun my-reindent-then-newline-and-indent-and-indent-sexp ()
  "Reindent current line, insert newline, then indent the new line.
Move backward out of one level of parentheses.
Indent each line of the list starting just after point."
  (interactive "*")
  (reindent-then-newline-and-indent)
  (save-excursion
    (backward-up-list)
    (indent-sexp)))

(defun my-join-line-and-indent-sexp ()
  "Join this line to previous and fix up whitespace at join.
Move backward out of one level of parentheses.
Indent each line of the list starting just after point."
  (interactive "*")
  (join-line)
  (save-excursion
    (backward-up-list)
    (indent-sexp)))

(defun my-join-line-and-indent-sexp-or-backward-kill-word ()
  "If point is on the whitespaces at the beginning of a line,
then join this line to previous and indent each line of the upper list.
Otherwise, kill characters backward until encountering the end of a word."

  (interactive "*")
  (if (save-excursion (and (skip-chars-backward " \t") (bolp)))
      (my-join-line-and-indent-sexp)
    (backward-kill-word 1)))

(define-key lisp-mode-map [(control return)] 'my-reindent-then-newline-and-indent-and-indent-sexp)
(define-key lisp-mode-map [(control backspace)] 'my-join-line-and-indent-sexp-or-backward-kill-word)
;;(tempo-define-template "lisp-print-map" '("(map (lambda (x) ) " p ")"))
;;(define-key lisp-mode-map "\C-zim" 'tempo-template-lisp-print-map)
(define-key emacs-lisp-mode-map [(control return)] 'my-reindent-then-newline-and-indent-and-indent-sexp)
(define-key emacs-lisp-mode-map [(control backspace)] 'my-join-line-and-indent-sexp-or-backward-kill-word)
;(define-key emacs-lisp-mode-map [(control meta tab)] 'lisp-complete-symbol)
(define-key emacs-lisp-mode-map "\C-ze\t" 'lisp-complete-symbol)
(define-key emacs-lisp-mode-map "\C-xF"  'find-function)
(define-key emacs-lisp-mode-map "\C-x4F" 'find-function-other-window)
(define-key emacs-lisp-mode-map "\C-x5F" 'find-function-other-frame)
(define-key emacs-lisp-mode-map "\C-xK"  'find-function-on-key)
(define-key emacs-lisp-mode-map "\C-xV"  'find-variable)
(define-key emacs-lisp-mode-map "\C-x4V" 'find-variable-other-window)
(define-key emacs-lisp-mode-map "\C-x5V" 'find-variable-other-frame)
;;(tempo-define-template "emacs-lisp-print-message" '("(message \"%s\" " p ")"))
;;(define-key emacs-lisp-mode-map "\C-zim" 'tempo-template-emacs-lisp-print-message)
;;(tempo-define-template "emacs-lisp-print-defun" '("(defun " p " ()\n  (interactive)\n\n)\n"))
;;(define-key emacs-lisp-mode-map "\C-zid" 'tempo-template-emacs-lisp-print-defun)
;;(tempo-define-template "lisp-print-map" '("(map (lambda (x) ) " p ")"))
;;(define-key lisp-interaction-mode-map "\C-zim" 'tempo-template-emacs-lisp-print-message)
(define-key lisp-interaction-mode-map [(control return)] 'my-reindent-then-newline-and-indent-and-indent-sexp)
(define-key lisp-interaction-mode-map [(control backspace)] 'my-join-line-and-indent-sexp-or-backward-kill-word)
;(define-key lisp-interaction-mode-map [(control meta tab)] 'lisp-complete-symbol)

;; gimmick: replace lambda with the greek Lambda symbol
;; (font-lock-add-keywords
;;  nil `(("\\<lambda\\>"
;;         (0 (progn (compose-region (match-beginning 0) (match-end 0)
;;                                   ,(make-char 'greek-iso8859-7 107))
;;                   nil)))))

(eval-after-load "scheme"
  '(progn
     (define-key scheme-mode-map [(control return)] 'my-reindent-then-newline-and-indent-and-indent-sexp)
     (define-key scheme-mode-map [(control backspace)] 'my-join-line-and-indent-sexp-or-backward-kill-word)))
#+END_SRC

* Mode: Javascript (js2-mode)

The rename-modeline macro is from http://whattheemacsd.com/appearance.el-01.html#disqus_thread

#+BEGIN_SRC emacs-lisp
(defmacro rename-modeline (package-name mode new-name)
  `(eval-after-load ,package-name
     '(defadvice ,mode (after rename-modeline activate)
        (setq mode-name ,new-name))))

(use-package js2-mode
  :mode
  ("\\.js$" . js2-mode)
  :init
  (rename-modeline "js2-mode" js2-mode "js2")
)

;; auto-mode-alist
#+END_SRC

* Mode: Lua

#+BEGIN_SRC emacs-lisp
(autoload 'lua-mode "lua-mode" "Lua editing mode." t)
(add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
(add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
#+END_SRC

* Mode: Man

#+BEGIN_SRC emacs-lisp
(eval-after-load "man"
  '(progn
     ;; Mozilla-like navigation:

     (define-key Man-mode-map [(meta right)] 'man-follow)
     (define-key Man-mode-map [(meta left)] 'quit-window)
     ;; Lynx-like navigation:
     (define-key Man-mode-map [(meta up)]
       (lambda ()
	 (interactive)
	 (my-prev-link-or-scroll-page-backward
	  (save-excursion
	    (ignore-errors (Man-previous-section 1))
	    (point)))))
     (define-key Man-mode-map [(meta down)]
       (lambda ()
	 (interactive)
	 (my-next-link-or-scroll-page-forward
	  (save-excursion

	    (ignore-errors (Man-next-section 1))
	    (point)))))
     (define-key Man-mode-map [f2] 'toggle-truncate-lines)
     ;; (define-key view-mode-map [tab] 'other-window) ; used for next-ref
     ;; more/less scrolling style
     (define-key Man-mode-map [return] 'View-scroll-line-forward)))
#+END_SRC

* Mode: Org

- http://orgmode.org/worg/org-tutorials/orgtutorial_dto.php
- http://thread.gmane.org/gmane.emacs.orgmode/4832
- http://www.newartisans.com/2007/08/using-org-mode-as-a-day-planner.html

#+BEGIN_SRC emacs-lisp
(eval-after-load "org"
  '(progn (setq org-directory (file-truename (concat dotfiles-dir "org/"))
		org-default-notes-file (concat org-directory "notes.org")
		;;org-agenda-files (list (concat org-directory "agenda.org") org-default-notes-file)
		org-agenda-files (list (concat org-directory "agenda.org"))

		;; Add a space before the elipsis
		org-ellipsis " ..."

		;; Store notes at beginning of file
		org-reverse-note-order t

		;; always use shift select
		;;org-support-shift-select t

		;; Follow a link with just return
		org-return-follows-link t

		;; No need to add a DONE log entry, as our #+TODO: line makes a
		;; log entry anyway. For the same reason, don't add a closed-
		;; string either.
		org-log-done 'nil
		;; org-closed-string ""

		;; Assumes you have "#+STARTUP: customtime" in your *.org file
		;; or you can alternative set "org-display-custom-times t"
		org-time-stamp-custom-formats '("<%d.%m.%Y %a>" . "<%d.%m.%Y %a %H:%M>")
		org-display-custom-times t

		;; Only allow parents to be marked done when all childrens are done:
		;; http://orgmode.org/manual/TODO-dependencies.html#TODO-dependencies
		org-enforce-todo-dependencies t
		org-enforce-todo-checkbox-dependencies t

		;; Initial visibility
		org-startup-folded 'content

		;; Fontify code blocks
		org-src-fontify-natively t
		org-src-tab-acts-natively t
		)
	  (add-hook 'org-mode-hook 'auto-fill-mode)
     ))

(autoload 'org-mode "org" "Org mode" t)
(autoload 'org-diary "org" "Diary entries from Org mode")
(autoload 'org-store-link "org" "Store a link to the current location" t)

(add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
#+END_SRC

Key-Bindings

#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cl" 'org-store-link)
;; ORIGINAL: undefined
#+END_SRC

** Mode: Org-Agenda

#+BEGIN_SRC emacs-lisp
(eval-after-load "org-agenda"
  '(progn (setq	;; Include diary entries
		org-agenda-include-diary t

		;; Opening/closing .the agenda
		;; org-agenda-restore-windows-after-quit t
		org-agenda-window-setup 'current-window

		;; Skip done items
		org-agenda-skip-deadline-if-done t
		org-agenda-skip-scheduled-if-done t

		;; Let agenda starts on the current day
		org-agenda-start-on-weekday nil

		;; For C-c a #
		org-stuck-projects
		'("+LEVEL=2-CATEGORY=\"Notes\""
		  ;; TODO-keyword identifying non-stuck projects:
		  ("TODO" "DONE" "CANCELLED")
		  ;; Tags identifying non-stuck projects:
		  nil
		  ;; Arbitrary reg-exp identifying non-stuck projects:
		  "")

		;; Some special view to select from after C-c a
		;; (key desc type match settings files)
		org-agenda-custom-commands
		'(("f" "Finished" todo "DONE|CANCELLED" nil)
		  ("w" "Waiting" todo "BLOCKED|FORWARD|FEEDBACK" nil)
		  ("3" "next 3 weeks" agenda "" ((org-agenda-ndays 21)))
		  ("u" "unscheduled" alltodo ""
		   ((org-agenda-skip-function
		     (lambda ()
		       (org-agenda-skip-entry-if 'scheduled
						 'deadline
						 'regexp "<[^>\n]+>"
						 ))))))

		)
	  (define-key org-agenda-mode-map "\C-ct" 'org-agenda-todo)
	  ;; ORIGINAL: undefined
	  (define-key org-agenda-mode-map "\C-cs" 'org-agenda-schedule)
	  ;; ORIGINAL: undefined
	  (define-key org-agenda-mode-map "\C-ce" 'org-agenda-set-effort)
	  ;; ORIGINAL: undefined
	  (define-key org-agenda-mode-map "\C-ci" 'org-agenda-clock-in)
	  ;; ORIGINAL: undefined
	  (define-key org-agenda-mode-map "\C-co" 'org-agenda-clock-out)
	  ;; ORIGINAL: undefined
	  (define-key org-agenda-mode-map "\C-cw" 'org-agenda-refile)
	  ;; ORIGINAL: undefined
     ))


(autoload 'org-agenda "org-agenda" "Multi-file agenda from Org mode" t)
#+END_SRC

Key-Bindings

#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-ca" 'org-agenda)
;; ORIGINAL: undefined
#+END_SRC

** Mode: Org-Faces

Normally the levels are colored in many different colors. These
definitions make them all blue.

#+BEGIN_SRC emacs-lisp
(eval-after-load "org-faces"
  '(progn (set-face-attribute 'org-level-1 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-2 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-2 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-3 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-4 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-5 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-6 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-7 nil :foreground "Blue1" :weight 'bold)
	  (set-face-attribute 'org-level-8 nil :foreground "Blue1" :weight 'bold)
	  ))
#+END_SRC

** Mode: Org-List

#+BEGIN_SRC emacs-lisp
(eval-after-load "org-list"
  '(progn (setq ;; Only use "1.", "2." for ordered lists, not "1)", "2)" etc
		org-plain-list-ordered-item-terminator ?.)
	  ))
#+END_SRC

** Mode: Org-Remember

#+BEGIN_SRC emacs-lisp
(eval-after-load "org-remember"
  '(progn (setq org-remember-templates
		;; List elements:
		;;   single name
		;;   character
		;;   template
		;;     %?  After completing the template, position cursor here.
		;;     %t  time stamp, date only (%u but inactive date)
		;;   optional file
		;;   optional headline: under which headline to file the new entry
		;;   optional context
		'(("TODO"
		   ?t
		   "* TODO %?\n  - State \"TODO\"       %u"
		   "agenda.org"
		   "Tasks")
		  )

		)
	  (org-remember-insinuate)
	  ))

(autoload 'org-remember "org-remember" "Remember something" t)

(define-key global-map "\C-cr" 'org-remember)
;; ORIGINAL: undefined
#+END_SRC

** Mode: Org-Src

http://orgmode.org/manual/Editing-source-code.html#Editing-source-code

#+BEGIN_SRC emacs-lisp
(eval-after-load "org-src"
  '(progn (setq ;; don't add two spaces after editing into the source block
	        org-src-preserve-indentation t

		;; Don't reorganize the frames when calling the editor
		org-src-window-setup 'current-window
		)

	  ;; Also exit with C-c C-c
	  (define-key org-src-mode-map "\C-c\C-c" 'org-edit-src-exit)
	  ))
#+END_SRC

* Mode: Perl

#+BEGIN_SRC emacs-lisp
;; Use cperl mode instead of perl mode
(fset 'perl-mode 'cperl-mode)

;; (add-to-list
;;TODO  'auto-insert-alist
;;  '(cperl-mode
;;    nil
;;    "#!/usr/bin/perl -w" \n
;;    "# -*- Perl -*-" \n
;;    ;; "# \$Id\$" \n
;;
;;    ;; "# \$RCSfile\$\$Revision\$\$Date\$" \n
;;    "# \$Revision\$" \n
;;    \n
;;    "while (<>) {" \n
;;    > "chomp;" \n
;;    > _ \n
;;    > "print \"$_\\n\";\n"
;;    "}\n"))

;; (eval-after-load "cperl-mode"
;;   '(progn
;;      ;; (define-auto-insert 'cperl-mode (lambda () (tempo-template-perl-skeleton)))
;;      (define-key cperl-mode-map "\C-ziw" 'tempo-template-perl-while-skeleton)
;;      (define-key cperl-mode-map "\C-zip" 'tempo-template-perl-print-skeleton)
;;      (define-key cperl-mode-map "\C-zis" 'tempo-template-perl-s-skeleton))
;;
;; (tempo-define-template "perl-skeleton" '("#!/usr/bin/perl -w\n# -*- Perl -*-\n# \$Revision\$\n\nwhile (<>) {\n  chomp;\n  " p "\n}\n"))
;; (tempo-define-template "perl-s-skeleton" '("s/" p "//;"))
;; (tempo-define-template "perl-print-skeleton" '("print \"$_" p "\\n\";"))
;; (tempo-define-template "perl-while-skeleton" '("while (<>) {\n  chomp;\n  " p "\n}\n"))
#+END_SRC

* Mode: Python

#+BEGIN_SRC emacs-lisp
(defun my-tab-setup ()
  (interactive)
  (setq indent-tabs-mode t
	tab-width 4
	python-indent-offset 4
	python-indent-guess-indent-offset t))
(add-hook 'python-mode-hook 'my-tab-setup)
#+END_SRC

* Mode: Shell

#+BEGIN_SRC emacs-lisp
(defun my-shell-tab-setup ()
  (interactive)
  (setq indent-tabs-mode t
	tab-width 4
	tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84))
  (define-key text-mode-map "\C-i" 'self-insert-command)
  )

(add-hook 'shell-mode-hook 'my-shell-tab-setup)
(add-hook 'sh-mode-hook 'my-shell-tab-setup)
#+END_SRC

* Mode: Term

#+BEGIN_SRC emacs-lisp
(eval-after-load "term"
  '(progn
     (add-hook 'term-mode-hook
	       (lambda ()
		 (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
		 ;; (make-local-variable 'transient-mark-mode)
		 (auto-fill-mode -1)))))
#+END_SRC

* Mode: Text

#+BEGIN_SRC emacs-lisp
;; always do auto-fill in text mode
(add-hook 'text-mode-hook
	  '(lambda ()
	     (auto-fill-mode 1)))
#+END_SRC

* Mode: Web-Mode

See http://web-mode.org/

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :init
  (setq web-mode-engines-alist '(("django" . "\\.html\\'")
                                 ("php"    . "\\.phtml\\'")
                                 ("blade"  . "\\.blade\\."))
        web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2)
  :mode ("\\.html\\'" . web-mode)
  )
#+END_SRC

* Mode: WordStar

#+BEGIN_SRC emacs-lisp
(autoload 'wsmm-mode "wsmm" "WordStar minor mode" t)
#+END_SRC

* Package: aspell

#+BEGIN_SRC emacs-lisp
; http://www.emacswiki.org/emacs-jp/InteractiveSpell
(setq ispell-program-name "aspell"
      ispell-list-command "list"
      ;; This makes aspell faster, but it will make it's suggestion worse
      ispell-extra-args '("--sug-mode=ultra")
      flyspell-issue-message-flag nil)

(defun flyspell-de ()
  "Calls Flyspell with german dictionary"
  (interactive)
  (ispell-change-dictionary "de-neu")
  (flyspell-mode 1)
  (flyspell-buffer))

(defun flyspell-en ()
  "Calls Flyspell with english dictionary"
  (interactive)
  (ispell-change-dictionary "en")
  (flyspell-mode 1)
  (flyspell-buffer))
#+END_SRC

* Package: bookmark

#+BEGIN_SRC emacs-lisp
(eval-after-load "bookmark"
  '(progn
     (setq ;; Store bookmarks inside .emacs.d
           bookmark-default-file (concat dotfiles-dir "org/bookmarks.org")
	   ;; Save file after every bookmark altertation
	   bookmark-save-flag 1
	   )))
#+END_SRC

* Package: browse-url

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "xdg-open")
#+END_SRC

* Package: calendar

#+BEGIN_SRC emacs-lisp
(setq diary-file  (concat dotfiles-dir "org/diary")
      calendar-latitude 50.17
      calendar-longitude 8.46
      calendar-location-name "Wöllstadt"
      calendar-christian-all-holidays-flag nil
      calendar-date-style 'european
      holiday-bahai-holidays nil
      holiday-hebrew-holidays nil
      holiday-islamic-holidays nil
      holiday-oriental-holidays nil
      holiday-solar-holidays nil
      calendar-holidays '((holiday-fixed 1 1 "Neujahr")
                          (holiday-easter-etc 0 "Ostern")
                          (holiday-easter-etc 1 "Ostermontag")
                          (holiday-easter-etc -2 "Karfreitag")
                          (holiday-easter-etc -46 "Aschermittwoch")
                          (holiday-fixed 12 24 "Heiligabend")
                          (holiday-fixed 12 25 "1. Weihnachtstag")
                          (holiday-fixed 12 26 "2. Weihnachtstag"))
					;(if (fboundp (quote atan)) (-equinoxes-solstices)))
      calendar-week-start-day 1
      calendar-mark-holidays-flag 1
      calendar-view-holidays-initially-flag t
      holidays-general-holidays '(holiday-fixed 1 1 "Neujahr")
      )

;; Fix foolish calendar-mode scrolling.
;; http://steve.yegge.googlepages.com/my-dot-emacs-file
(add-hook 'calendar-load-hook
	  '(lambda ()
	     (define-key calendar-mode-map ">" 'scroll-calendar-left)
	     (define-key calendar-mode-map "<" 'scroll-calendar-right)
	     (define-key calendar-mode-map "\C-x>" 'scroll-calendar-left)
	     (define-key calendar-mode-map "\C-x<" 'scroll-calendar-right)))

(add-hook 'calendar-initial-window-hook 'diary-mark-entries)
#+END_SRC

* Package: cscope

#+BEGIN_SRC emacs-lisp
;; (eval-after-load "xcscope"
(eval-after-load "xcscope"
  '(progn (setq ;; This indexer ignores .obj, .git, .svn and single-letter directories
	   cscope-indexing-script (concat dotfiles-dir "bin/cscope-indexer")
	   ;; It seems that it asks anyway ...
	   cscope-no-mouse-prompts t)
	  ))

(autoload 'cscope-find-this-symbol "xcsope" nil t)
(autoload 'cscope-pop-mark "xcsope" nil t)
(autoload 'cscope-next-symbol "xcsope" nil t)
(autoload 'cscope-prev-symbol "xcsope" nil t)

(define-key esc-map "." 'cscope-find-this-symbol)
;; ORIGINAL: find-tag (etags.el)

(define-key esc-map "*" 'cscope-pop-mark)
;; ORIGINAL: pop-tag-mark (etags.el)

(define-key esc-map "," 'cscope-next-symbol)
;; ORIGINAL: tags-loop-continue (etags.el)

(define-key esc-map ";" 'cscope-prev-symbol)
;; ORIGINAL: comment-dwim
#+END_SRC

* Package: erc (IRC client)

#+begin_src emacs-lisp
(eval-after-load "erc"
  '(progn (erc-hide-list (quote ("JOIN" "PART" "QUIT")))
   ))
#+end_src

* Package: eshell

#+BEGIN_SRC emacs-lisp
(setq eshell-cmpl-cycle-completions nil
      eshell-save-history-on-exit t
      eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'")

(eval-after-load 'esh-opt
  '(progn
     (require 'em-prompt)
     (require 'em-term)
     (require 'em-cmpl)
     (setenv "PAGER" "cat")
     (set-face-attribute 'eshell-prompt nil :foreground "turquoise1")
     (add-hook 'eshell-mode-hook ;; for some reason this needs to be a hook
	       '(lambda () (define-key eshell-mode-map "\C-a" 'eshell-bol)))
     (add-to-list 'eshell-visual-commands "ssh")
     (add-to-list 'eshell-visual-commands "tail")
     (add-to-list 'eshell-command-completions-alist
     		  '("gunzip" "gz\\'"))
     (add-to-list 'eshell-command-completions-alist
     		  '("tar" "\\(\\.tar|\\.tgz\\|\\.tar\\.gz\\)\\'"))
     ;; Somehow this clashes with magit from ELPA
     ;;(add-to-list 'eshell-output-filter-functions 'eshell-handle-ansi-color)
     ))


;; The eshell directory holds alias definitions and history
;; information.  It is much like a .bashrc file for those who are
;; familiar with bash.  This set the value of eshell-directory-name to
;; point to the eshell directory in this directory.  The alias file
;; is pre-populated with some generally applicable aliases.

;; (setq eshell-directory-name (expand-file-name "./" (expand-file-name "eshell" dotfiles-dir)))

(global-set-key (kbd "C-x m") 'eshell)
;; ORIGINAL: undefined
(global-set-key (kbd "C-x M") (lambda () (interactive) (eshell t)))
;; ORIGINAL: compose-mail
#+END_SRC

* Package: fill

#+BEGIN_SRC emacs-lisp
;; Each list element as new paragraph
;; http://www.emacswiki.org/cgi-bin/wiki/FillParagraph
(setq paragraph-start    " *\\([*+-]\\|\\([0-9]+\\|[a-zA-Z]\\)[.)]\\|$\\)"
      paragraph-separate "$")

;; Do not break line after single character when filling
(defun fill-single-char-nobreak-p ()
  "Don't break line after a single character."
  (save-excursion
    (skip-chars-backward " \t")
    (backward-char 2)
    (looking-at "[[:space:]][a-zA-Z]")))

(add-to-list 'fill-nobreak-predicate 'fill-single-char-nobreak-p)
#+END_SRC

* Package: maxima

#+BEGIN_SRC emacs-lisp
(defun my-maxima-inferior-setup ()
  (setq yas/dont-activate t))

(eval-after-load "imaxima"
  '(progn (setq imaxima-fnt-size "Large"
		imaxima-latex-preamble"\\usepackage{concrete}"
		imaxima-use-maxima-mode-flag t)
	  (add-hook 'inferior-maxima-mode-hook 'my-maxima-inferior-setup)
	  ))

(autoload 'imaxima "imaxima" nil t)


;; This function opens an imaxima buffer in the background. When I use
;; C-c C-c in the maxima-mode, the already started imaxima buffer will
;; then be re-used by maxima-display-buffer. That way I have the image
;; capable imaxima instead of the text-only maxima buffer.
(defun my-maxima-setup()
  (let ((oldbuf (current-buffer)))
    (require 'imaxima)
    (imaxima)
    (switch-to-buffer oldbuf))
  )

(eval-after-load "maxima"
  '(progn (define-key inferior-maxima-mode-map "\t" 'inferior-maxima-complete)
	  (setq maxima-use-full-color-in-process-buffer t)
	  (add-hook 'maxima-mode-hook 'my-maxima-setup)
	  ))

(autoload 'maxima-mode "maxima" nil t)

(add-to-list 'auto-mode-alist '("\\.mac$" . maxima-mode))
#+END_SRC

* Package: md-mode

#+BEGIN_SRC emacs-lisp
(autoload 'md-mode "md-mode" nil t)
(add-to-list 'auto-mode-alist '("\\.md$" . md-mode))
#+END_SRC

* Package: mediawiki

#+BEGIN_SRC emacs-lisp
;; http://www.emacswiki.org/emacs/mediawiki.el
;; (auto-install-from-url "http://launchpadlibrarian.net/59170085/mediawiki.el")
;; "http://bazaar.launchpad.net/~hexmode/mediawiki-el/trunk/download/head%3A/mediawiki.el-20100227051241-nk34zzd7aq6b02gm-1/mediawiki.el")
(eval-after-load "mediawiki"
  '(progn (setq mediawiki-site-default "Mediawiki"
		mediawiki-pop-buffer-hook '(delete-other-windows)
		mediawiki-draft-data-file (concat dotfiles-dir "tmp/draft.wiki")
		)
	  (add-to-list 'mediawiki-site-alist
		       (list "DARC"
		       	     "http://wiki.darc.de/"
		       	     "DH3HS"
		       	     "dtgabzd0"
		       	     "Harzburg"))
	  (add-to-list 'mediawiki-site-alist
		       (list "Mediawiki"
			     "http://www.mediawiki.org/w/"
			     "HolgerSchurig"
			     "dtgabzm"
			     "Sandbox"))
     ))

;; (require 'mediawiki)
;; (mediawiki-site "Mediawiki")
;; (mediawiki-site "DARC")
;; (mediawiki-open "Sandbox")
(autoload 'mediawiki-open "mediawiki" nil t)
#+END_SRC

* Package: pabbrev

#+BEGIN_SRC emacs-lisp
(autoload 'pabbrev-mode "pabbrev" nil t)
(autoload 'global-pabbrev-mode "pabbrev" nil t)

;; HINT: pabbrev.el comes from EmacsWiki, you can update it
;; with (auto-install-from-emacswiki)

;; (require 'pabbrev)
;; (global-pabbrev-mode t)
;; (setq pabbrev-read-only-error nil)
#+END_SRC

* Package: paredit

#+BEGIN_SRC emacs-lisp
;; Paredit is now loaded via package.el (elpa)
(autoload 'paredit-mode "paredit" nil t)

;; Automatically turn on in elist mode
;; (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
#+END_SRC

* Package: rcirc

#+BEGIN_SRC emacs-lisp
(eval-after-load "rcirc"
  '(progn
     (setq rcirc-prompt "%t> "
	   ;; Turn on logging everything to a special buffer, for debugging.
	   ;;rcirc-debug-flag
	   rcirc-fill-prefix "      "
	   ;; Use max. frame width
	   rcirc-fill-column 'frame-width
	   ;; Colorize inside text
	   rcirc-keywords '("schurig")
	   ;; colorize important :-) nicks
	   rcirc-bright-nicks '("schurig")
	   ;; Omit JOIN/PART/QUIT/NICK (from rcirc-omit-responses)
	   rcirc-omit-mode t
	   ;; Automatically connect:
	   rcirc-server-alist
	   '(("irc.freenode.net"
	      :channels ("#emacs"))
	     ;; ("irc.datacomm.ch"
	     ;;  :channels ("#drsrm"))
	     ;; ("irc.perl.org"
	     ;;  :channels ("#perlde"))
	     )
	   ;;rcirc-decode-coding-system 'undecided
	   ;;rcirc-coding-system-alist '(("#nihongo" undecided . iso-2022-jp))
	   rcirc-authinfo
	   '(("freenode" nickserv "schurig" "dtgabzi")
	     ;;("freenode" chanserv "bob" "#bobland" "passwd99")
	     ;;("bitlbee" bitlbee "robert" "sekrit")
	     ))
     ))
#+END_SRC

* Package: recentf

#+BEGIN_SRC emacs-lisp
;; Save recent files
(setq recentf-save-file (concat dotfiles-dir "tmp/recentf.el")
      recentf-exclude '("bbdb$"
			"svn-commit.tmp$"
			".git/COMMIT_EDITMSG$"
			".git/TAG_EDITMSG")
      recentf-max-saved-items 1000
      recentf-auto-cleanup 300
      recentf-max-menu-items 20)

(recentf-mode 1)
#+END_SRC

* Package: server

#+BEGIN_SRC emacs-lisp
;; Automatically start server, even when run interactively
(require 'server)
(unless (server-running-p)
  (server-start))

;; Make sure the frame pops up as a graphical frame
(setq server-window '(lambda (buf)
		       (switch-to-buffer buf)
		       (raise-frame))
      server-temp-file-regexp "^/tmp/Re\\|/draft\\|/.git/COMMIT_EDITMSG\\|/.git/TAG_EDITMSG$")

;; Kill buffers when done (M-x #)
(add-hook 'server-done-hook (lambda nil (kill-buffer nil)))
#+END_SRC

* Package: tramp

#+BEGIN_SRC emacs-lisp
(setq tramp-persistency-file-name (concat dotfiles-dir "tmp/tramp")
      tramp-default-method "ssh"
      ;; Relax prompt checking
      tramp-shell-prompt-pattern "^#$>\n]*[#$%>] *")
#+END_SRC

* Package: unbound

#+BEGIN_SRC emacs-lisp
;; http://www.emacswiki.org/emacs/download/unbound.el
;;
;; HINT: unbound.el comes from EmacsWiki, you can update it
;; with (auto-install-from-emacswiki)
(autoload 'describe-unbound-keys "unbound"
  "Display a list of unbound keystrokes of complexity no greater than max." t)
#+END_SRC

* Package: uniquify

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward-angle-brackets
      uniquify-separator "/"
      uniquify-after-kill-buffer-p t
      uniquify-ignore-buffers-re "^\\*")
#+END_SRC

* Package: visual-basic

#+BEGIN_SRC emacs-lisp
(autoload 'visual-basic-mode "visual-basic-mode" nil t)

(add-to-list 'auto-mode-alist '("\\.vba$" . visual-basic-mode))
#+END_SRC

* DISABLED Mode: Nimrod

#+BEGIN_SRC emacs-lisp :tangle no
(autoload 'nimrod-mode "nimrod-mode" "Nimrod editing mode." t)
(add-to-list 'auto-mode-alist '("\\.nim$" . nimrod-mode))
(add-to-list 'interpreter-mode-alist '("nim" . nimrod-mode))
#+END_SRC

* DISABLED Package: auto-install

#+BEGIN_SRC emacs-lisp :tangle no

(eval-after-load "install-elisp"
  '(setq install-elisp-repository-directory (concat dotfiles-dir "elisp/")))

(eval-after-load "url-cache"
  '(setq url-cache-directory (concat dotfiles-dir "tmp/cache/")))

(eval-after-load "auto-install"
  '(progn (setq auto-install-directory (concat dotfiles-dir "elisp/"))
	  ))

;; HINT: auto-install.el comes from EmacsWiki, you can update it
;; with (auto-install-from-emacswiki)

;; (require 'auto-install nil 'nomsg)
;; (auto-install-update-emacswiki-package-name t)
(autoload 'auto-install-from-emacswiki "auto-install" nil t)
(autoload 'auto-install-from-url "auto-install" nil t)
#+END_SRC

* DISABLED Package: desktop

#+RC emacs-lisp :tangle no
;;/www.emacswiki.org/emacs/DeskTop

;;desktop-base-file-name (concat dotfiles-dir "tmp/desktop.data")
;;desktop-base-lock-name (concat dotfiles-dir "tmp/desktop.lock")
;;desktop-save t
;;desktop-load-locked-desktop t
;;desktop-buffers-not-to-save
;;(concat "\\("
;;     "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
;;     "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
;;     "\\)$"))
;;op-save-mode 1)

;;o-list 'desktop-modes-not-to-save 'dired-mode)
;;o-list 'desktop-modes-not-to-save 'org-mode)
;;o-list 'desktop-modes-not-to-save 'Info-mode)
;;o-list 'desktop-modes-not-to-save 'info-lookup-mode)
;;o-list 'desktop-modes-not-to-save 'fundamental-mode)
;;need to save them, as the history will be handled by
;;entf and recentf-initialize-file-name-history, but
;;y if file-name-history is empty ...
;;'file-name-history desktop-globals-to-save)
;;o-list 'desktop-globals-to-save 'compile-command)
#+

* DISABLED Package: eproject

#+RC emacs-lisp :tangle no
;;re 'eproject nil t)
;;eproject-completing-read-function (quote eproject--ido-completing-read))

;;uire 'eprojects)
;;(concat dotfiles-dir "eprojects.el") 'noerror 'nomessage)


;;ppets from eproject-extra.el:

;; eproject-grep (regexp)
;;rch all files in the current project for REGEXP."
;;eractive "sRegexp grep: ")
;;* ((root (eproject-root))
;;   (default-directory root)
;;   (files (eproject-list-project-files-relative root)))
;;rep-compute-defaults)
;;grep regexp (combine-and-quote-strings files) root)))

;;r eproject-todo-expressions
;;ODO" "XXX" "FIXME")
;;ist of tags for `eproject-todo' to search for when generating the project's TODO list.")

;; eproject-todo ()
;;play a project TODO list.

;;ize `eproject-todo-expressions' to control what this function looks for."
;;eractive)
;;ODO: display output in a buffer called *<project>-TODO* instead of *grep*.
;;oject-grep (regexp-opt eproject-todo-expressions)))
#+

* DISABLED Package: skeleton

#+BEGIN_SRC emacs-lisp :tangle no
;; Skeleton pairs
;; (global-set-key (kbd "(") 'skeleton-pair-insert-maybe)
;; (global-set-key (kbd "[") 'skeleton-pair-insert-maybe)
;; (global-set-key (kbd "{") 'skeleton-pair-insert-maybe)
;; (global-set-key (kbd "\"") 'skeleton-pair-insert-maybe)

;; ;; If this function returns nil, then pairing is attempted
;; (defun my-skeleton-pair-filter-function ()
;;   (cond
;;    ;; if the just-entered skeleton char is a quote char
;;    ((eq last-command-char ?\")
;;     (or (looking-at   (regexp-quote (string last-command-char)))
;; 	(looking-back (regexp-quote (string last-command-char)))
;; 	(looking-back "[[:graph:]]")
;; 	))
;;    ;; For other skeleton chars
;;    (t
;;     (looking-at (regexp-quote (string last-command-char))))))

;; (setq skeleton-pair t
;;       skeleton-pair-filter-function 'my-skeleton-pair-filter-function)
#+END_SRC

* Key bindings

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-xE"		'apply-macro-to-region-lines)
;; ORIGINAL: kmacro-and-and-call-macro (on \C-Xe)

(global-set-key "\C-x\\"	'align-regexp)
;; ORIGINAL: undefined

(global-set-key "\C-c\C-f"	'ff-find-other-file)
;; ORIGINAL: undefined

(global-set-key "\C-cc"		'comment-region)
;; ORIGINAL: undefined

(global-set-key "\C-cu"		'uncomment-region)
;; ORIGINAL: undefined

(global-set-key (kbd "C-;")     'comment-dwim)
;; ORIGINAL: undefined


;; Don't iconify
(when window-system
  (global-unset-key "\C-z"))

;; Enable some normally disabled functions
;; (put 'capitalize-region 'disabled nil)
;; (put 'dired-find-alternate-file 'disabled nil)
;; (put 'downcase-region 'disabled nil)
;; (put 'erase-buffer 'disabled nil)
;; (put 'eval-expression 'disabled nil)
;; (put 'narrow-to-region 'disabled nil)
;; (put 'scroll-left 'disabled nil)
;; (put 'upcase-region 'disabled nil)

;; Enable all disabled commands
(setq disabled-command-function nil)

;; Don't bother entering search and replace args if the buffer is read-only
(defadvice query-replace-read-args (before barf-if-buffer-read-only activate)
  "Signal a `buffer-read-only' error if the current buffer is read-only."
  (barf-if-buffer-read-only))
#+END_SRC

* Trailer
#+begin_src emacs-lisp
(message "NOTE: emacs.org loaded")
#+end_src
